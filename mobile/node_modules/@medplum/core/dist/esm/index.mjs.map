{
  "version": 3,
  "sources": ["../../src/fhirlexer/parse.ts", "../../src/cache.ts", "../../src/constants.ts", "../../src/outcomes.ts", "../../src/base-schema.ts", "../../src/base-schema.json", "../../src/typeschema/types.ts", "../../src/typeschema/crawler.ts", "../../src/typeschema/validation.ts", "../../src/fhirpath/utils.ts", "../../src/utils.ts", "../../src/format.ts", "../../src/types.ts", "../../src/fhirpath/date.ts", "../../src/fhirpath/functions.ts", "../../src/fhirpath/atoms.ts", "../../src/fhirlexer/tokenize.ts", "../../src/fhirpath/tokenize.ts", "../../src/fhirpath/parse.ts", "../../src/search/details.ts", "../../src/search/search.ts", "../../src/search/match.ts", "../../src/access.ts", "../../src/base64.ts", "../../src/crypto.ts", "../../src/bundle.ts", "../../src/contenttype.ts", "../../src/eventtarget.ts", "../../src/fhircast/index.ts", "../../src/jwt.ts", "../../src/keyvalue.ts", "../../src/readablepromise.ts", "../../src/storage.ts", "../../src/websockets/reconnecting-websocket.ts", "../../src/subscriptions/index.ts", "../../src/client.ts", "../../src/config.ts", "../../src/datasampler.ts", "../../src/elements-context.ts", "../../src/typeschema/slices.ts", "../../src/schema-crawler.ts", "../../src/default-values.ts", "../../src/fhirmapper/conceptmaptranslate.ts", "../../src/fhirmapper/tokenize.ts", "../../src/fhirmapper/parse.ts", "../../src/fhirmapper/transform.ts", "../../src/filebuilder.ts", "../../src/filter/tokenize.ts", "../../src/filter/types.ts", "../../src/filter/parse.ts", "../../src/hl7.ts", "../../src/logger.ts", "../../src/schema.ts", "../../src/sftp.ts", "../../src/sql-on-fhir/eval.ts", "../../src/version-utils.ts"],
  "sourcesContent": ["import { TypedValue } from '../types';\nimport { Token } from './tokenize';\n\nexport interface AtomContext {\n  parent?: AtomContext;\n  variables: Record<string, TypedValue>;\n}\nexport interface Atom {\n  eval(context: AtomContext, input: TypedValue[]): TypedValue[];\n\n  toString(): string;\n}\n\nexport abstract class PrefixOperatorAtom implements Atom {\n  readonly operator: string;\n  readonly child: Atom;\n\n  constructor(operator: string, child: Atom) {\n    this.operator = operator;\n    this.child = child;\n  }\n\n  abstract eval(context: AtomContext, input: TypedValue[]): TypedValue[];\n\n  toString(): string {\n    return `${this.operator}(${this.child.toString()})`;\n  }\n}\n\nexport abstract class InfixOperatorAtom implements Atom {\n  readonly operator: string;\n  readonly left: Atom;\n  readonly right: Atom;\n\n  constructor(operator: string, left: Atom, right: Atom) {\n    this.operator = operator;\n    this.left = left;\n    this.right = right;\n  }\n\n  abstract eval(context: AtomContext, input: TypedValue[]): TypedValue[];\n\n  toString(): string {\n    return `(${this.left.toString()} ${this.operator} ${this.right.toString()})`;\n  }\n}\n\nexport interface PrefixParselet {\n  parse(parser: Parser, token: Token): Atom;\n}\n\nexport interface InfixParselet {\n  precedence: number;\n  parse?(parser: Parser, left: Atom, token: Token): Atom;\n}\n\nexport class ParserBuilder {\n  private readonly prefixParselets: Record<string, PrefixParselet> = {};\n  private readonly infixParselets: Record<string, InfixParselet> = {};\n\n  public registerInfix(tokenType: string, parselet: InfixParselet): this {\n    this.infixParselets[tokenType] = parselet;\n    return this;\n  }\n\n  public registerPrefix(tokenType: string, parselet: PrefixParselet): this {\n    this.prefixParselets[tokenType] = parselet;\n    return this;\n  }\n\n  public prefix(tokenType: string, precedence: number, builder: (token: Token, right: Atom) => Atom): this {\n    return this.registerPrefix(tokenType, {\n      parse(parser, token) {\n        const right = parser.consumeAndParse(precedence);\n        return builder(token, right);\n      },\n    });\n  }\n\n  public infixLeft(\n    tokenType: string,\n    precedence: number,\n    builder: (left: Atom, token: Token, right: Atom) => Atom\n  ): this {\n    return this.registerInfix(tokenType, {\n      parse(parser, left, token) {\n        const right = parser.consumeAndParse(precedence);\n        return builder(left, token, right);\n      },\n      precedence,\n    });\n  }\n\n  public construct(input: Token[]): Parser {\n    return new Parser(input, this.prefixParselets, this.infixParselets);\n  }\n}\n\nexport class Parser {\n  private tokens: Token[];\n  private readonly prefixParselets: Record<string, PrefixParselet>;\n  private readonly infixParselets: Record<string, InfixParselet>;\n\n  constructor(\n    tokens: Token[],\n    prefixParselets: Record<string, PrefixParselet>,\n    infixParselets: Record<string, InfixParselet>\n  ) {\n    this.tokens = tokens;\n    this.prefixParselets = prefixParselets;\n    this.infixParselets = infixParselets;\n  }\n\n  hasMore(): boolean {\n    return this.tokens.length > 0;\n  }\n\n  match(expected: string): boolean {\n    const token = this.peek();\n    if (token?.id !== expected) {\n      return false;\n    }\n\n    this.consume();\n    return true;\n  }\n\n  consumeAndParse(precedence = Infinity): Atom {\n    const token = this.consume();\n    const prefix = this.prefixParselets[token.id];\n    if (!prefix) {\n      throw Error(\n        `Parse error at \"${token.value}\" (line ${token.line}, column ${token.column}). No matching prefix parselet.`\n      );\n    }\n\n    let left = prefix.parse(this, token);\n\n    while (precedence > this.getPrecedence()) {\n      const next = this.consume();\n      const infix = this.getInfixParselet(next) as InfixParselet;\n      left = (infix.parse as (parser: Parser, left: Atom, token: Token) => Atom)(this, left, next);\n    }\n\n    return left;\n  }\n\n  getPrecedence(): number {\n    const nextToken = this.peek();\n    if (!nextToken) {\n      return Infinity;\n    }\n    const parser = this.getInfixParselet(nextToken);\n    if (parser) {\n      return parser.precedence;\n    }\n    return Infinity;\n  }\n\n  consume(expectedId?: string, expectedValue?: string): Token {\n    if (!this.tokens.length) {\n      throw Error('Cant consume unknown more tokens.');\n    }\n    if (expectedId && this.peek()?.id !== expectedId) {\n      const actual = this.peek() as Token;\n      throw Error(\n        `Expected ${expectedId} but got \"${actual.id}\" (${actual.value}) at line ${actual.line} column ${actual.column}.`\n      );\n    }\n    if (expectedValue && this.peek()?.value !== expectedValue) {\n      const actual = this.peek() as Token;\n      throw Error(\n        `Expected \"${expectedValue}\" but got \"${actual.value}\" at line ${actual.line} column ${actual.column}.`\n      );\n    }\n    return this.tokens.shift() as Token;\n  }\n\n  peek(): Token | undefined {\n    return this.tokens.length > 0 ? this.tokens[0] : undefined;\n  }\n\n  removeComments(): void {\n    this.tokens = this.tokens.filter((t) => t.id !== 'Comment');\n  }\n\n  getInfixParselet(token: Token): InfixParselet | undefined {\n    return this.infixParselets[token.id === 'Symbol' ? token.value : token.id];\n  }\n}\n", "/**\n * LRU cache (least recently used)\n * Source: https://stackoverflow.com/a/46432113\n */\nexport class LRUCache<T> {\n  private readonly max: number;\n  private readonly cache: Map<string, T>;\n\n  constructor(max = 10) {\n    this.max = max;\n    this.cache = new Map();\n  }\n\n  /**\n   * Deletes all values from the cache.\n   */\n  clear(): void {\n    this.cache.clear();\n  }\n\n  /**\n   * Returns the value for the given key.\n   * @param key - The key to retrieve.\n   * @returns The value if found; undefined otherwise.\n   */\n  get(key: string): T | undefined {\n    const item = this.cache.get(key);\n    if (item) {\n      this.cache.delete(key);\n      this.cache.set(key, item);\n    }\n    return item;\n  }\n\n  /**\n   * Sets the value for the given key.\n   * @param key - The key to set.\n   * @param val - The value to set.\n   */\n  set(key: string, val: T): void {\n    if (this.cache.has(key)) {\n      this.cache.delete(key);\n    } else if (this.cache.size >= this.max) {\n      this.cache.delete(this.first());\n    }\n    this.cache.set(key, val);\n  }\n\n  /**\n   * Deletes the value for the given key.\n   * @param key - The key to delete.\n   */\n  delete(key: string): void {\n    this.cache.delete(key);\n  }\n\n  /**\n   * Returns the list of all keys in the cache.\n   * @returns The array of keys in the cache.\n   */\n  keys(): IterableIterator<string> {\n    return this.cache.keys();\n  }\n\n  private first(): string {\n    // This works because the Map class maintains ordered keys.\n    return this.cache.keys().next().value as string;\n  }\n}\n", "// Common terminology systems, taken from https://terminology.hl7.org/external_terminologies.html\nexport const UCUM = 'http://unitsofmeasure.org';\nexport const LOINC = 'http://loinc.org';\nexport const SNOMED = 'http://snomed.info/sct';\nexport const RXNORM = 'http://www.nlm.nih.gov/research/umls/rxnorm';\nexport const CPT = 'http://www.ama-assn.org/go/cpt';\nexport const ICD10 = 'http://hl7.org/fhir/sid/icd-10';\nexport const NDC = 'http://hl7.org/fhir/sid/ndc';\n\n// common http-based origins useful for avoiding false-positives about preferring https over http,\n// e.g. https://rules.sonarsource.com/javascript/type/Security%20Hotspot/RSPEC-5332/\nexport const HTTP_HL7_ORG = 'http://hl7.org';\nexport const HTTP_TERMINOLOGY_HL7_ORG = 'http://terminology.hl7.org';\n", "import { OperationOutcome, OperationOutcomeIssue } from '@medplum/fhirtypes';\nimport { Constraint } from './typeschema/types';\n\nconst OK_ID = 'ok';\nconst CREATED_ID = 'created';\nconst GONE_ID = 'gone';\nconst NOT_MODIFIED_ID = 'not-modified';\nconst FOUND_ID = 'found';\nconst NOT_FOUND_ID = 'not-found';\nconst CONFLICT_ID = 'conflict';\nconst UNAUTHORIZED_ID = 'unauthorized';\nconst FORBIDDEN_ID = 'forbidden';\nconst PRECONDITION_FAILED_ID = 'precondition-failed';\nconst MULTIPLE_MATCHES_ID = 'multiple-matches';\nconst TOO_MANY_REQUESTS_ID = 'too-many-requests';\nconst ACCEPTED_ID = 'accepted';\nconst SERVER_TIMEOUT_ID = 'server-timeout';\n\nexport const allOk: OperationOutcome = {\n  resourceType: 'OperationOutcome',\n  id: OK_ID,\n  issue: [\n    {\n      severity: 'information',\n      code: 'informational',\n      details: {\n        text: 'All OK',\n      },\n    },\n  ],\n};\n\nexport const created: OperationOutcome = {\n  resourceType: 'OperationOutcome',\n  id: CREATED_ID,\n  issue: [\n    {\n      severity: 'information',\n      code: 'informational',\n      details: {\n        text: 'Created',\n      },\n    },\n  ],\n};\n\nexport const notModified: OperationOutcome = {\n  resourceType: 'OperationOutcome',\n  id: NOT_MODIFIED_ID,\n  issue: [\n    {\n      severity: 'information',\n      code: 'informational',\n      details: {\n        text: 'Not Modified',\n      },\n    },\n  ],\n};\n\nexport const notFound: OperationOutcome = {\n  resourceType: 'OperationOutcome',\n  id: NOT_FOUND_ID,\n  issue: [\n    {\n      severity: 'error',\n      code: 'not-found',\n      details: {\n        text: 'Not found',\n      },\n    },\n  ],\n};\n\nexport const unauthorized: OperationOutcome = {\n  resourceType: 'OperationOutcome',\n  id: UNAUTHORIZED_ID,\n  issue: [\n    {\n      severity: 'error',\n      code: 'login',\n      details: {\n        text: 'Unauthorized',\n      },\n    },\n  ],\n};\n\nexport const unauthorizedTokenExpired: OperationOutcome = {\n  ...unauthorized,\n  issue: [\n    ...unauthorized.issue,\n    {\n      severity: 'error',\n      code: 'expired',\n      details: {\n        text: 'Token expired',\n      },\n    },\n  ],\n};\n\nexport const unauthorizedTokenAudience: OperationOutcome = {\n  ...unauthorized,\n  issue: [\n    ...unauthorized.issue,\n    {\n      severity: 'error',\n      code: 'invalid',\n      details: {\n        text: 'Token not issued for this audience',\n      },\n    },\n  ],\n};\n\nexport const forbidden: OperationOutcome = {\n  resourceType: 'OperationOutcome',\n  id: FORBIDDEN_ID,\n  issue: [\n    {\n      severity: 'error',\n      code: 'forbidden',\n      details: {\n        text: 'Forbidden',\n      },\n    },\n  ],\n};\n\nexport const gone: OperationOutcome = {\n  resourceType: 'OperationOutcome',\n  id: GONE_ID,\n  issue: [\n    {\n      severity: 'error',\n      code: 'deleted',\n      details: {\n        text: 'Gone',\n      },\n    },\n  ],\n};\n\nexport const preconditionFailed: OperationOutcome = {\n  resourceType: 'OperationOutcome',\n  id: PRECONDITION_FAILED_ID,\n  issue: [\n    {\n      severity: 'error',\n      code: 'processing',\n      details: {\n        text: 'Precondition Failed',\n      },\n    },\n  ],\n};\n\nexport const multipleMatches: OperationOutcome = {\n  resourceType: 'OperationOutcome',\n  id: MULTIPLE_MATCHES_ID,\n  issue: [\n    {\n      severity: 'error',\n      code: 'multiple-matches',\n      details: {\n        text: 'Multiple resources found matching condition',\n      },\n    },\n  ],\n};\n\nexport const tooManyRequests: OperationOutcome = {\n  resourceType: 'OperationOutcome',\n  id: TOO_MANY_REQUESTS_ID,\n  issue: [\n    {\n      severity: 'error',\n      code: 'throttled',\n      details: {\n        text: 'Too Many Requests',\n      },\n    },\n  ],\n};\n\nexport function accepted(location: string): OperationOutcome {\n  return {\n    resourceType: 'OperationOutcome',\n    id: ACCEPTED_ID,\n    issue: [\n      {\n        severity: 'information',\n        code: 'informational',\n        details: {\n          text: 'Accepted',\n        },\n        diagnostics: location,\n      },\n    ],\n  };\n}\n\nexport function badRequest(details: string, expression?: string): OperationOutcome {\n  return {\n    resourceType: 'OperationOutcome',\n    issue: [\n      {\n        severity: 'error',\n        code: 'invalid',\n        details: {\n          text: details,\n        },\n        ...(expression ? { expression: [expression] } : undefined),\n      },\n    ],\n  };\n}\n\nexport function conflict(details: string, code?: string): OperationOutcome {\n  return {\n    resourceType: 'OperationOutcome',\n    id: CONFLICT_ID,\n    issue: [\n      {\n        severity: 'error',\n        code: 'conflict',\n        details: {\n          coding: code ? [{ code }] : undefined,\n          text: details,\n        },\n      },\n    ],\n  };\n}\n\nexport function validationError(details: string): OperationOutcome {\n  return {\n    resourceType: 'OperationOutcome',\n    issue: [\n      {\n        severity: 'error',\n        code: 'structure',\n        details: {\n          text: details,\n        },\n      },\n    ],\n  };\n}\n\nexport function serverError(err: Error): OperationOutcome {\n  return {\n    resourceType: 'OperationOutcome',\n    issue: [\n      {\n        severity: 'error',\n        code: 'exception',\n        details: {\n          text: 'Internal server error',\n        },\n        diagnostics: err.toString(),\n      },\n    ],\n  };\n}\n\nexport function serverTimeout(msg?: string): OperationOutcome {\n  return {\n    resourceType: 'OperationOutcome',\n    id: SERVER_TIMEOUT_ID,\n    issue: [\n      {\n        severity: 'error',\n        code: 'timeout',\n        details: {\n          text: msg ?? 'Server timeout',\n        },\n      },\n    ],\n  };\n}\n\nexport function redirect(url: URL): OperationOutcome {\n  const urlStr = url.toString();\n  return {\n    resourceType: 'OperationOutcome',\n    id: FOUND_ID,\n    issue: [\n      {\n        severity: 'information',\n        code: 'informational',\n        details: {\n          coding: [{ system: 'urn:ietf:rfc:3986', code: urlStr }],\n          text: 'Redirect to ' + urlStr,\n        },\n      },\n    ],\n  };\n}\n\nexport function isOperationOutcome(value: unknown): value is OperationOutcome {\n  return typeof value === 'object' && value !== null && (value as any).resourceType === 'OperationOutcome';\n}\n\nexport function isOk(outcome: OperationOutcome): boolean {\n  return (\n    outcome.id === OK_ID || outcome.id === CREATED_ID || outcome.id === NOT_MODIFIED_ID || outcome.id === ACCEPTED_ID\n  );\n}\n\nexport function isCreated(outcome: OperationOutcome): boolean {\n  return outcome.id === CREATED_ID;\n}\n\nexport function isAccepted(outcome: OperationOutcome): boolean {\n  return outcome.id === ACCEPTED_ID;\n}\n\nexport function isRedirect(outcome: OperationOutcome): boolean {\n  return outcome.id === FOUND_ID;\n}\n\nexport function isNotFound(outcome: OperationOutcome): boolean {\n  return outcome.id === NOT_FOUND_ID;\n}\n\nexport function isConflict(outcome: OperationOutcome): boolean {\n  return outcome.id === CONFLICT_ID;\n}\n\nexport function isGone(outcome: OperationOutcome): boolean {\n  return outcome.id === GONE_ID;\n}\n\nexport function isUnauthenticated(outcome: OperationOutcome): boolean {\n  return outcome.id === UNAUTHORIZED_ID;\n}\n\nexport function getStatus(outcome: OperationOutcome): number {\n  switch (outcome.id) {\n    case OK_ID:\n      return 200;\n    case CREATED_ID:\n      return 201;\n    case ACCEPTED_ID:\n      return 202;\n    case FOUND_ID:\n      return 302;\n    case NOT_MODIFIED_ID:\n      return 304;\n    case UNAUTHORIZED_ID:\n      return 401;\n    case FORBIDDEN_ID:\n      return 403;\n    case NOT_FOUND_ID:\n      return 404;\n    case CONFLICT_ID:\n      return 409;\n    case GONE_ID:\n      return 410;\n    case PRECONDITION_FAILED_ID:\n    case MULTIPLE_MATCHES_ID:\n      return 412;\n    case TOO_MANY_REQUESTS_ID:\n      return 429;\n    case SERVER_TIMEOUT_ID:\n      return 504;\n    default:\n      return outcome.issue?.[0]?.code === 'exception' ? 500 : 400;\n  }\n}\n\n/**\n * Asserts that the operation completed successfully and that the resource is defined.\n * @param outcome - The operation outcome.\n * @param resource - The resource that may or may not have been returned.\n */\nexport function assertOk<T>(outcome: OperationOutcome, resource: T | undefined): asserts resource is T {\n  if (!isOk(outcome) || resource === undefined) {\n    throw new OperationOutcomeError(outcome);\n  }\n}\n\nexport class OperationOutcomeError extends Error {\n  readonly outcome: OperationOutcome;\n\n  constructor(outcome: OperationOutcome, cause?: unknown) {\n    super(operationOutcomeToString(outcome));\n    this.outcome = outcome;\n    this.cause = cause;\n  }\n}\n\n/**\n * Normalizes an error object into an OperationOutcome.\n * @param error - The error value which could be a string, Error, OperationOutcome, or other unknown type.\n * @returns The normalized OperationOutcome.\n */\nexport function normalizeOperationOutcome(error: unknown): OperationOutcome {\n  if (error instanceof OperationOutcomeError) {\n    return error.outcome;\n  }\n  if (isOperationOutcome(error)) {\n    return error;\n  }\n  return badRequest(normalizeErrorString(error));\n}\n\n/**\n * Normalizes an error object into a displayable error string.\n * @param error - The error value which could be a string, Error, OperationOutcome, or other unknown type.\n * @returns A display string for the error.\n */\nexport function normalizeErrorString(error: unknown): string {\n  if (!error) {\n    return 'Unknown error';\n  }\n  if (typeof error === 'string') {\n    return error;\n  }\n  if (error instanceof Error) {\n    return error.message;\n  }\n  if (isOperationOutcome(error)) {\n    return operationOutcomeToString(error);\n  }\n  if (typeof error === 'object' && 'code' in error && typeof error.code === 'string') {\n    return error.code;\n  }\n  return JSON.stringify(error);\n}\n\n/**\n * Returns a string represenation of the operation outcome.\n * @param outcome - The operation outcome.\n * @returns The string representation of the operation outcome.\n */\nexport function operationOutcomeToString(outcome: OperationOutcome): string {\n  const strs = outcome.issue?.map(operationOutcomeIssueToString) ?? [];\n  return strs.length > 0 ? strs.join('; ') : 'Unknown error';\n}\n\n/**\n * Returns a string represenation of the operation outcome issue.\n * @param issue - The operation outcome issue.\n * @returns The string representation of the operation outcome issue.\n */\nexport function operationOutcomeIssueToString(issue: OperationOutcomeIssue): string {\n  let issueStr;\n  if (issue.details?.text) {\n    if (issue.diagnostics) {\n      issueStr = `${issue.details.text} (${issue.diagnostics})`;\n    } else {\n      issueStr = issue.details.text;\n    }\n  } else if (issue.diagnostics) {\n    issueStr = issue.diagnostics;\n  } else {\n    issueStr = 'Unknown error';\n  }\n  if (issue.expression?.length) {\n    issueStr += ` (${issue.expression.join(', ')})`;\n  }\n  return issueStr;\n}\n\nexport type IssueSeverity = 'error' | 'fatal' | 'warning' | 'information';\nexport type IssueType = 'structure' | 'invariant' | 'processing';\n\nexport function createOperationOutcomeIssue(\n  severity: IssueSeverity,\n  code: IssueType,\n  message: string,\n  path: string,\n  data?: Record<string, any>\n): OperationOutcomeIssue {\n  const issue: OperationOutcomeIssue = {\n    severity,\n    code,\n    details: {\n      text: message,\n    },\n    expression: [path],\n  };\n  if (data) {\n    issue.diagnostics = JSON.stringify(data);\n  }\n  return issue;\n}\n\nexport function createStructureIssue(expression: string, details: string): OperationOutcomeIssue {\n  return createOperationOutcomeIssue('error', 'structure', details, expression);\n}\n\nexport function createConstraintIssue(expression: string, constraint: Constraint): OperationOutcomeIssue {\n  return createOperationOutcomeIssue(\n    'error',\n    'invariant',\n    `Constraint ${constraint.key} not met: ${constraint.description}`,\n    expression,\n    {\n      fhirpath: constraint.expression,\n    }\n  );\n}\n\nexport function createProcessingIssue(\n  expression: string,\n  message: string,\n  err: Error,\n  data?: Record<string, any>\n): OperationOutcomeIssue {\n  return createOperationOutcomeIssue('error', 'processing', message, expression, { ...data, error: err });\n}\n", "import { InternalSchemaElement, InternalTypeSchema } from './typeschema/types';\n\nexport type BaseSchema = Record<string, { elements: Record<string, Partial<InternalSchemaElement>> }>;\n\nconst normalizedTypes: Record<string, string> = {\n  'http://hl7.org/fhirpath/System.String': 'string',\n};\n\nexport function compressElement(element: InternalSchemaElement): Partial<InternalSchemaElement> {\n  // For each property, only keep \"min\", \"max\", and \"type\"\n  // Only keep \"min\" if not 0\n  // Only keep \"max\" if not 1\n  const outputPropertySchema: Partial<InternalSchemaElement> = {};\n  if (element.min !== 0) {\n    outputPropertySchema.min = element.min;\n  }\n\n  if (element.max !== 1 && Number.isFinite(element.max)) {\n    outputPropertySchema.max = element.max;\n  } else if (element.max === Number.POSITIVE_INFINITY) {\n    outputPropertySchema.max = Number.MAX_SAFE_INTEGER;\n  }\n\n  outputPropertySchema.type = element.type?.map((t) => ({\n    ...t,\n    extension: undefined,\n    code: normalizedTypes[t.code] ?? t.code,\n  }));\n  return outputPropertySchema;\n}\n\nexport function inflateElement(path: string, partial: Partial<InternalSchemaElement>): InternalSchemaElement {\n  const max = partial.max && partial.max === Number.MAX_SAFE_INTEGER ? Number.POSITIVE_INFINITY : partial.max;\n  return {\n    path,\n    description: '',\n    type: partial.type ?? [],\n    min: partial.min ?? 0,\n    max: max ?? 1,\n    isArray: !!max && max > 1,\n    constraints: [],\n  };\n}\n\nexport type DataTypesMap = { [type: string]: InternalTypeSchema };\n\nexport function inflateBaseSchema(base: BaseSchema): DataTypesMap {\n  const output: DataTypesMap = Object.create(null);\n  for (const [key, schema] of Object.entries(base)) {\n    output[key] = {\n      name: key,\n      type: key,\n      path: key,\n      elements: Object.fromEntries(\n        Object.entries(schema.elements).map(([property, partial]) => [property, inflateElement(property, partial)])\n      ),\n      constraints: [],\n      innerTypes: [],\n    };\n  }\n  return output;\n}\n", "{\n  \"Element\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      }\n    }\n  },\n  \"BackboneElement\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"modifierExtension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      }\n    }\n  },\n  \"Address\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"use\": {\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      },\n      \"type\": {\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      },\n      \"text\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"line\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"city\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"district\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"state\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"postalCode\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"country\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"period\": {\n        \"type\": [\n          {\n            \"code\": \"Period\"\n          }\n        ]\n      }\n    }\n  },\n  \"Age\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"value\": {\n        \"type\": [\n          {\n            \"code\": \"decimal\"\n          }\n        ]\n      },\n      \"comparator\": {\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      },\n      \"unit\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"system\": {\n        \"type\": [\n          {\n            \"code\": \"uri\"\n          }\n        ]\n      },\n      \"code\": {\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      }\n    }\n  },\n  \"Annotation\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"author[x]\": {\n        \"type\": [\n          {\n            \"code\": \"Reference\",\n            \"targetProfile\": [\n              \"http://hl7.org/fhir/StructureDefinition/Practitioner\",\n              \"http://hl7.org/fhir/StructureDefinition/Patient\",\n              \"http://hl7.org/fhir/StructureDefinition/RelatedPerson\",\n              \"http://hl7.org/fhir/StructureDefinition/Organization\"\n            ]\n          },\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"time\": {\n        \"type\": [\n          {\n            \"code\": \"dateTime\"\n          }\n        ]\n      },\n      \"text\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"markdown\"\n          }\n        ]\n      }\n    }\n  },\n  \"Attachment\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"contentType\": {\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      },\n      \"language\": {\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      },\n      \"data\": {\n        \"type\": [\n          {\n            \"code\": \"base64Binary\"\n          }\n        ]\n      },\n      \"url\": {\n        \"type\": [\n          {\n            \"code\": \"url\"\n          }\n        ]\n      },\n      \"size\": {\n        \"type\": [\n          {\n            \"code\": \"unsignedInt\"\n          }\n        ]\n      },\n      \"hash\": {\n        \"type\": [\n          {\n            \"code\": \"base64Binary\"\n          }\n        ]\n      },\n      \"title\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"creation\": {\n        \"type\": [\n          {\n            \"code\": \"dateTime\"\n          }\n        ]\n      }\n    }\n  },\n  \"CodeableConcept\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"coding\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Coding\"\n          }\n        ]\n      },\n      \"text\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      }\n    }\n  },\n  \"Coding\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"system\": {\n        \"type\": [\n          {\n            \"code\": \"uri\"\n          }\n        ]\n      },\n      \"version\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"code\": {\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      },\n      \"display\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"userSelected\": {\n        \"type\": [\n          {\n            \"code\": \"boolean\"\n          }\n        ]\n      }\n    }\n  },\n  \"ContactDetail\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"name\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"telecom\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"ContactPoint\"\n          }\n        ]\n      }\n    }\n  },\n  \"ContactPoint\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"system\": {\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      },\n      \"value\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"use\": {\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      },\n      \"rank\": {\n        \"type\": [\n          {\n            \"code\": \"positiveInt\"\n          }\n        ]\n      },\n      \"period\": {\n        \"type\": [\n          {\n            \"code\": \"Period\"\n          }\n        ]\n      }\n    }\n  },\n  \"Contributor\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"type\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      },\n      \"name\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"contact\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"ContactDetail\"\n          }\n        ]\n      }\n    }\n  },\n  \"Count\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"value\": {\n        \"type\": [\n          {\n            \"code\": \"decimal\"\n          }\n        ]\n      },\n      \"comparator\": {\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      },\n      \"unit\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"system\": {\n        \"type\": [\n          {\n            \"code\": \"uri\"\n          }\n        ]\n      },\n      \"code\": {\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      }\n    }\n  },\n  \"DataRequirement\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"type\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      },\n      \"profile\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"canonical\",\n            \"targetProfile\": [\"http://hl7.org/fhir/StructureDefinition/StructureDefinition\"]\n          }\n        ]\n      },\n      \"subject[x]\": {\n        \"type\": [\n          {\n            \"code\": \"CodeableConcept\"\n          },\n          {\n            \"code\": \"Reference\",\n            \"targetProfile\": [\"http://hl7.org/fhir/StructureDefinition/Group\"]\n          }\n        ]\n      },\n      \"mustSupport\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"codeFilter\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"DataRequirementCodeFilter\"\n          }\n        ]\n      },\n      \"dateFilter\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"DataRequirementDateFilter\"\n          }\n        ]\n      },\n      \"limit\": {\n        \"type\": [\n          {\n            \"code\": \"positiveInt\"\n          }\n        ]\n      },\n      \"sort\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"DataRequirementSort\"\n          }\n        ]\n      }\n    }\n  },\n  \"DataRequirementCodeFilter\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"path\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"searchParam\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"valueSet\": {\n        \"type\": [\n          {\n            \"code\": \"canonical\",\n            \"targetProfile\": [\"http://hl7.org/fhir/StructureDefinition/ValueSet\"]\n          }\n        ]\n      },\n      \"code\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Coding\"\n          }\n        ]\n      }\n    }\n  },\n  \"DataRequirementDateFilter\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"path\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"searchParam\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"value[x]\": {\n        \"type\": [\n          {\n            \"code\": \"dateTime\"\n          },\n          {\n            \"code\": \"Period\"\n          },\n          {\n            \"code\": \"Duration\"\n          }\n        ]\n      }\n    }\n  },\n  \"DataRequirementSort\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"path\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"direction\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      }\n    }\n  },\n  \"Distance\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"value\": {\n        \"type\": [\n          {\n            \"code\": \"decimal\"\n          }\n        ]\n      },\n      \"comparator\": {\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      },\n      \"unit\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"system\": {\n        \"type\": [\n          {\n            \"code\": \"uri\"\n          }\n        ]\n      },\n      \"code\": {\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      }\n    }\n  },\n  \"Dosage\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"modifierExtension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"sequence\": {\n        \"type\": [\n          {\n            \"code\": \"integer\"\n          }\n        ]\n      },\n      \"text\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"additionalInstruction\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"CodeableConcept\"\n          }\n        ]\n      },\n      \"patientInstruction\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"timing\": {\n        \"type\": [\n          {\n            \"code\": \"Timing\"\n          }\n        ]\n      },\n      \"asNeeded[x]\": {\n        \"type\": [\n          {\n            \"code\": \"boolean\"\n          },\n          {\n            \"code\": \"CodeableConcept\"\n          }\n        ]\n      },\n      \"site\": {\n        \"type\": [\n          {\n            \"code\": \"CodeableConcept\"\n          }\n        ]\n      },\n      \"route\": {\n        \"type\": [\n          {\n            \"code\": \"CodeableConcept\"\n          }\n        ]\n      },\n      \"method\": {\n        \"type\": [\n          {\n            \"code\": \"CodeableConcept\"\n          }\n        ]\n      },\n      \"doseAndRate\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"DosageDoseAndRate\"\n          }\n        ]\n      },\n      \"maxDosePerPeriod\": {\n        \"type\": [\n          {\n            \"code\": \"Ratio\"\n          }\n        ]\n      },\n      \"maxDosePerAdministration\": {\n        \"type\": [\n          {\n            \"code\": \"Quantity\",\n            \"profile\": [\"http://hl7.org/fhir/StructureDefinition/SimpleQuantity\"]\n          }\n        ]\n      },\n      \"maxDosePerLifetime\": {\n        \"type\": [\n          {\n            \"code\": \"Quantity\",\n            \"profile\": [\"http://hl7.org/fhir/StructureDefinition/SimpleQuantity\"]\n          }\n        ]\n      }\n    }\n  },\n  \"DosageDoseAndRate\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"type\": {\n        \"type\": [\n          {\n            \"code\": \"CodeableConcept\"\n          }\n        ]\n      },\n      \"dose[x]\": {\n        \"type\": [\n          {\n            \"code\": \"Range\"\n          },\n          {\n            \"code\": \"Quantity\",\n            \"profile\": [\"http://hl7.org/fhir/StructureDefinition/SimpleQuantity\"]\n          }\n        ]\n      },\n      \"rate[x]\": {\n        \"type\": [\n          {\n            \"code\": \"Ratio\"\n          },\n          {\n            \"code\": \"Range\"\n          },\n          {\n            \"code\": \"Quantity\",\n            \"profile\": [\"http://hl7.org/fhir/StructureDefinition/SimpleQuantity\"]\n          }\n        ]\n      }\n    }\n  },\n  \"Duration\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"value\": {\n        \"type\": [\n          {\n            \"code\": \"decimal\"\n          }\n        ]\n      },\n      \"comparator\": {\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      },\n      \"unit\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"system\": {\n        \"type\": [\n          {\n            \"code\": \"uri\"\n          }\n        ]\n      },\n      \"code\": {\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      }\n    }\n  },\n  \"ElementDefinition\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"modifierExtension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"path\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"representation\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      },\n      \"sliceName\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"sliceIsConstraining\": {\n        \"type\": [\n          {\n            \"code\": \"boolean\"\n          }\n        ]\n      },\n      \"label\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"code\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Coding\"\n          }\n        ]\n      },\n      \"slicing\": {\n        \"type\": [\n          {\n            \"code\": \"ElementDefinitionSlicing\"\n          }\n        ]\n      },\n      \"short\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"definition\": {\n        \"type\": [\n          {\n            \"code\": \"markdown\"\n          }\n        ]\n      },\n      \"comment\": {\n        \"type\": [\n          {\n            \"code\": \"markdown\"\n          }\n        ]\n      },\n      \"requirements\": {\n        \"type\": [\n          {\n            \"code\": \"markdown\"\n          }\n        ]\n      },\n      \"alias\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"min\": {\n        \"type\": [\n          {\n            \"code\": \"unsignedInt\"\n          }\n        ]\n      },\n      \"max\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"base\": {\n        \"type\": [\n          {\n            \"code\": \"ElementDefinitionBase\"\n          }\n        ]\n      },\n      \"contentReference\": {\n        \"type\": [\n          {\n            \"code\": \"uri\"\n          }\n        ]\n      },\n      \"type\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"ElementDefinitionType\"\n          }\n        ]\n      },\n      \"defaultValue[x]\": {\n        \"type\": [\n          {\n            \"code\": \"base64Binary\"\n          },\n          {\n            \"code\": \"boolean\"\n          },\n          {\n            \"code\": \"canonical\"\n          },\n          {\n            \"code\": \"code\"\n          },\n          {\n            \"code\": \"date\"\n          },\n          {\n            \"code\": \"dateTime\"\n          },\n          {\n            \"code\": \"decimal\"\n          },\n          {\n            \"code\": \"id\"\n          },\n          {\n            \"code\": \"instant\"\n          },\n          {\n            \"code\": \"integer\"\n          },\n          {\n            \"code\": \"markdown\"\n          },\n          {\n            \"code\": \"oid\"\n          },\n          {\n            \"code\": \"positiveInt\"\n          },\n          {\n            \"code\": \"string\"\n          },\n          {\n            \"code\": \"time\"\n          },\n          {\n            \"code\": \"unsignedInt\"\n          },\n          {\n            \"code\": \"uri\"\n          },\n          {\n            \"code\": \"url\"\n          },\n          {\n            \"code\": \"uuid\"\n          },\n          {\n            \"code\": \"Address\"\n          },\n          {\n            \"code\": \"Age\"\n          },\n          {\n            \"code\": \"Annotation\"\n          },\n          {\n            \"code\": \"Attachment\"\n          },\n          {\n            \"code\": \"CodeableConcept\"\n          },\n          {\n            \"code\": \"Coding\"\n          },\n          {\n            \"code\": \"ContactPoint\"\n          },\n          {\n            \"code\": \"Count\"\n          },\n          {\n            \"code\": \"Distance\"\n          },\n          {\n            \"code\": \"Duration\"\n          },\n          {\n            \"code\": \"HumanName\"\n          },\n          {\n            \"code\": \"Identifier\"\n          },\n          {\n            \"code\": \"Money\"\n          },\n          {\n            \"code\": \"Period\"\n          },\n          {\n            \"code\": \"Quantity\"\n          },\n          {\n            \"code\": \"Range\"\n          },\n          {\n            \"code\": \"Ratio\"\n          },\n          {\n            \"code\": \"Reference\"\n          },\n          {\n            \"code\": \"SampledData\"\n          },\n          {\n            \"code\": \"Signature\"\n          },\n          {\n            \"code\": \"Timing\"\n          },\n          {\n            \"code\": \"ContactDetail\"\n          },\n          {\n            \"code\": \"Contributor\"\n          },\n          {\n            \"code\": \"DataRequirement\"\n          },\n          {\n            \"code\": \"Expression\"\n          },\n          {\n            \"code\": \"ParameterDefinition\"\n          },\n          {\n            \"code\": \"RelatedArtifact\"\n          },\n          {\n            \"code\": \"TriggerDefinition\"\n          },\n          {\n            \"code\": \"UsageContext\"\n          },\n          {\n            \"code\": \"Dosage\"\n          },\n          {\n            \"code\": \"Meta\"\n          }\n        ]\n      },\n      \"meaningWhenMissing\": {\n        \"type\": [\n          {\n            \"code\": \"markdown\"\n          }\n        ]\n      },\n      \"orderMeaning\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"fixed[x]\": {\n        \"type\": [\n          {\n            \"code\": \"base64Binary\"\n          },\n          {\n            \"code\": \"boolean\"\n          },\n          {\n            \"code\": \"canonical\"\n          },\n          {\n            \"code\": \"code\"\n          },\n          {\n            \"code\": \"date\"\n          },\n          {\n            \"code\": \"dateTime\"\n          },\n          {\n            \"code\": \"decimal\"\n          },\n          {\n            \"code\": \"id\"\n          },\n          {\n            \"code\": \"instant\"\n          },\n          {\n            \"code\": \"integer\"\n          },\n          {\n            \"code\": \"markdown\"\n          },\n          {\n            \"code\": \"oid\"\n          },\n          {\n            \"code\": \"positiveInt\"\n          },\n          {\n            \"code\": \"string\"\n          },\n          {\n            \"code\": \"time\"\n          },\n          {\n            \"code\": \"unsignedInt\"\n          },\n          {\n            \"code\": \"uri\"\n          },\n          {\n            \"code\": \"url\"\n          },\n          {\n            \"code\": \"uuid\"\n          },\n          {\n            \"code\": \"Address\"\n          },\n          {\n            \"code\": \"Age\"\n          },\n          {\n            \"code\": \"Annotation\"\n          },\n          {\n            \"code\": \"Attachment\"\n          },\n          {\n            \"code\": \"CodeableConcept\"\n          },\n          {\n            \"code\": \"Coding\"\n          },\n          {\n            \"code\": \"ContactPoint\"\n          },\n          {\n            \"code\": \"Count\"\n          },\n          {\n            \"code\": \"Distance\"\n          },\n          {\n            \"code\": \"Duration\"\n          },\n          {\n            \"code\": \"HumanName\"\n          },\n          {\n            \"code\": \"Identifier\"\n          },\n          {\n            \"code\": \"Money\"\n          },\n          {\n            \"code\": \"Period\"\n          },\n          {\n            \"code\": \"Quantity\"\n          },\n          {\n            \"code\": \"Range\"\n          },\n          {\n            \"code\": \"Ratio\"\n          },\n          {\n            \"code\": \"Reference\"\n          },\n          {\n            \"code\": \"SampledData\"\n          },\n          {\n            \"code\": \"Signature\"\n          },\n          {\n            \"code\": \"Timing\"\n          },\n          {\n            \"code\": \"ContactDetail\"\n          },\n          {\n            \"code\": \"Contributor\"\n          },\n          {\n            \"code\": \"DataRequirement\"\n          },\n          {\n            \"code\": \"Expression\"\n          },\n          {\n            \"code\": \"ParameterDefinition\"\n          },\n          {\n            \"code\": \"RelatedArtifact\"\n          },\n          {\n            \"code\": \"TriggerDefinition\"\n          },\n          {\n            \"code\": \"UsageContext\"\n          },\n          {\n            \"code\": \"Dosage\"\n          },\n          {\n            \"code\": \"Meta\"\n          }\n        ]\n      },\n      \"pattern[x]\": {\n        \"type\": [\n          {\n            \"code\": \"base64Binary\"\n          },\n          {\n            \"code\": \"boolean\"\n          },\n          {\n            \"code\": \"canonical\"\n          },\n          {\n            \"code\": \"code\"\n          },\n          {\n            \"code\": \"date\"\n          },\n          {\n            \"code\": \"dateTime\"\n          },\n          {\n            \"code\": \"decimal\"\n          },\n          {\n            \"code\": \"id\"\n          },\n          {\n            \"code\": \"instant\"\n          },\n          {\n            \"code\": \"integer\"\n          },\n          {\n            \"code\": \"markdown\"\n          },\n          {\n            \"code\": \"oid\"\n          },\n          {\n            \"code\": \"positiveInt\"\n          },\n          {\n            \"code\": \"string\"\n          },\n          {\n            \"code\": \"time\"\n          },\n          {\n            \"code\": \"unsignedInt\"\n          },\n          {\n            \"code\": \"uri\"\n          },\n          {\n            \"code\": \"url\"\n          },\n          {\n            \"code\": \"uuid\"\n          },\n          {\n            \"code\": \"Address\"\n          },\n          {\n            \"code\": \"Age\"\n          },\n          {\n            \"code\": \"Annotation\"\n          },\n          {\n            \"code\": \"Attachment\"\n          },\n          {\n            \"code\": \"CodeableConcept\"\n          },\n          {\n            \"code\": \"Coding\"\n          },\n          {\n            \"code\": \"ContactPoint\"\n          },\n          {\n            \"code\": \"Count\"\n          },\n          {\n            \"code\": \"Distance\"\n          },\n          {\n            \"code\": \"Duration\"\n          },\n          {\n            \"code\": \"HumanName\"\n          },\n          {\n            \"code\": \"Identifier\"\n          },\n          {\n            \"code\": \"Money\"\n          },\n          {\n            \"code\": \"Period\"\n          },\n          {\n            \"code\": \"Quantity\"\n          },\n          {\n            \"code\": \"Range\"\n          },\n          {\n            \"code\": \"Ratio\"\n          },\n          {\n            \"code\": \"Reference\"\n          },\n          {\n            \"code\": \"SampledData\"\n          },\n          {\n            \"code\": \"Signature\"\n          },\n          {\n            \"code\": \"Timing\"\n          },\n          {\n            \"code\": \"ContactDetail\"\n          },\n          {\n            \"code\": \"Contributor\"\n          },\n          {\n            \"code\": \"DataRequirement\"\n          },\n          {\n            \"code\": \"Expression\"\n          },\n          {\n            \"code\": \"ParameterDefinition\"\n          },\n          {\n            \"code\": \"RelatedArtifact\"\n          },\n          {\n            \"code\": \"TriggerDefinition\"\n          },\n          {\n            \"code\": \"UsageContext\"\n          },\n          {\n            \"code\": \"Dosage\"\n          },\n          {\n            \"code\": \"Meta\"\n          }\n        ]\n      },\n      \"example\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"ElementDefinitionExample\"\n          }\n        ]\n      },\n      \"minValue[x]\": {\n        \"type\": [\n          {\n            \"code\": \"date\"\n          },\n          {\n            \"code\": \"dateTime\"\n          },\n          {\n            \"code\": \"instant\"\n          },\n          {\n            \"code\": \"time\"\n          },\n          {\n            \"code\": \"decimal\"\n          },\n          {\n            \"code\": \"integer\"\n          },\n          {\n            \"code\": \"positiveInt\"\n          },\n          {\n            \"code\": \"unsignedInt\"\n          },\n          {\n            \"code\": \"Quantity\"\n          }\n        ]\n      },\n      \"maxValue[x]\": {\n        \"type\": [\n          {\n            \"code\": \"date\"\n          },\n          {\n            \"code\": \"dateTime\"\n          },\n          {\n            \"code\": \"instant\"\n          },\n          {\n            \"code\": \"time\"\n          },\n          {\n            \"code\": \"decimal\"\n          },\n          {\n            \"code\": \"integer\"\n          },\n          {\n            \"code\": \"positiveInt\"\n          },\n          {\n            \"code\": \"unsignedInt\"\n          },\n          {\n            \"code\": \"Quantity\"\n          }\n        ]\n      },\n      \"maxLength\": {\n        \"type\": [\n          {\n            \"code\": \"integer\"\n          }\n        ]\n      },\n      \"condition\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"id\"\n          }\n        ]\n      },\n      \"constraint\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"ElementDefinitionConstraint\"\n          }\n        ]\n      },\n      \"mustSupport\": {\n        \"type\": [\n          {\n            \"code\": \"boolean\"\n          }\n        ]\n      },\n      \"isModifier\": {\n        \"type\": [\n          {\n            \"code\": \"boolean\"\n          }\n        ]\n      },\n      \"isModifierReason\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"isSummary\": {\n        \"type\": [\n          {\n            \"code\": \"boolean\"\n          }\n        ]\n      },\n      \"binding\": {\n        \"type\": [\n          {\n            \"code\": \"ElementDefinitionBinding\"\n          }\n        ]\n      },\n      \"mapping\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"ElementDefinitionMapping\"\n          }\n        ]\n      }\n    }\n  },\n  \"ElementDefinitionSlicingDiscriminator\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"type\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      },\n      \"path\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      }\n    }\n  },\n  \"ElementDefinitionSlicing\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"discriminator\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"ElementDefinitionSlicingDiscriminator\"\n          }\n        ]\n      },\n      \"description\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"ordered\": {\n        \"type\": [\n          {\n            \"code\": \"boolean\"\n          }\n        ]\n      },\n      \"rules\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      }\n    }\n  },\n  \"ElementDefinitionBase\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"path\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"min\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"unsignedInt\"\n          }\n        ]\n      },\n      \"max\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      }\n    }\n  },\n  \"ElementDefinitionType\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"code\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"uri\"\n          }\n        ]\n      },\n      \"profile\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"canonical\",\n            \"targetProfile\": [\n              \"http://hl7.org/fhir/StructureDefinition/StructureDefinition\",\n              \"http://hl7.org/fhir/StructureDefinition/ImplementationGuide\"\n            ]\n          }\n        ]\n      },\n      \"targetProfile\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"canonical\",\n            \"targetProfile\": [\n              \"http://hl7.org/fhir/StructureDefinition/StructureDefinition\",\n              \"http://hl7.org/fhir/StructureDefinition/ImplementationGuide\"\n            ]\n          }\n        ]\n      },\n      \"aggregation\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      },\n      \"versioning\": {\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      }\n    }\n  },\n  \"ElementDefinitionExample\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"label\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"value[x]\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"base64Binary\"\n          },\n          {\n            \"code\": \"boolean\"\n          },\n          {\n            \"code\": \"canonical\"\n          },\n          {\n            \"code\": \"code\"\n          },\n          {\n            \"code\": \"date\"\n          },\n          {\n            \"code\": \"dateTime\"\n          },\n          {\n            \"code\": \"decimal\"\n          },\n          {\n            \"code\": \"id\"\n          },\n          {\n            \"code\": \"instant\"\n          },\n          {\n            \"code\": \"integer\"\n          },\n          {\n            \"code\": \"markdown\"\n          },\n          {\n            \"code\": \"oid\"\n          },\n          {\n            \"code\": \"positiveInt\"\n          },\n          {\n            \"code\": \"string\"\n          },\n          {\n            \"code\": \"time\"\n          },\n          {\n            \"code\": \"unsignedInt\"\n          },\n          {\n            \"code\": \"uri\"\n          },\n          {\n            \"code\": \"url\"\n          },\n          {\n            \"code\": \"uuid\"\n          },\n          {\n            \"code\": \"Address\"\n          },\n          {\n            \"code\": \"Age\"\n          },\n          {\n            \"code\": \"Annotation\"\n          },\n          {\n            \"code\": \"Attachment\"\n          },\n          {\n            \"code\": \"CodeableConcept\"\n          },\n          {\n            \"code\": \"Coding\"\n          },\n          {\n            \"code\": \"ContactPoint\"\n          },\n          {\n            \"code\": \"Count\"\n          },\n          {\n            \"code\": \"Distance\"\n          },\n          {\n            \"code\": \"Duration\"\n          },\n          {\n            \"code\": \"HumanName\"\n          },\n          {\n            \"code\": \"Identifier\"\n          },\n          {\n            \"code\": \"Money\"\n          },\n          {\n            \"code\": \"Period\"\n          },\n          {\n            \"code\": \"Quantity\"\n          },\n          {\n            \"code\": \"Range\"\n          },\n          {\n            \"code\": \"Ratio\"\n          },\n          {\n            \"code\": \"Reference\"\n          },\n          {\n            \"code\": \"SampledData\"\n          },\n          {\n            \"code\": \"Signature\"\n          },\n          {\n            \"code\": \"Timing\"\n          },\n          {\n            \"code\": \"ContactDetail\"\n          },\n          {\n            \"code\": \"Contributor\"\n          },\n          {\n            \"code\": \"DataRequirement\"\n          },\n          {\n            \"code\": \"Expression\"\n          },\n          {\n            \"code\": \"ParameterDefinition\"\n          },\n          {\n            \"code\": \"RelatedArtifact\"\n          },\n          {\n            \"code\": \"TriggerDefinition\"\n          },\n          {\n            \"code\": \"UsageContext\"\n          },\n          {\n            \"code\": \"Dosage\"\n          },\n          {\n            \"code\": \"Meta\"\n          }\n        ]\n      }\n    }\n  },\n  \"ElementDefinitionConstraint\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"key\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"id\"\n          }\n        ]\n      },\n      \"requirements\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"severity\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      },\n      \"human\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"expression\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"xpath\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"source\": {\n        \"type\": [\n          {\n            \"code\": \"canonical\",\n            \"targetProfile\": [\"http://hl7.org/fhir/StructureDefinition/StructureDefinition\"]\n          }\n        ]\n      }\n    }\n  },\n  \"ElementDefinitionBinding\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"strength\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      },\n      \"description\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"valueSet\": {\n        \"type\": [\n          {\n            \"code\": \"canonical\",\n            \"targetProfile\": [\"http://hl7.org/fhir/StructureDefinition/ValueSet\"]\n          }\n        ]\n      }\n    }\n  },\n  \"ElementDefinitionMapping\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"identity\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"id\"\n          }\n        ]\n      },\n      \"language\": {\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      },\n      \"map\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"comment\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      }\n    }\n  },\n  \"Expression\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"description\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"name\": {\n        \"type\": [\n          {\n            \"code\": \"id\"\n          }\n        ]\n      },\n      \"language\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      },\n      \"expression\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"reference\": {\n        \"type\": [\n          {\n            \"code\": \"uri\"\n          }\n        ]\n      }\n    }\n  },\n  \"Extension\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"url\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"uri\"\n          }\n        ]\n      },\n      \"value[x]\": {\n        \"type\": [\n          {\n            \"code\": \"base64Binary\"\n          },\n          {\n            \"code\": \"boolean\"\n          },\n          {\n            \"code\": \"canonical\"\n          },\n          {\n            \"code\": \"code\"\n          },\n          {\n            \"code\": \"date\"\n          },\n          {\n            \"code\": \"dateTime\"\n          },\n          {\n            \"code\": \"decimal\"\n          },\n          {\n            \"code\": \"id\"\n          },\n          {\n            \"code\": \"instant\"\n          },\n          {\n            \"code\": \"integer\"\n          },\n          {\n            \"code\": \"markdown\"\n          },\n          {\n            \"code\": \"oid\"\n          },\n          {\n            \"code\": \"positiveInt\"\n          },\n          {\n            \"code\": \"string\"\n          },\n          {\n            \"code\": \"time\"\n          },\n          {\n            \"code\": \"unsignedInt\"\n          },\n          {\n            \"code\": \"uri\"\n          },\n          {\n            \"code\": \"url\"\n          },\n          {\n            \"code\": \"uuid\"\n          },\n          {\n            \"code\": \"Address\"\n          },\n          {\n            \"code\": \"Age\"\n          },\n          {\n            \"code\": \"Annotation\"\n          },\n          {\n            \"code\": \"Attachment\"\n          },\n          {\n            \"code\": \"CodeableConcept\"\n          },\n          {\n            \"code\": \"Coding\"\n          },\n          {\n            \"code\": \"ContactPoint\"\n          },\n          {\n            \"code\": \"Count\"\n          },\n          {\n            \"code\": \"Distance\"\n          },\n          {\n            \"code\": \"Duration\"\n          },\n          {\n            \"code\": \"HumanName\"\n          },\n          {\n            \"code\": \"Identifier\"\n          },\n          {\n            \"code\": \"Money\"\n          },\n          {\n            \"code\": \"Period\"\n          },\n          {\n            \"code\": \"Quantity\"\n          },\n          {\n            \"code\": \"Range\"\n          },\n          {\n            \"code\": \"Ratio\"\n          },\n          {\n            \"code\": \"Reference\"\n          },\n          {\n            \"code\": \"SampledData\"\n          },\n          {\n            \"code\": \"Signature\"\n          },\n          {\n            \"code\": \"Timing\"\n          },\n          {\n            \"code\": \"ContactDetail\"\n          },\n          {\n            \"code\": \"Contributor\"\n          },\n          {\n            \"code\": \"DataRequirement\"\n          },\n          {\n            \"code\": \"Expression\"\n          },\n          {\n            \"code\": \"ParameterDefinition\"\n          },\n          {\n            \"code\": \"RelatedArtifact\"\n          },\n          {\n            \"code\": \"TriggerDefinition\"\n          },\n          {\n            \"code\": \"UsageContext\"\n          },\n          {\n            \"code\": \"Dosage\"\n          },\n          {\n            \"code\": \"Meta\"\n          }\n        ]\n      }\n    }\n  },\n  \"HumanName\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"use\": {\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      },\n      \"text\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"family\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"given\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"prefix\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"suffix\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"period\": {\n        \"type\": [\n          {\n            \"code\": \"Period\"\n          }\n        ]\n      }\n    }\n  },\n  \"Identifier\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"use\": {\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      },\n      \"type\": {\n        \"type\": [\n          {\n            \"code\": \"CodeableConcept\"\n          }\n        ]\n      },\n      \"system\": {\n        \"type\": [\n          {\n            \"code\": \"uri\"\n          }\n        ]\n      },\n      \"value\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"period\": {\n        \"type\": [\n          {\n            \"code\": \"Period\"\n          }\n        ]\n      },\n      \"assigner\": {\n        \"type\": [\n          {\n            \"code\": \"Reference\",\n            \"targetProfile\": [\"http://hl7.org/fhir/StructureDefinition/Organization\"]\n          }\n        ]\n      }\n    }\n  },\n  \"MarketingStatus\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"modifierExtension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"country\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"CodeableConcept\"\n          }\n        ]\n      },\n      \"jurisdiction\": {\n        \"type\": [\n          {\n            \"code\": \"CodeableConcept\"\n          }\n        ]\n      },\n      \"status\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"CodeableConcept\"\n          }\n        ]\n      },\n      \"dateRange\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"Period\"\n          }\n        ]\n      },\n      \"restoreDate\": {\n        \"type\": [\n          {\n            \"code\": \"dateTime\"\n          }\n        ]\n      }\n    }\n  },\n  \"Meta\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"versionId\": {\n        \"type\": [\n          {\n            \"code\": \"id\"\n          }\n        ]\n      },\n      \"lastUpdated\": {\n        \"type\": [\n          {\n            \"code\": \"instant\"\n          }\n        ]\n      },\n      \"source\": {\n        \"type\": [\n          {\n            \"code\": \"uri\"\n          }\n        ]\n      },\n      \"profile\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"canonical\",\n            \"targetProfile\": [\"http://hl7.org/fhir/StructureDefinition/StructureDefinition\"]\n          }\n        ]\n      },\n      \"security\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Coding\"\n          }\n        ]\n      },\n      \"tag\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Coding\"\n          }\n        ]\n      },\n      \"project\": {\n        \"type\": [\n          {\n            \"code\": \"uri\"\n          }\n        ]\n      },\n      \"author\": {\n        \"type\": [\n          {\n            \"code\": \"Reference\"\n          }\n        ]\n      },\n      \"onBehalfOf\": {\n        \"type\": [\n          {\n            \"code\": \"Reference\"\n          }\n        ]\n      },\n      \"account\": {\n        \"type\": [\n          {\n            \"code\": \"Reference\"\n          }\n        ]\n      },\n      \"accounts\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Reference\"\n          }\n        ]\n      },\n      \"compartment\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Reference\"\n          }\n        ]\n      }\n    }\n  },\n  \"Money\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"value\": {\n        \"type\": [\n          {\n            \"code\": \"decimal\"\n          }\n        ]\n      },\n      \"currency\": {\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      }\n    }\n  },\n  \"Narrative\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"status\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      },\n      \"div\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"xhtml\"\n          }\n        ]\n      }\n    }\n  },\n  \"ParameterDefinition\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"name\": {\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      },\n      \"use\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      },\n      \"min\": {\n        \"type\": [\n          {\n            \"code\": \"integer\"\n          }\n        ]\n      },\n      \"max\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"documentation\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"type\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      },\n      \"profile\": {\n        \"type\": [\n          {\n            \"code\": \"canonical\",\n            \"targetProfile\": [\"http://hl7.org/fhir/StructureDefinition/StructureDefinition\"]\n          }\n        ]\n      }\n    }\n  },\n  \"Period\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"start\": {\n        \"type\": [\n          {\n            \"code\": \"dateTime\"\n          }\n        ]\n      },\n      \"end\": {\n        \"type\": [\n          {\n            \"code\": \"dateTime\"\n          }\n        ]\n      }\n    }\n  },\n  \"Population\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"modifierExtension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"age[x]\": {\n        \"type\": [\n          {\n            \"code\": \"Range\"\n          },\n          {\n            \"code\": \"CodeableConcept\"\n          }\n        ]\n      },\n      \"gender\": {\n        \"type\": [\n          {\n            \"code\": \"CodeableConcept\"\n          }\n        ]\n      },\n      \"race\": {\n        \"type\": [\n          {\n            \"code\": \"CodeableConcept\"\n          }\n        ]\n      },\n      \"physiologicalCondition\": {\n        \"type\": [\n          {\n            \"code\": \"CodeableConcept\"\n          }\n        ]\n      }\n    }\n  },\n  \"ProdCharacteristic\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"modifierExtension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"height\": {\n        \"type\": [\n          {\n            \"code\": \"Quantity\"\n          }\n        ]\n      },\n      \"width\": {\n        \"type\": [\n          {\n            \"code\": \"Quantity\"\n          }\n        ]\n      },\n      \"depth\": {\n        \"type\": [\n          {\n            \"code\": \"Quantity\"\n          }\n        ]\n      },\n      \"weight\": {\n        \"type\": [\n          {\n            \"code\": \"Quantity\"\n          }\n        ]\n      },\n      \"nominalVolume\": {\n        \"type\": [\n          {\n            \"code\": \"Quantity\"\n          }\n        ]\n      },\n      \"externalDiameter\": {\n        \"type\": [\n          {\n            \"code\": \"Quantity\"\n          }\n        ]\n      },\n      \"shape\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"color\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"imprint\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"image\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Attachment\"\n          }\n        ]\n      },\n      \"scoring\": {\n        \"type\": [\n          {\n            \"code\": \"CodeableConcept\"\n          }\n        ]\n      }\n    }\n  },\n  \"ProductShelfLife\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"modifierExtension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"identifier\": {\n        \"type\": [\n          {\n            \"code\": \"Identifier\"\n          }\n        ]\n      },\n      \"type\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"CodeableConcept\"\n          }\n        ]\n      },\n      \"period\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"Quantity\"\n          }\n        ]\n      },\n      \"specialPrecautionsForStorage\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"CodeableConcept\"\n          }\n        ]\n      }\n    }\n  },\n  \"Quantity\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"value\": {\n        \"type\": [\n          {\n            \"code\": \"decimal\"\n          }\n        ]\n      },\n      \"comparator\": {\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      },\n      \"unit\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"system\": {\n        \"type\": [\n          {\n            \"code\": \"uri\"\n          }\n        ]\n      },\n      \"code\": {\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      }\n    }\n  },\n  \"Range\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"low\": {\n        \"type\": [\n          {\n            \"code\": \"Quantity\",\n            \"profile\": [\"http://hl7.org/fhir/StructureDefinition/SimpleQuantity\"]\n          }\n        ]\n      },\n      \"high\": {\n        \"type\": [\n          {\n            \"code\": \"Quantity\",\n            \"profile\": [\"http://hl7.org/fhir/StructureDefinition/SimpleQuantity\"]\n          }\n        ]\n      }\n    }\n  },\n  \"Ratio\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"numerator\": {\n        \"type\": [\n          {\n            \"code\": \"Quantity\"\n          }\n        ]\n      },\n      \"denominator\": {\n        \"type\": [\n          {\n            \"code\": \"Quantity\"\n          }\n        ]\n      }\n    }\n  },\n  \"Reference\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"reference\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"type\": {\n        \"type\": [\n          {\n            \"code\": \"uri\"\n          }\n        ]\n      },\n      \"identifier\": {\n        \"type\": [\n          {\n            \"code\": \"Identifier\"\n          }\n        ]\n      },\n      \"display\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      }\n    }\n  },\n  \"RelatedArtifact\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"type\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      },\n      \"label\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"display\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"citation\": {\n        \"type\": [\n          {\n            \"code\": \"markdown\"\n          }\n        ]\n      },\n      \"url\": {\n        \"type\": [\n          {\n            \"code\": \"url\"\n          }\n        ]\n      },\n      \"document\": {\n        \"type\": [\n          {\n            \"code\": \"Attachment\"\n          }\n        ]\n      },\n      \"resource\": {\n        \"type\": [\n          {\n            \"code\": \"canonical\",\n            \"targetProfile\": [\"http://hl7.org/fhir/StructureDefinition/Resource\"]\n          }\n        ]\n      }\n    }\n  },\n  \"SampledData\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"origin\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"Quantity\",\n            \"profile\": [\"http://hl7.org/fhir/StructureDefinition/SimpleQuantity\"]\n          }\n        ]\n      },\n      \"period\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"decimal\"\n          }\n        ]\n      },\n      \"factor\": {\n        \"type\": [\n          {\n            \"code\": \"decimal\"\n          }\n        ]\n      },\n      \"lowerLimit\": {\n        \"type\": [\n          {\n            \"code\": \"decimal\"\n          }\n        ]\n      },\n      \"upperLimit\": {\n        \"type\": [\n          {\n            \"code\": \"decimal\"\n          }\n        ]\n      },\n      \"dimensions\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"positiveInt\"\n          }\n        ]\n      },\n      \"data\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      }\n    }\n  },\n  \"Signature\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"type\": {\n        \"min\": 1,\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Coding\"\n          }\n        ]\n      },\n      \"when\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"instant\"\n          }\n        ]\n      },\n      \"who\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"Reference\",\n            \"targetProfile\": [\n              \"http://hl7.org/fhir/StructureDefinition/Practitioner\",\n              \"http://hl7.org/fhir/StructureDefinition/PractitionerRole\",\n              \"http://hl7.org/fhir/StructureDefinition/RelatedPerson\",\n              \"http://hl7.org/fhir/StructureDefinition/Patient\",\n              \"http://hl7.org/fhir/StructureDefinition/Device\",\n              \"http://hl7.org/fhir/StructureDefinition/Organization\"\n            ]\n          }\n        ]\n      },\n      \"onBehalfOf\": {\n        \"type\": [\n          {\n            \"code\": \"Reference\",\n            \"targetProfile\": [\n              \"http://hl7.org/fhir/StructureDefinition/Practitioner\",\n              \"http://hl7.org/fhir/StructureDefinition/PractitionerRole\",\n              \"http://hl7.org/fhir/StructureDefinition/RelatedPerson\",\n              \"http://hl7.org/fhir/StructureDefinition/Patient\",\n              \"http://hl7.org/fhir/StructureDefinition/Device\",\n              \"http://hl7.org/fhir/StructureDefinition/Organization\"\n            ]\n          }\n        ]\n      },\n      \"targetFormat\": {\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      },\n      \"sigFormat\": {\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      },\n      \"data\": {\n        \"type\": [\n          {\n            \"code\": \"base64Binary\"\n          }\n        ]\n      }\n    }\n  },\n  \"SubstanceAmount\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"modifierExtension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"amount[x]\": {\n        \"type\": [\n          {\n            \"code\": \"Quantity\"\n          },\n          {\n            \"code\": \"Range\"\n          },\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"amountType\": {\n        \"type\": [\n          {\n            \"code\": \"CodeableConcept\"\n          }\n        ]\n      },\n      \"amountText\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"referenceRange\": {\n        \"type\": [\n          {\n            \"code\": \"SubstanceAmountReferenceRange\"\n          }\n        ]\n      }\n    }\n  },\n  \"SubstanceAmountReferenceRange\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"lowLimit\": {\n        \"type\": [\n          {\n            \"code\": \"Quantity\"\n          }\n        ]\n      },\n      \"highLimit\": {\n        \"type\": [\n          {\n            \"code\": \"Quantity\"\n          }\n        ]\n      }\n    }\n  },\n  \"Timing\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"modifierExtension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"event\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"dateTime\"\n          }\n        ]\n      },\n      \"repeat\": {\n        \"type\": [\n          {\n            \"code\": \"TimingRepeat\"\n          }\n        ]\n      },\n      \"code\": {\n        \"type\": [\n          {\n            \"code\": \"CodeableConcept\"\n          }\n        ]\n      }\n    }\n  },\n  \"TimingRepeat\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"bounds[x]\": {\n        \"type\": [\n          {\n            \"code\": \"Duration\"\n          },\n          {\n            \"code\": \"Range\"\n          },\n          {\n            \"code\": \"Period\"\n          }\n        ]\n      },\n      \"count\": {\n        \"type\": [\n          {\n            \"code\": \"positiveInt\"\n          }\n        ]\n      },\n      \"countMax\": {\n        \"type\": [\n          {\n            \"code\": \"positiveInt\"\n          }\n        ]\n      },\n      \"duration\": {\n        \"type\": [\n          {\n            \"code\": \"decimal\"\n          }\n        ]\n      },\n      \"durationMax\": {\n        \"type\": [\n          {\n            \"code\": \"decimal\"\n          }\n        ]\n      },\n      \"durationUnit\": {\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      },\n      \"frequency\": {\n        \"type\": [\n          {\n            \"code\": \"positiveInt\"\n          }\n        ]\n      },\n      \"frequencyMax\": {\n        \"type\": [\n          {\n            \"code\": \"positiveInt\"\n          }\n        ]\n      },\n      \"period\": {\n        \"type\": [\n          {\n            \"code\": \"decimal\"\n          }\n        ]\n      },\n      \"periodMax\": {\n        \"type\": [\n          {\n            \"code\": \"decimal\"\n          }\n        ]\n      },\n      \"periodUnit\": {\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      },\n      \"dayOfWeek\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      },\n      \"timeOfDay\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"time\"\n          }\n        ]\n      },\n      \"when\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      },\n      \"offset\": {\n        \"type\": [\n          {\n            \"code\": \"unsignedInt\"\n          }\n        ]\n      }\n    }\n  },\n  \"TriggerDefinition\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"type\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      },\n      \"name\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"timing[x]\": {\n        \"type\": [\n          {\n            \"code\": \"Timing\"\n          },\n          {\n            \"code\": \"Reference\",\n            \"targetProfile\": [\"http://hl7.org/fhir/StructureDefinition/Schedule\"]\n          },\n          {\n            \"code\": \"date\"\n          },\n          {\n            \"code\": \"dateTime\"\n          }\n        ]\n      },\n      \"data\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"DataRequirement\"\n          }\n        ]\n      },\n      \"condition\": {\n        \"type\": [\n          {\n            \"code\": \"Expression\"\n          }\n        ]\n      }\n    }\n  },\n  \"UsageContext\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"code\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"Coding\"\n          }\n        ]\n      },\n      \"value[x]\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"CodeableConcept\"\n          },\n          {\n            \"code\": \"Quantity\"\n          },\n          {\n            \"code\": \"Range\"\n          },\n          {\n            \"code\": \"Reference\",\n            \"targetProfile\": [\n              \"http://hl7.org/fhir/StructureDefinition/PlanDefinition\",\n              \"http://hl7.org/fhir/StructureDefinition/ResearchStudy\",\n              \"http://hl7.org/fhir/StructureDefinition/InsurancePlan\",\n              \"http://hl7.org/fhir/StructureDefinition/HealthcareService\",\n              \"http://hl7.org/fhir/StructureDefinition/Group\",\n              \"http://hl7.org/fhir/StructureDefinition/Location\",\n              \"http://hl7.org/fhir/StructureDefinition/Organization\"\n            ]\n          }\n        ]\n      }\n    }\n  },\n  \"MoneyQuantity\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"value\": {\n        \"type\": [\n          {\n            \"code\": \"decimal\"\n          }\n        ]\n      },\n      \"comparator\": {\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      },\n      \"unit\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"system\": {\n        \"type\": [\n          {\n            \"code\": \"uri\"\n          }\n        ]\n      },\n      \"code\": {\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      }\n    }\n  },\n  \"SimpleQuantity\": {\n    \"elements\": {\n      \"id\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"extension\": {\n        \"max\": 9007199254740991,\n        \"type\": [\n          {\n            \"code\": \"Extension\"\n          }\n        ]\n      },\n      \"value\": {\n        \"type\": [\n          {\n            \"code\": \"decimal\"\n          }\n        ]\n      },\n      \"comparator\": {\n        \"max\": 0,\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      },\n      \"unit\": {\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"system\": {\n        \"type\": [\n          {\n            \"code\": \"uri\"\n          }\n        ]\n      },\n      \"code\": {\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      }\n    }\n  },\n  \"IdentityProvider\": {\n    \"elements\": {\n      \"authorizeUrl\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"tokenUrl\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"tokenAuthMethod\": {\n        \"type\": [\n          {\n            \"code\": \"code\"\n          }\n        ]\n      },\n      \"userInfoUrl\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"clientId\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"clientSecret\": {\n        \"min\": 1,\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      },\n      \"usePkce\": {\n        \"type\": [\n          {\n            \"code\": \"boolean\"\n          }\n        ]\n      },\n      \"useSubject\": {\n        \"type\": [\n          {\n            \"code\": \"boolean\"\n          }\n        ]\n      }\n    }\n  }\n}\n", "import {\n  Bundle,\n  Coding,\n  ElementDefinition,\n  ElementDefinitionBinding,\n  Resource,\n  StructureDefinition,\n} from '@medplum/fhirtypes';\nimport { DataTypesMap, inflateBaseSchema } from '../base-schema';\nimport baseSchema from '../base-schema.json';\nimport { getTypedPropertyValue } from '../fhirpath/utils';\nimport { OperationOutcomeError, badRequest } from '../outcomes';\nimport { TypedValue, getElementDefinitionTypeName, indexDefaultSearchParameters, isResourceTypeSchema } from '../types';\nimport { capitalize, getExtension, isEmpty } from '../utils';\n\n/**\n * Internal representation of a non-primitive FHIR type, suitable for use in resource validation\n */\nexport interface InternalTypeSchema {\n  name: string;\n  type: string;\n  path: string;\n  title?: string;\n  url?: string;\n  version?: string;\n  kind?: string;\n  description?: string;\n  elements: Record<string, InternalSchemaElement>;\n  constraints?: Constraint[];\n  parentType?: InternalTypeSchema;\n  innerTypes: InternalTypeSchema[];\n  summaryProperties?: Set<string>;\n  mandatoryProperties?: Set<string>;\n}\n\nexport interface InternalSchemaElement {\n  description: string;\n  path: string;\n  min: number;\n  max: number;\n  isArray?: boolean;\n  constraints?: Constraint[];\n  type: ElementType[];\n  slicing?: SlicingRules;\n  fixed?: TypedValue;\n  pattern?: TypedValue;\n  binding?: ElementDefinitionBinding;\n}\n\nexport interface ElementType {\n  code: string;\n  targetProfile?: string[];\n  profile?: string[];\n}\n\nexport interface Constraint {\n  key: string;\n  severity: 'error' | 'warning';\n  expression: string;\n  description: string;\n}\n\nexport interface SlicingRules {\n  discriminator: SliceDiscriminator[];\n  ordered: boolean;\n  rule?: 'open' | 'closed' | 'openAtEnd';\n  slices: SliceDefinition[];\n}\n\nexport interface SliceDefinition extends Omit<InternalSchemaElement, 'slicing'> {\n  name: string;\n  definition?: string;\n  elements: Record<string, InternalSchemaElement>;\n}\n\nexport interface SliceDiscriminator {\n  path: string;\n  type: string;\n}\n\n/**\n * Parses a StructureDefinition resource into an internal schema better suited for\n * programmatic validation and usage in internal systems\n * @param sd - The StructureDefinition resource to parse\n * @returns The parsed schema for the given resource type\n * @experimental\n */\nexport function parseStructureDefinition(sd: StructureDefinition): InternalTypeSchema {\n  return new StructureDefinitionParser(sd).parse();\n}\n\nconst DATA_TYPES: DataTypesMap = inflateBaseSchema(baseSchema);\n\n// profiles are referenced by URL instead of name\nconst PROFILE_SCHEMAS_BY_URL: { [profileUrl: string]: InternalTypeSchema } = Object.create(null);\n\n// Since profiles alter the schemas of their elements, a mapping of type names to schemas\n// is maintained per profile URL\nconst PROFILE_DATA_TYPES: { [profileUrl: string]: DataTypesMap } = Object.create(null);\n\n// Special case names for StructureDefinitions that are technically \"profiles\", but are used as base types.\n// This is for backwards compatibility with R4 StructureDefinitions that are used as base types.\n// MoneyQuantity and SimpleQuantity are technically \"profiles\" on Quantity, but we allow them to be used as base types.\n// ViewDefinition is a special case for SQL-on-FHIR.\n// We can add more types here in the future as necessary, when we want them to be used as base types.\n// For example, exporting new types in \"@medplum/fhirtypes\".\nconst TYPE_SPECIAL_CASES: { [url: string]: string } = {\n  'http://hl7.org/fhir/StructureDefinition/MoneyQuantity': 'MoneyQuantity',\n  'http://hl7.org/fhir/StructureDefinition/SimpleQuantity': 'SimpleQuantity',\n  'http://hl7.org/fhir/uv/sql-on-fhir/StructureDefinition/ViewDefinition': 'ViewDefinition',\n};\n\nfunction getDataTypesMap(profileUrl: string): DataTypesMap {\n  let dataTypes: DataTypesMap;\n  dataTypes = PROFILE_DATA_TYPES[profileUrl];\n  if (!dataTypes) {\n    dataTypes = PROFILE_DATA_TYPES[profileUrl] = Object.create(null);\n  }\n  return dataTypes;\n}\n\n/**\n * Parses and indexes structure definitions\n * @param bundle - Bundle or array of structure definitions to be parsed and indexed\n */\nexport function indexStructureDefinitionBundle(bundle: StructureDefinition[] | Bundle): void {\n  const maybeSds = Array.isArray(bundle) ? bundle : (bundle.entry?.map((e) => e.resource) ?? []);\n  const sds: StructureDefinition[] = maybeSds.filter((r) => r?.resourceType === 'StructureDefinition');\n  indexDefaultSearchParameters(sds);\n  for (const sd of sds) {\n    loadDataType(sd);\n  }\n}\n\nexport function loadDataType(sd: StructureDefinition): void {\n  if (!sd?.name) {\n    throw new Error(`Failed loading StructureDefinition from bundle`);\n  }\n  if (sd.resourceType !== 'StructureDefinition') {\n    return;\n  }\n  const schema = parseStructureDefinition(sd);\n  const specialCase = TYPE_SPECIAL_CASES[sd.url];\n  let dataTypes: DataTypesMap;\n  let typeName: string;\n\n  if (specialCase) {\n    // Special cases by \"name\"\n    // These are StructureDefinitions that are technically \"profiles\", but are used as base types\n    dataTypes = DATA_TYPES;\n    typeName = specialCase;\n  } else if (\n    // By default, only index by \"type\" for \"official\" FHIR types\n    sd.url === `http://hl7.org/fhir/StructureDefinition/${sd.type}` ||\n    sd.url === `https://medplum.com/fhir/StructureDefinition/${sd.type}` ||\n    sd.type?.startsWith('http://') ||\n    sd.type?.startsWith('https://')\n  ) {\n    dataTypes = DATA_TYPES;\n    typeName = sd.type;\n  } else {\n    dataTypes = getDataTypesMap(sd.url);\n    typeName = sd.type;\n  }\n\n  dataTypes[typeName] = schema;\n\n  for (const inner of schema.innerTypes) {\n    inner.parentType = schema;\n    dataTypes[inner.name] = inner;\n  }\n\n  PROFILE_SCHEMAS_BY_URL[sd.url] = schema;\n}\n\nexport function getAllDataTypes(): DataTypesMap {\n  return DATA_TYPES;\n}\n\nexport function isDataTypeLoaded(type: string): boolean {\n  return !!DATA_TYPES[type];\n}\n\nexport function tryGetDataType(type: string, profileUrl?: string): InternalTypeSchema | undefined {\n  if (profileUrl) {\n    const profileType = getDataTypesMap(profileUrl)[type];\n    if (profileType) {\n      return profileType;\n    }\n  }\n  // Fallback to base schema if no result found in profileUrl namespace\n  return DATA_TYPES[type];\n}\n\nexport function getDataType(type: string, profileUrl?: string): InternalTypeSchema {\n  const schema = tryGetDataType(type, profileUrl);\n  if (!schema) {\n    throw new OperationOutcomeError(badRequest('Unknown data type: ' + type));\n  }\n  return schema;\n}\n\n/**\n * Returns true if the given string is a valid FHIR resource type.\n *\n * @example\n * ```ts\n * isResourceType('Patient'); // true\n * isResourceType('XYZ'); // false\n * ```\n *\n * @param resourceType - The candidate resource type string.\n * @returns True if the resource type is a valid FHIR resource type.\n */\nexport function isResourceType(resourceType: string): boolean {\n  const typeSchema = DATA_TYPES[resourceType];\n  return typeSchema && isResourceTypeSchema(typeSchema);\n}\n\nexport function isProfileLoaded(profileUrl: string): boolean {\n  return !!PROFILE_SCHEMAS_BY_URL[profileUrl];\n}\n\nexport function tryGetProfile(profileUrl: string): InternalTypeSchema | undefined {\n  return PROFILE_SCHEMAS_BY_URL[profileUrl];\n}\n\ninterface BackboneContext {\n  type: InternalTypeSchema;\n  path: string;\n  parent?: BackboneContext;\n}\n\n/**\n * @experimental\n */\nclass StructureDefinitionParser {\n  private readonly root: ElementDefinition;\n  private readonly elements: ElementDefinition[];\n  private readonly elementIndex: Record<string, ElementDefinition>;\n  private index: number;\n  private readonly resourceSchema: InternalTypeSchema;\n  private slicingContext: { field: SlicingRules; current?: SliceDefinition; path: string } | undefined;\n  private readonly innerTypes: InternalTypeSchema[];\n  private backboneContext: BackboneContext | undefined;\n\n  /**\n   * @param sd - The StructureDefinition to parse\n   * @throws Throws when the StructureDefinition does not have a populated `snapshot` field\n   */\n  constructor(sd: StructureDefinition) {\n    if (!sd.snapshot?.element || sd.snapshot.element.length === 0) {\n      throw new Error(`No snapshot defined for StructureDefinition '${sd.name}'`);\n    }\n\n    this.root = sd.snapshot.element[0];\n    this.elements = sd.snapshot.element.slice(1);\n    this.elementIndex = Object.create(null);\n    this.index = 0;\n    this.resourceSchema = {\n      name: sd.name as string,\n      path: this.root.path,\n      title: sd.title,\n      type: sd.type,\n      url: sd.url as string,\n      version: sd.version,\n      kind: sd.kind,\n      description: getDescription(sd),\n      elements: {},\n      constraints: this.parseElementDefinition(this.root).constraints,\n      innerTypes: [],\n      summaryProperties: new Set(),\n      mandatoryProperties: new Set(),\n    };\n    this.innerTypes = [];\n  }\n\n  parse(): InternalTypeSchema {\n    let element = this.next();\n    while (element) {\n      if (element.sliceName) {\n        // Start of slice: this ElementDefinition defines the top-level element of a slice value\n        this.parseSliceStart(element);\n      } else if (element.id?.includes(':')) {\n        // Slice element, part of some slice definition\n        if (this.slicingContext?.current) {\n          const path = elementPath(element, this.slicingContext.path);\n          this.slicingContext.current.elements[path] = this.parseElementDefinition(element);\n        }\n      } else {\n        // Normal field definition\n        const field = this.parseElementDefinition(element);\n        this.checkFieldEnter(element, field);\n\n        // Record field in schema\n        let parentContext: BackboneContext | undefined = this.backboneContext;\n        while (parentContext) {\n          if (element.path?.startsWith(parentContext.path + '.')) {\n            parentContext.type.elements[elementPath(element, parentContext.path)] = field;\n            break;\n          }\n          parentContext = parentContext.parent;\n        }\n\n        if (!parentContext) {\n          // Within R4 StructureDefinitions, there are 2 cases where StructureDefinition.name !== ElementDefinition.path.\n          // For SimpleQuantity and MoneyQuantity, the names are the names, but the root ElementDefinition.path is Quantity.\n          // We need to use StructureDefinition.name for the type name, and ElementDefinition.path for the path.\n          const path = elementPath(element, this.root.path);\n          if (element.isSummary) {\n            this.resourceSchema.summaryProperties?.add(path.replace('[x]', ''));\n          }\n          if (field.min > 0) {\n            this.resourceSchema.mandatoryProperties?.add(path.replace('[x]', ''));\n          }\n          this.resourceSchema.elements[path] = field;\n        }\n\n        // Clean up contextual book-keeping\n        this.checkFieldExit(element);\n      }\n\n      element = this.next();\n    }\n\n    // Wrap up if the StructureDefinition ends on a slice or backbone element\n    this.checkFieldExit();\n    if (this.innerTypes.length > 0) {\n      this.resourceSchema.innerTypes = this.innerTypes;\n    }\n\n    return this.resourceSchema;\n  }\n\n  private checkFieldEnter(element: ElementDefinition, field: InternalSchemaElement): void {\n    if (this.isInnerType(element)) {\n      this.enterInnerType(element);\n    }\n    if (this.slicingContext && !pathsCompatible(this.slicingContext.path, element?.path as string)) {\n      // Path must be compatible with the sliced field path (i.e. have it as a prefix) to be a part of the\n      // same slice group; otherwise, that group is finished and this is the start of a new field\n      this.slicingContext = undefined;\n    }\n    if (element.slicing && !this.slicingContext) {\n      this.enterSlice(element, field);\n    }\n  }\n\n  private enterInnerType(element: ElementDefinition): void {\n    while (this.backboneContext && !pathsCompatible(this.backboneContext?.path, element.path)) {\n      // Starting new inner type, unwind type stack to this property's parent\n      this.innerTypes.push(this.backboneContext.type);\n      this.backboneContext = this.backboneContext.parent;\n    }\n    const typeName = getElementDefinitionTypeName(element);\n    this.backboneContext = {\n      type: {\n        name: typeName,\n        type: typeName,\n        path: element.path,\n        title: element.label,\n        description: element.definition,\n        elements: {},\n        constraints: this.parseElementDefinition(element).constraints,\n        innerTypes: [],\n      },\n      path: element.path,\n      parent: pathsCompatible(this.backboneContext?.path, element.path)\n        ? this.backboneContext\n        : this.backboneContext?.parent,\n    };\n  }\n\n  private enterSlice(element: ElementDefinition, field: InternalSchemaElement): void {\n    if (hasDefaultExtensionSlice(element) && !this.peek()?.sliceName) {\n      // Extensions are always sliced by URL; don't start slicing context if no slices follow\n      return;\n    }\n    field.slicing = {\n      discriminator: (element.slicing?.discriminator ?? []).map((d) => {\n        if (d.type !== 'value' && d.type !== 'pattern' && d.type !== 'type') {\n          throw new Error(`Unsupported slicing discriminator type: ${d.type}`);\n        }\n        return {\n          path: d.path as string,\n          type: d.type as string,\n        };\n      }),\n      slices: [],\n      ordered: element.slicing?.ordered ?? false,\n      rule: element.slicing?.rules,\n    };\n    this.slicingContext = { field: field.slicing, path: element.path ?? '' };\n  }\n\n  private checkFieldExit(element: ElementDefinition | undefined = undefined): void {\n    if (this.backboneContext && !pathsCompatible(this.backboneContext.path, element?.path)) {\n      // Leaving BackboneElement child fields\n      if (this.backboneContext.parent) {\n        do {\n          this.innerTypes.push(this.backboneContext.type);\n          this.backboneContext = this.backboneContext.parent;\n        } while (this.backboneContext && !pathsCompatible(this.backboneContext.path, element?.path));\n      } else {\n        this.innerTypes.push(this.backboneContext.type);\n        this.backboneContext = undefined;\n      }\n    }\n  }\n\n  private next(): ElementDefinition | undefined {\n    const element = this.peek();\n    if (element) {\n      this.index++;\n      return element;\n    }\n    return undefined;\n  }\n\n  private peek(): ElementDefinition | undefined {\n    const element = this.elements[this.index];\n    if (element) {\n      this.elementIndex[element.path ?? ''] = element;\n      if (element.contentReference) {\n        const contentRefPath = element.contentReference.slice(element.contentReference.indexOf('#') + 1);\n        const ref = this.elementIndex[contentRefPath];\n        if (!ref) {\n          return undefined;\n        }\n        return {\n          ...ref,\n          id: element.id,\n          path: element.path,\n          min: element.min ?? ref.min,\n          max: element.max ?? ref.max,\n          base: {\n            path: ref.base?.path ?? contentRefPath,\n            min: element.base?.min ?? ref.base?.min ?? (ref.min as number),\n            max: element.base?.max ?? ref.base?.max ?? (ref.max as string),\n          },\n          contentReference: element.contentReference,\n          definition: element.definition,\n        };\n      }\n      return element;\n    }\n    return undefined;\n  }\n\n  private isInnerType(current: ElementDefinition): boolean {\n    const next = this.peek();\n    return !!(\n      pathsCompatible(current?.path, next?.path) &&\n      current.type?.some((t) => ['BackboneElement', 'Element'].includes(t.code as string))\n    );\n  }\n\n  private parseSliceStart(element: ElementDefinition): void {\n    if (!this.slicingContext) {\n      throw new Error(`Invalid slice start before discriminator: ${element.sliceName} (${element.id})`);\n    }\n\n    this.slicingContext.current = {\n      ...this.parseElementDefinition(element),\n      name: element.sliceName ?? '',\n      definition: element.definition,\n      elements: {},\n    };\n    this.slicingContext.field.slices.push(this.slicingContext.current);\n  }\n\n  private parseElementDefinitionType(ed: ElementDefinition): ElementType[] {\n    return (ed.type ?? []).map((type) => {\n      let code: string | undefined;\n\n      if (type.code === 'BackboneElement' || type.code === 'Element') {\n        code = getElementDefinitionTypeName(ed);\n      }\n\n      if (!code) {\n        // This is a low-level extension that we optimize handling for\n        code = getExtension(type, 'http://hl7.org/fhir/StructureDefinition/structuredefinition-fhir-type')?.valueUrl;\n      }\n\n      if (!code) {\n        code = type.code ?? '';\n      }\n\n      return {\n        code,\n        targetProfile: type.targetProfile,\n        profile: type.profile,\n      };\n    });\n  }\n\n  private parseElementDefinition(ed: ElementDefinition): InternalSchemaElement {\n    const max = parseCardinality(ed.max as string);\n    const baseMax = ed.base?.max ? parseCardinality(ed.base.max) : max;\n    const typedElementDef = { type: 'ElementDefinition', value: ed };\n    return {\n      description: ed.definition || '',\n      path: ed.path || ed.base?.path || '',\n      min: ed.min ?? 0,\n      max: max,\n      isArray: baseMax > 1,\n      constraints: (ed.constraint ?? []).map((c) => ({\n        key: c.key ?? '',\n        severity: c.severity ?? 'error',\n        expression: c.expression ?? '',\n        description: c.human ?? '',\n      })),\n      type: this.parseElementDefinitionType(ed),\n      fixed: firstValue(getTypedPropertyValue(typedElementDef, 'fixed[x]')),\n      pattern: firstValue(getTypedPropertyValue(typedElementDef, 'pattern[x]')),\n      binding: ed.binding,\n    };\n  }\n}\n\n/**\n * Construct the subset of a resource containing a minimum set of fields.  The returned resource is not guaranteed\n * to contain only the provided properties, and may contain others (e.g. `resourceType` and `id`)\n *\n * @param resource - The resource to subset\n * @param properties - The minimum properties to include in the subset\n * @returns The modified resource, containing the listed properties and possibly other mandatory ones\n */\nexport function subsetResource<T extends Resource>(resource: T | undefined, properties: string[]): T | undefined {\n  if (!resource) {\n    return undefined;\n  }\n  const extraProperties = [];\n  for (const property of properties) {\n    extraProperties.push('_' + property);\n    const choiceTypeField = DATA_TYPES[resource.resourceType].elements[property + '[x]'];\n    if (choiceTypeField) {\n      extraProperties.push(...choiceTypeField.type.map((t) => property + capitalize(t.code)));\n    }\n  }\n  for (const property of Object.getOwnPropertyNames(resource)) {\n    if (\n      !properties.includes(property) &&\n      !extraProperties.includes(property) &&\n      !mandatorySubsetProperties.includes(property)\n    ) {\n      Object.defineProperty(resource, property, {\n        enumerable: false,\n        writable: false,\n        value: undefined,\n      });\n    }\n  }\n  resource.meta = { ...resource.meta, tag: resource.meta?.tag ? resource.meta.tag.concat(subsetTag) : [subsetTag] };\n  return resource;\n}\nconst subsetTag: Coding = {\n  system: 'http://hl7.org/fhir/v3/ObservationValue',\n  code: 'SUBSETTED',\n};\nconst mandatorySubsetProperties = ['resourceType', 'id', 'meta'];\n\nfunction parseCardinality(c: string): number {\n  return c === '*' ? Number.POSITIVE_INFINITY : Number.parseInt(c, 10);\n}\n\nfunction elementPath(element: ElementDefinition, prefix = ''): string {\n  return trimPrefix(element.path, prefix);\n}\n\nfunction trimPrefix(str: string | undefined, prefix: string): string {\n  if (!str) {\n    return '';\n  }\n  if (prefix && str.startsWith(prefix)) {\n    return str.substring(prefix.length + 1);\n  }\n  return str;\n}\n\n/**\n * Tests whether two element paths are compatible, i.e. whether the child path is nested under the parent.\n * @param parent - The expected parent path, which should be a prefix of the child path.\n * @param child - The child path to test for compatibility with the parent path.\n * @returns True if the given path is a child of the parent.\n */\nfunction pathsCompatible(parent: string | undefined, child: string | undefined): boolean {\n  if (!parent || !child) {\n    return false;\n  }\n  return child.startsWith(parent + '.') || child === parent;\n}\n\nfunction firstValue(obj: TypedValue | TypedValue[] | undefined): TypedValue | undefined {\n  if (Array.isArray(obj) && obj.length > 0) {\n    return obj[0];\n  } else if (!isEmpty(obj)) {\n    return obj as TypedValue;\n  } else {\n    return undefined;\n  }\n}\n\nfunction hasDefaultExtensionSlice(element: ElementDefinition): boolean {\n  const discriminators = element.slicing?.discriminator;\n  return Boolean(\n    element.type?.some((t) => t.code === 'Extension') &&\n      discriminators?.length === 1 &&\n      discriminators[0].type === 'value' &&\n      discriminators[0].path === 'url'\n  );\n}\n\nfunction getDescription(sd: StructureDefinition): string | undefined {\n  let result = sd.description;\n\n  // Many description strings start with an unwanted prefix \"Base StructureDefinition for X Type: \"\n  // For example:\n  // Base StructureDefinition for Age Type: A duration of time during which an organism (or a process) has existed.\n  // If the description starts with the name of the resource type, remove it.\n  if (result?.startsWith(`Base StructureDefinition for ${sd.name} Type: `)) {\n    result = result.substring(`Base StructureDefinition for ${sd.name} Type: `.length);\n  }\n\n  return result;\n}\n", "import { getTypedPropertyValue, GetTypedPropertyValueOptions } from '../fhirpath/utils';\nimport { isResource, TypedValue } from '../types';\nimport { arrayify } from '../utils';\nimport { getDataType, InternalTypeSchema } from './types';\nimport { isPrimitiveType } from './validation';\n\nexport interface CrawlerVisitor {\n  onEnterObject?: (path: string, value: TypedValueWithPath, schema: InternalTypeSchema) => void;\n  onExitObject?: (path: string, value: TypedValueWithPath, schema: InternalTypeSchema) => void;\n  onEnterResource?: (path: string, value: TypedValueWithPath, schema: InternalTypeSchema) => void;\n  onExitResource?: (path: string, value: TypedValueWithPath, schema: InternalTypeSchema) => void;\n  visitProperty: (\n    parent: TypedValueWithPath,\n    key: string,\n    path: string,\n    propertyValues: (TypedValueWithPath | TypedValueWithPath[])[],\n    schema: InternalTypeSchema\n  ) => void;\n}\n\nexport interface AsyncCrawlerVisitor {\n  onEnterObject?: (path: string, value: TypedValueWithPath, schema: InternalTypeSchema) => Promise<void>;\n  onExitObject?: (path: string, value: TypedValueWithPath, schema: InternalTypeSchema) => Promise<void>;\n  onEnterResource?: (path: string, value: TypedValueWithPath, schema: InternalTypeSchema) => Promise<void>;\n  onExitResource?: (path: string, value: TypedValueWithPath, schema: InternalTypeSchema) => Promise<void>;\n  visitPropertyAsync: (\n    parent: TypedValueWithPath,\n    key: string,\n    path: string,\n    value: TypedValueWithPath | TypedValueWithPath[],\n    schema: InternalTypeSchema\n  ) => Promise<void>;\n}\n\nexport interface CrawlerOptions {\n  skipMissingProperties?: boolean;\n  schema?: InternalTypeSchema;\n  initialPath?: string;\n}\n\n/**\n * Crawls the typed value synchronously.\n * @param typedValue - The typed value to crawl.\n * @param visitor - The visitor functions to apply while crawling.\n * @param options - Options for how to crawl the typed value.\n */\nexport function crawlTypedValue(typedValue: TypedValue, visitor: CrawlerVisitor, options?: CrawlerOptions): void {\n  new Crawler(typedValue, visitor, options).crawl();\n}\n\n/**\n * Crawls the typed value asynchronously.\n * @param typedValue - The typed value to crawl.\n * @param visitor - The visitor functions to apply while crawling.\n * @param options - Options for how to crawl the typed value.\n * @returns Promise to crawl the typed value.\n */\nexport function crawlTypedValueAsync(\n  typedValue: TypedValue,\n  visitor: AsyncCrawlerVisitor,\n  options?: CrawlerOptions\n): Promise<void> {\n  return new AsyncCrawler(typedValue, visitor, options).crawl();\n}\n\nclass Crawler {\n  private readonly root: TypedValue;\n  private readonly visitor: CrawlerVisitor;\n  private readonly schema: InternalTypeSchema;\n  private readonly initialPath: string;\n  private readonly excludeMissingProperties?: boolean;\n\n  constructor(root: TypedValue, visitor: CrawlerVisitor, options?: CrawlerOptions) {\n    this.root = root;\n    this.visitor = visitor;\n\n    this.schema = options?.schema ?? getDataType(root.type);\n    this.initialPath = options?.initialPath ?? this.schema.path;\n    this.excludeMissingProperties = options?.skipMissingProperties;\n  }\n\n  crawl(): void {\n    this.crawlObject({ ...this.root, path: this.initialPath }, this.schema, this.initialPath);\n  }\n\n  private crawlObject(obj: TypedValueWithPath, schema: InternalTypeSchema, path: string): void {\n    const objIsResource = isResource(obj.value);\n\n    if (objIsResource && this.visitor.onEnterResource) {\n      this.visitor.onEnterResource(path, obj, schema);\n    }\n\n    if (this.visitor.onEnterObject) {\n      this.visitor.onEnterObject(path, obj, schema);\n    }\n\n    if (this.excludeMissingProperties) {\n      for (const key of Object.keys(obj.value)) {\n        this.crawlProperty(obj, key, schema, `${path}.${key}`);\n      }\n    } else {\n      for (const key of Object.keys(schema.elements)) {\n        this.crawlProperty(obj, key, schema, `${path}.${key}`);\n      }\n    }\n\n    if (this.visitor.onExitObject) {\n      this.visitor.onExitObject(path, obj, schema);\n    }\n\n    if (objIsResource && this.visitor.onExitResource) {\n      this.visitor.onExitResource(path, obj, schema);\n    }\n  }\n\n  private crawlProperty(parent: TypedValueWithPath, key: string, schema: InternalTypeSchema, path: string): void {\n    const propertyValues = getNestedProperty(parent, key, { withPath: true });\n    if (this.visitor.visitProperty) {\n      this.visitor.visitProperty(parent, key, path, propertyValues, schema);\n    }\n\n    for (const propertyValue of propertyValues) {\n      if (propertyValue) {\n        for (const value of arrayify(propertyValue) as TypedValueWithPath[]) {\n          this.crawlPropertyValue(value, path);\n        }\n      }\n    }\n  }\n\n  private crawlPropertyValue(value: TypedValueWithPath, path: string): void {\n    if (!isPrimitiveType(value.type)) {\n      // Recursively crawl as the expected data type\n      const type = getDataType(value.type);\n      this.crawlObject(value, type, path);\n    }\n  }\n}\n\nclass AsyncCrawler {\n  private readonly root: TypedValue;\n  private readonly visitor: AsyncCrawlerVisitor;\n  private readonly schema: InternalTypeSchema;\n  private readonly initialPath: string;\n  private readonly excludeMissingProperties?: boolean;\n\n  constructor(root: TypedValue, visitor: AsyncCrawlerVisitor, options?: CrawlerOptions) {\n    this.root = root;\n    this.visitor = visitor;\n\n    this.schema = options?.schema ?? getDataType(root.type);\n    this.initialPath = options?.initialPath ?? this.schema.path;\n    this.excludeMissingProperties = options?.skipMissingProperties;\n  }\n\n  async crawl(): Promise<void> {\n    return this.crawlObject({ ...this.root, path: this.initialPath }, this.schema, this.initialPath);\n  }\n\n  private async crawlObject(obj: TypedValueWithPath, schema: InternalTypeSchema, path: string): Promise<void> {\n    const objIsResource = isResource(obj.value);\n\n    if (objIsResource && this.visitor.onEnterResource) {\n      await this.visitor.onEnterResource(path, obj, schema);\n    }\n\n    if (this.visitor.onEnterObject) {\n      await this.visitor.onEnterObject(path, obj, schema);\n    }\n\n    if (this.excludeMissingProperties && obj.value) {\n      for (const key of Object.keys(obj.value)) {\n        await this.crawlProperty(obj, key, schema, `${path}.${key}`);\n      }\n    } else {\n      for (const key of Object.keys(schema.elements)) {\n        await this.crawlProperty(obj, key, schema, `${path}.${key}`);\n      }\n    }\n\n    if (this.visitor.onExitObject) {\n      await this.visitor.onExitObject(path, obj, schema);\n    }\n\n    if (objIsResource && this.visitor.onExitResource) {\n      await this.visitor.onExitResource(path, obj, schema);\n    }\n  }\n\n  private async crawlProperty(\n    parent: TypedValueWithPath,\n    key: string,\n    schema: InternalTypeSchema,\n    path: string\n  ): Promise<void> {\n    const propertyValues = getNestedProperty(parent, key, { withPath: true });\n    if (this.visitor.visitPropertyAsync) {\n      for (const propertyValue of propertyValues) {\n        await this.visitor.visitPropertyAsync(parent, key, path, propertyValue, schema);\n      }\n    }\n\n    for (const propertyValue of propertyValues) {\n      if (propertyValue) {\n        for (const value of arrayify(propertyValue) as TypedValueWithPath[]) {\n          await this.crawlPropertyValue(value, path);\n        }\n      }\n    }\n  }\n\n  private async crawlPropertyValue(value: TypedValueWithPath, path: string): Promise<void> {\n    if (!isPrimitiveType(value.type)) {\n      // Recursively crawl as the expected data type\n      const type = getDataType(value.type);\n      await this.crawlObject(value, type, path);\n    }\n  }\n}\n\nexport function getNestedProperty(\n  value: TypedValueWithPath | undefined,\n  key: string,\n  options: { profileUrl?: string; withPath: true }\n): (TypedValueWithPath | TypedValueWithPath[])[];\nexport function getNestedProperty(\n  value: TypedValue | undefined,\n  key: string,\n  options?: { profileUrl?: string; withPath?: false }\n): (TypedValue | TypedValue[] | undefined)[];\nexport function getNestedProperty(\n  value: TypedValue | undefined,\n  key: string,\n  options?: { profileUrl?: string; withPath?: boolean }\n): (TypedValue | TypedValue[] | undefined)[] {\n  if (value === undefined) {\n    return [undefined];\n  }\n\n  if (key === '$this') {\n    return [value];\n  }\n\n  const propertyGetter = options?.withPath ? getTypedPropertyValueWithPath : getTypedPropertyValue;\n\n  const [firstProp, ...nestedProps] = key.split('.');\n  let propertyValues = [propertyGetter(value, firstProp, options)];\n  for (const prop of nestedProps) {\n    const next = [];\n    for (const current of propertyValues) {\n      if (Array.isArray(current)) {\n        for (const element of current) {\n          next.push(propertyGetter(element, prop, options));\n        }\n      } else if (options?.withPath && current && current.value !== undefined) {\n        next.push(propertyGetter(current, prop, options));\n      } else if (!options?.withPath && current !== undefined) {\n        next.push(propertyGetter(current, prop, options));\n      }\n    }\n    propertyValues = next;\n  }\n  return propertyValues;\n}\n\nexport function getTypedPropertyValueWithPath(\n  input: TypedValue | TypedValueWithPath,\n  path: string,\n  options?: GetTypedPropertyValueOptions\n): TypedValueWithPath[] | TypedValueWithPath {\n  const parentPath = (input as TypedValueWithPath).path;\n  return withPath(getTypedPropertyValue(input, path, options), parentPath, path);\n}\n\nexport type TypedValueWithPath = TypedValue & { path: string };\n\nfunction withPath(\n  tv: TypedValue | TypedValue[] | undefined,\n  parentPath: string | undefined,\n  key: string\n): TypedValueWithPath | TypedValueWithPath[] {\n  const parentPrefix = parentPath ? parentPath + '.' : '';\n\n  if (tv === undefined) {\n    return { type: 'undefined', value: undefined, path: `${parentPrefix}${key}` };\n  }\n\n  if (Array.isArray(tv)) {\n    return tv.map((v, idx) => ({\n      ...v,\n      path: `${parentPrefix}${key}[${idx}]`,\n    }));\n  }\n\n  return { ...tv, path: `${parentPrefix}${key}` };\n}\n", "import { OperationOutcomeIssue, Resource, StructureDefinition } from '@medplum/fhirtypes';\nimport { LRUCache } from '../cache';\nimport { HTTP_HL7_ORG, UCUM } from '../constants';\nimport { FhirPathAtom } from '../fhirpath/atoms';\nimport { evalFhirPathTyped } from '../fhirpath/parse';\nimport { getTypedPropertyValue, toTypedValue } from '../fhirpath/utils';\nimport {\n  OperationOutcomeError,\n  createConstraintIssue,\n  createOperationOutcomeIssue,\n  createProcessingIssue,\n  createStructureIssue,\n  validationError,\n} from '../outcomes';\nimport { PropertyType, TypedValue, isReference, isResource } from '../types';\nimport { arrayify, deepEquals, deepIncludes, isEmpty } from '../utils';\nimport { CrawlerVisitor, TypedValueWithPath, crawlTypedValue, getNestedProperty } from './crawler';\nimport {\n  Constraint,\n  InternalSchemaElement,\n  InternalTypeSchema,\n  SliceDefinition,\n  SliceDiscriminator,\n  SlicingRules,\n  getDataType,\n  parseStructureDefinition,\n} from './types';\n\n/*\n * This file provides schema validation utilities for FHIR JSON objects.\n *\n * See: [JSON Representation of Resources](https://hl7.org/fhir/json.html)\n * See: [FHIR Data Types](https://www.hl7.org/fhir/datatypes.html)\n */\nexport const fhirTypeToJsType = {\n  base64Binary: 'string',\n  boolean: 'boolean',\n  canonical: 'string',\n  code: 'string',\n  date: 'string',\n  dateTime: 'string',\n  decimal: 'number',\n  id: 'string',\n  instant: 'string',\n  integer: 'number',\n  integer64: 'string',\n  markdown: 'string',\n  oid: 'string',\n  positiveInt: 'number',\n  string: 'string',\n  time: 'string',\n  unsignedInt: 'number',\n  uri: 'string',\n  url: 'string',\n  uuid: 'string',\n  xhtml: 'string',\n  'http://hl7.org/fhirpath/System.String': 'string', // Not actually a FHIR type, but included in some StructureDefinition resources\n} as const satisfies Record<string, 'string' | 'boolean' | 'number'>;\n\nconst fhirPathCache = new LRUCache<FhirPathAtom>(1_000);\n\n/**\n * Returns true if the type code is a primitive type.\n * @param code - The type code to check.\n * @returns True if the type code is a primitive type.\n */\nexport function isPrimitiveType(code: string): boolean {\n  return code === 'undefined' || code in fhirTypeToJsType;\n}\n\n/*\n * This file provides schema validation utilities for FHIR JSON objects.\n *\n * See: [JSON Representation of Resources](https://hl7.org/fhir/json.html)\n * See: [FHIR Data Types](https://www.hl7.org/fhir/datatypes.html)\n */\nexport const validationRegexes: Record<string, RegExp> = {\n  base64Binary: /^([A-Za-z\\d+/]{4})*([A-Za-z\\d+/]{2}==|[A-Za-z\\d+/]{3}=)?$/,\n  canonical: /^\\S*$/,\n  code: /^[^\\s]+( [^\\s]+)*$/,\n  date: /^(\\d(\\d(\\d[1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2]\\d|3[0-1]))?)?$/,\n  dateTime:\n    /^(\\d(\\d(\\d[1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2]\\d|3[0-1])(T([01]\\d|2[0-3])(:[0-5]\\d:([0-5]\\d|60)(\\.\\d{1,9})?)?)?)?(Z|[+-]((0\\d|1[0-3]):[0-5]\\d|14:00)?)?)?$/,\n  id: /^[A-Za-z0-9\\-.]{1,64}$/,\n  instant:\n    /^(\\d(\\d(\\d[1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2]\\d|3[0-1])T([01]\\d|2[0-3]):[0-5]\\d:([0-5]\\d|60)(\\.\\d{1,9})?(Z|[+-]((0\\d|1[0-3]):[0-5]\\d|14:00))$/,\n  markdown: /^[\\r\\n\\t\\u0020-\\uFFFF]+$/,\n  oid: /^urn:oid:[0-2](\\.(0|[1-9]\\d*))+$/,\n  string: /^[\\r\\n\\t\\u0020-\\uFFFF]+$/,\n  time: /^([01]\\d|2[0-3]):[0-5]\\d:([0-5]\\d|60)(\\.\\d{1,9})?$/,\n  uri: /^\\S*$/,\n  url: /^\\S*$/,\n  uuid: /^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/,\n  xhtml: /.*/,\n} as const;\n\n/**\n * List of constraint keys that aren't to be checked in an expression.\n */\nconst skippedConstraintKeys: Record<string, boolean> = {\n  'ele-1': true,\n  'dom-3': true, // If the resource is contained in another resource, it SHALL be referred to from elsewhere in the resource (requries \"descendants()\")\n  'org-1': true, // The organization SHALL at least have a name or an identifier, and possibly more than one (back compat)\n  'sdf-19': true, // FHIR Specification models only use FHIR defined types\n};\n\nexport interface ValidatorOptions {\n  profile?: StructureDefinition;\n}\n\nexport function validateResource(resource: Resource, options?: ValidatorOptions): OperationOutcomeIssue[] {\n  if (!resource.resourceType) {\n    throw new OperationOutcomeError(validationError('Missing resource type'));\n  }\n  return new ResourceValidator(toTypedValue(resource), options).validate();\n}\n\nexport function validateTypedValue(typedValue: TypedValue, options?: ValidatorOptions): OperationOutcomeIssue[] {\n  return new ResourceValidator(typedValue, options).validate();\n}\n\nclass ResourceValidator implements CrawlerVisitor {\n  private readonly issues: OperationOutcomeIssue[];\n  private readonly root: TypedValue;\n  private currentResource: Resource[];\n  private readonly schema: InternalTypeSchema;\n\n  constructor(typedValue: TypedValue, options?: ValidatorOptions) {\n    this.issues = [];\n    this.root = typedValue;\n    this.currentResource = [];\n    if (isResource(typedValue.value)) {\n      this.currentResource.push(typedValue.value);\n    }\n    if (!options?.profile) {\n      this.schema = getDataType(typedValue.type);\n    } else {\n      this.schema = parseStructureDefinition(options.profile);\n    }\n  }\n\n  validate(): OperationOutcomeIssue[] {\n    // Check root constraints\n    this.constraintsCheck({ ...this.root, path: this.schema.path }, this.schema);\n\n    checkObjectForNull(this.root.value as unknown as Record<string, unknown>, this.schema.path, this.issues);\n\n    crawlTypedValue(this.root, this, { schema: this.schema, initialPath: this.schema.path });\n\n    const issues = this.issues;\n\n    let foundError = false;\n    for (const issue of issues) {\n      if (issue.severity === 'error') {\n        foundError = true;\n      }\n    }\n\n    if (foundError) {\n      throw new OperationOutcomeError({\n        resourceType: 'OperationOutcome',\n        issue: issues,\n      });\n    }\n\n    return issues;\n  }\n\n  onExitObject(_path: string, obj: TypedValueWithPath, schema: InternalTypeSchema): void {\n    //@TODO(mattwiller 2023-06-05): Detect extraneous properties in a single pass by keeping track of all keys that\n    // were correctly matched to resource properties as elements are validated above\n    this.checkAdditionalProperties(obj, schema.elements, obj.path);\n  }\n\n  onEnterResource(_path: string, obj: TypedValueWithPath): void {\n    this.currentResource.push(obj.value);\n  }\n\n  onExitResource(): void {\n    this.currentResource.pop();\n  }\n\n  visitProperty(\n    _parent: TypedValueWithPath,\n    key: string,\n    path: string,\n    propertyValues: (TypedValueWithPath | TypedValueWithPath[])[],\n    schema: InternalTypeSchema\n  ): void {\n    const element = schema.elements[key];\n    if (!element) {\n      throw new Error(`Missing element validation schema for ${key}`);\n    }\n\n    for (const value of propertyValues) {\n      if (!this.checkPresence(value, element, path)) {\n        return;\n      }\n      // Check cardinality\n      let values: TypedValueWithPath[];\n      if (element.isArray) {\n        if (!Array.isArray(value)) {\n          this.issues.push(createStructureIssue(path, 'Expected array of values for property'));\n          return;\n        }\n        values = value;\n      } else {\n        if (Array.isArray(value)) {\n          this.issues.push(createStructureIssue(path, 'Expected single value for property'));\n          return;\n        }\n        values = [value];\n      }\n\n      if (values.length < element.min || values.length > element.max) {\n        this.issues.push(\n          createStructureIssue(\n            element.path,\n            `Invalid number of values: expected ${element.min}..${\n              Number.isFinite(element.max) ? element.max : '*'\n            }, but found ${values.length}`\n          )\n        );\n      }\n\n      if (!matchesSpecifiedValue(value, element)) {\n        this.issues.push(createStructureIssue(path, 'Value did not match expected pattern'));\n      }\n\n      const sliceCounts: Record<string, number> | undefined = element.slicing\n        ? Object.fromEntries(element.slicing.slices.map((s) => [s.name, 0]))\n        : undefined;\n      for (const value of values) {\n        this.constraintsCheck(value, element);\n        this.referenceTypeCheck(value, element);\n        this.checkPropertyValue(value);\n\n        const sliceName = checkSliceElement(value, element.slicing);\n        if (sliceName && sliceCounts) {\n          sliceCounts[sliceName] += 1;\n        }\n      }\n\n      this.validateSlices(element.slicing?.slices, sliceCounts, path);\n    }\n  }\n\n  private checkPresence(\n    value: TypedValueWithPath | TypedValueWithPath[],\n    field: InternalSchemaElement,\n    path: string\n  ): boolean {\n    if (!Array.isArray(value) && value.value === undefined) {\n      if (field.min > 0) {\n        this.issues.push(createStructureIssue(value.path, 'Missing required property'));\n      }\n      return false;\n    }\n\n    if (isEmpty(value)) {\n      this.issues.push(createStructureIssue(path, 'Invalid empty value'));\n      return false;\n    }\n\n    return true;\n  }\n\n  private checkPropertyValue(value: TypedValueWithPath): void {\n    if (isPrimitiveType(value.type)) {\n      this.validatePrimitiveType(value);\n    } else if (isEmpty(value.value)) {\n      this.issues.push(createStructureIssue(value.path, `Invalid empty non-primitive value`));\n    }\n  }\n\n  private validateSlices(\n    slices: SliceDefinition[] | undefined,\n    counts: Record<string, number> | undefined,\n    path: string\n  ): void {\n    if (!slices || !counts) {\n      return;\n    }\n    for (const slice of slices) {\n      const sliceCardinality = counts[slice.name];\n      if (sliceCardinality < slice.min || sliceCardinality > slice.max) {\n        this.issues.push(\n          createStructureIssue(\n            path,\n            `Incorrect number of values provided for slice '${slice.name}': expected ${slice.min}..${\n              Number.isFinite(slice.max) ? slice.max : '*'\n            }, but found ${sliceCardinality}`\n          )\n        );\n      }\n    }\n  }\n\n  private checkAdditionalProperties(\n    parent: TypedValueWithPath,\n    properties: Record<string, InternalSchemaElement>,\n    path: string\n  ): void {\n    const object = parent.value as Record<string, unknown> | undefined;\n    if (!object) {\n      return;\n    }\n    const choiceOfTypeElements: Record<string, string> = {};\n    for (const key of Object.keys(object)) {\n      if (key === 'resourceType') {\n        continue; // Skip special resource type discriminator property in JSON\n      }\n      const choiceOfTypeElementName = isChoiceOfType(parent, key, properties);\n      if (choiceOfTypeElementName) {\n        // check that the type of the primitive extension matches the type of the property\n        let relatedElementName: string;\n        let requiredRelatedElementName: string;\n        if (choiceOfTypeElementName.startsWith('_')) {\n          relatedElementName = choiceOfTypeElementName.slice(1);\n          requiredRelatedElementName = key.slice(1);\n        } else {\n          relatedElementName = '_' + choiceOfTypeElementName;\n          requiredRelatedElementName = '_' + key;\n        }\n\n        if (\n          relatedElementName in choiceOfTypeElements &&\n          choiceOfTypeElements[relatedElementName] !== requiredRelatedElementName\n        ) {\n          this.issues.push(\n            createOperationOutcomeIssue(\n              'warning',\n              'structure',\n              `Type of primitive extension does not match the type of property \"${choiceOfTypeElementName.startsWith('_') ? choiceOfTypeElementName.slice(1) : choiceOfTypeElementName}\"`,\n              choiceOfTypeElementName\n            )\n          );\n        }\n\n        if (choiceOfTypeElements[choiceOfTypeElementName]) {\n          // Found a duplicate choice of type property\n          // TODO: This should be an error, but it's currently a warning to avoid breaking existing code\n          // Warnings are logged, but do not cause validation to fail\n          this.issues.push(\n            createOperationOutcomeIssue(\n              'warning',\n              'structure',\n              `Conflicting choice of type properties: \"${key}\", \"${choiceOfTypeElements[choiceOfTypeElementName]}\"`,\n              key\n            )\n          );\n        }\n        choiceOfTypeElements[choiceOfTypeElementName] = key;\n        continue;\n      }\n      if (!(key in properties) && !(key.startsWith('_') && key.slice(1) in properties)) {\n        this.issues.push(createStructureIssue(`${path}.${key}`, `Invalid additional property \"${key}\"`));\n      }\n    }\n  }\n\n  private constraintsCheck(value: TypedValueWithPath, field: InternalTypeSchema | InternalSchemaElement): void {\n    const constraints = field.constraints;\n    if (!constraints) {\n      return;\n    }\n    for (const constraint of constraints) {\n      if (constraint.severity === 'error' && !(constraint.key in skippedConstraintKeys)) {\n        const expression = this.isExpressionTrue(constraint, value);\n        if (!expression) {\n          this.issues.push(createConstraintIssue(value.path, constraint));\n          return;\n        }\n      }\n    }\n  }\n\n  private referenceTypeCheck(value: TypedValueWithPath, field: InternalSchemaElement): void {\n    if (value.type !== 'Reference') {\n      return;\n    }\n\n    const reference = value.value;\n    if (!isReference(reference)) {\n      // Silently ignore unrecognized reference types\n      return;\n    }\n\n    if (reference.reference.startsWith('#')) {\n      // Silently ignore contained references\n      return;\n    }\n\n    // Pick out the resource type from the reference, either as a conditional reference or a literal reference\n    const referenceResourceType = reference.reference.includes('?')\n      ? reference.reference.split('?')[0]\n      : reference.reference.split('/')[0];\n\n    if (!referenceResourceType) {\n      // Silently ignore empty references - that will get picked up by constraint validation\n      return;\n    }\n\n    const targetProfiles = field.type.find((t) => t.code === 'Reference')?.targetProfile;\n    if (!targetProfiles) {\n      // No required target profiles\n      return;\n    }\n\n    const hl7BaseUrl = HTTP_HL7_ORG + '/fhir/StructureDefinition/';\n    const hl7AllResourcesUrl = hl7BaseUrl + 'Resource';\n    const hl7ResourceTypeUrl = hl7BaseUrl + referenceResourceType;\n\n    const medplumBaseUrl = 'https://medplum.com/fhir/StructureDefinition/';\n    const medplumResourceTypeUrl = medplumBaseUrl + referenceResourceType;\n\n    for (const targetProfile of targetProfiles) {\n      if (\n        targetProfile === hl7AllResourcesUrl ||\n        targetProfile === hl7ResourceTypeUrl ||\n        targetProfile === medplumResourceTypeUrl\n      ) {\n        // Found a matching profile\n        return;\n      }\n\n      if (!targetProfile.startsWith(hl7BaseUrl) && !targetProfile.startsWith(medplumBaseUrl)) {\n        // This is an unrecognized target profile string\n        // For example, it could be US-Core or a custom profile definition\n        // Example: http://hl7.org/fhir/us/core/StructureDefinition/us-core-patient\n        // And therefore we cannot validate\n        return;\n      }\n    }\n\n    // All of the target profiles were recognized formats\n    // and we did not find a match\n    // TODO: This should be an error, but it's currently a warning to avoid breaking existing code\n    // Warnings are logged, but do not cause validation to fail\n    this.issues.push(\n      createOperationOutcomeIssue(\n        'warning',\n        'structure',\n        `Invalid reference: got \"${referenceResourceType}\", expected \"${targetProfiles.join('\", \"')}\"`,\n        value.path\n      )\n    );\n  }\n\n  private isExpressionTrue(constraint: Constraint, value: TypedValueWithPath): boolean {\n    const variables: Record<string, TypedValue> = {\n      '%context': value,\n      '%ucum': toTypedValue(UCUM),\n    };\n\n    if (this.currentResource.length > 0) {\n      variables['%resource'] = toTypedValue(this.currentResource[this.currentResource.length - 1]);\n    }\n\n    if (isResource(this.root.value)) {\n      variables['%rootResource'] = this.root;\n    }\n\n    try {\n      const evalValues = evalFhirPathTyped(constraint.expression, [value], variables, fhirPathCache);\n\n      return evalValues.length === 1 && evalValues[0].value === true;\n    } catch (e: any) {\n      this.issues.push(\n        createProcessingIssue(value.path, 'Error evaluating invariant expression', e, {\n          fhirpath: constraint.expression,\n        })\n      );\n      return false;\n    }\n  }\n\n  private validatePrimitiveType(typedValue: TypedValueWithPath): void {\n    const [primitiveValue, extensionElement] = unpackPrimitiveElement(typedValue);\n    const path = typedValue.path;\n\n    if (primitiveValue) {\n      const { type, value } = primitiveValue;\n      // First, make sure the value is the correct JS type\n      if (!(type in fhirTypeToJsType)) {\n        this.issues.push(createStructureIssue(path, `Invalid JSON type: ${type} is not a valid FHIR type`));\n        return;\n      }\n      const expectedType = fhirTypeToJsType[type as keyof typeof fhirTypeToJsType];\n      // biome-ignore lint/suspicious/useValidTypeof: expected value ensured to be one of: 'string' | 'boolean' | 'number'\n      if (typeof value !== expectedType) {\n        if (value !== null) {\n          this.issues.push(\n            createStructureIssue(path, `Invalid JSON type: expected ${expectedType}, but got ${typeof value}`)\n          );\n        }\n        return;\n      }\n      // Then, perform additional checks for specialty types\n      if (expectedType === 'string') {\n        this.validateString(value as string, type, path);\n      } else if (expectedType === 'number') {\n        this.validateNumber(value as number, type, path);\n      }\n    }\n    if (extensionElement) {\n      crawlTypedValue(extensionElement, this, { schema: getDataType('Element'), initialPath: path });\n    }\n  }\n\n  private validateString(str: string, type: string, path: string): void {\n    if (!str.trim()) {\n      this.issues.push(createStructureIssue(path, 'String must contain non-whitespace content'));\n      return;\n    }\n\n    const regex = validationRegexes[type];\n    if (regex && !regex.exec(str)) {\n      this.issues.push(createStructureIssue(path, 'Invalid ' + type + ' format'));\n    }\n  }\n\n  private validateNumber(n: number, type: string, path: string): void {\n    if (Number.isNaN(n) || !Number.isFinite(n)) {\n      this.issues.push(createStructureIssue(path, 'Invalid numeric value'));\n    } else if (isIntegerType(type) && !Number.isInteger(n)) {\n      this.issues.push(createStructureIssue(path, 'Expected number to be an integer'));\n    } else if (type === PropertyType.positiveInt && n <= 0) {\n      this.issues.push(createStructureIssue(path, 'Expected number to be positive'));\n    } else if (type === PropertyType.unsignedInt && n < 0) {\n      this.issues.push(createStructureIssue(path, 'Expected number to be non-negative'));\n    }\n  }\n}\n\nfunction isIntegerType(propertyType: string): boolean {\n  return (\n    propertyType === PropertyType.integer ||\n    propertyType === PropertyType.positiveInt ||\n    propertyType === PropertyType.unsignedInt\n  );\n}\n\n/**\n * Returns the choice-of-type element name if the key is a choice of type property.\n * Returns undefined if the key is not a choice of type property.\n * @param typedValue - The value to check.\n * @param key - The object key to check. This is different than the element name, which could contain \"[x]\".\n * @param propertyDefinitions - The property definitions for the object..\n * @returns The element name if a choice of type property is present, otherwise undefined.\n */\nfunction isChoiceOfType(\n  typedValue: TypedValue,\n  key: string,\n  propertyDefinitions: Record<string, InternalSchemaElement>\n): string | undefined {\n  let prefix = '';\n  if (key.startsWith('_')) {\n    key = key.slice(1);\n    prefix = '_';\n  }\n  const parts = key.split(/(?=[A-Z])/g); // Split before capital letters\n  let testProperty = '';\n  for (const part of parts) {\n    testProperty += part;\n    const elementName = testProperty + '[x]';\n    if (propertyDefinitions[elementName]) {\n      const typedPropertyValue = getTypedPropertyValue(typedValue, testProperty);\n      return typedPropertyValue ? prefix + elementName : undefined;\n    }\n  }\n  return undefined;\n}\n\nfunction checkObjectForNull(obj: Record<string, unknown>, path: string, issues: OperationOutcomeIssue[]): void {\n  for (const [key, value] of Object.entries(obj)) {\n    const propertyPath = `${path}.${key}`;\n    const partnerKey = key.startsWith('_') ? key.slice(1) : `_${key}`;\n    if (value === null) {\n      issues.push(createStructureIssue(propertyPath, 'Invalid null value'));\n    } else if (Array.isArray(value)) {\n      for (let i = 0; i < value.length; i++) {\n        if (value[i] === undefined) {\n          issues.push(createStructureIssue(`${propertyPath}[${i}]`, 'Invalid undefined value'));\n        } else if (value[i] === null && !(obj[partnerKey] as any)?.[i]) {\n          // This tests for the one case where `null` is allowed in FHIR JSON, where an array of primitive values\n          // has extensions for some but not all values\n          issues.push(createStructureIssue(`${propertyPath}[${i}]`, 'Invalid null value'));\n        } else if (value[i]) {\n          checkObjectForNull(value[i], `${propertyPath}[${i}]`, issues);\n        }\n      }\n    } else if (typeof value === 'object') {\n      checkObjectForNull(value as Record<string, unknown>, propertyPath, issues);\n    }\n  }\n}\n\nfunction matchesSpecifiedValue(value: TypedValue | TypedValue[], element: InternalSchemaElement): boolean {\n  // It is possible that `value` has additional keys beyond `type` and `value` (e.g. `expression` if a\n  // `TypedValueWithExpression` is being used), so ensure that only `type` and `value` are considered for comparison.\n  const typeAndValue = Array.isArray(value)\n    ? value.map((v) => ({ type: v.type, value: v.value }))\n    : { type: value.type, value: value.value };\n\n  if (element.pattern && !deepIncludes(typeAndValue, element.pattern)) {\n    return false;\n  }\n  if (element.fixed && !deepEquals(typeAndValue, element.fixed)) {\n    return false;\n  }\n  return true;\n}\n\nexport function matchDiscriminant(\n  value: TypedValue | TypedValue[] | undefined,\n  discriminator: SliceDiscriminator,\n  slice: SliceDefinition,\n  elements?: Record<string, InternalSchemaElement>\n): boolean {\n  if (Array.isArray(value)) {\n    // Only single values can match\n    return false;\n  }\n\n  let sliceElement: InternalSchemaElement | undefined;\n  if (discriminator.path === '$this') {\n    sliceElement = slice;\n  } else {\n    sliceElement = (elements ?? slice.elements)[discriminator.path];\n  }\n\n  const sliceType = slice.type;\n  switch (discriminator.type) {\n    case 'value':\n    case 'pattern':\n      if (!value || !sliceElement) {\n        return false;\n      }\n      if (sliceElement.pattern) {\n        return deepIncludes(value, sliceElement.pattern);\n      }\n      if (sliceElement.fixed) {\n        return deepEquals(value, sliceElement.fixed);\n      }\n\n      if (sliceElement.binding?.strength === 'required' && sliceElement.binding.valueSet) {\n        // This cannot be implemented correctly without asynchronous validation, so make it permissive for now.\n        // Ideally this should check something like value.value.coding.some((code) => isValidCode(sliceElement.binding.valueSet, code))\n        // where isValidCode is a function that checks if the code is included in the expansion of the ValueSet\n        return true;\n      }\n      break;\n    case 'type':\n      if (!value || !sliceType?.length) {\n        return false;\n      }\n      return sliceType.some((t) => t.code === value.type);\n    // Other discriminator types are not yet supported, see http://hl7.org/fhir/R4/profiling.html#discriminator\n  }\n  // Default to no match\n  return false;\n}\n\nfunction checkSliceElement(value: TypedValue, slicingRules: SlicingRules | undefined): string | undefined {\n  if (!slicingRules) {\n    return undefined;\n  }\n  for (const slice of slicingRules.slices) {\n    if (\n      slicingRules.discriminator.every((discriminator) =>\n        arrayify(getNestedProperty(value, discriminator.path))?.some((v) => matchDiscriminant(v, discriminator, slice))\n      )\n    ) {\n      return slice.name;\n    }\n  }\n  return undefined;\n}\n\nfunction unpackPrimitiveElement(v: TypedValue): [TypedValue | undefined, TypedValue | undefined] {\n  if (typeof v.value !== 'object' || !v.value) {\n    return [v, undefined];\n  }\n  const primitiveValue = v.value.valueOf();\n  if (primitiveValue === v.value) {\n    return [undefined, { type: 'Element', value: v.value }];\n  }\n  const primitiveKeys = new Set(Object.keys(primitiveValue));\n  const extensionEntries = Object.entries(v.value).filter(([k, _]) => !primitiveKeys.has(k));\n  const extensionElement = extensionEntries.length > 0 ? Object.fromEntries(extensionEntries) : undefined;\n  return [\n    { type: v.type, value: primitiveValue },\n    { type: 'Element', value: extensionElement },\n  ];\n}\n", "import { Coding, Extension, Period, Quantity } from '@medplum/fhirtypes';\nimport { PropertyType, TypedValue, getElementDefinition, isResource } from '../types';\nimport { InternalSchemaElement } from '../typeschema/types';\nimport { validationRegexes } from '../typeschema/validation';\nimport { capitalize, isCodeableConcept, isCoding, isEmpty } from '../utils';\n\n/**\n * Returns a single element array with a typed boolean value.\n * @param value - The primitive boolean value.\n * @returns Single element array with a typed boolean value.\n */\nexport function booleanToTypedValue(value: boolean): [TypedValue] {\n  return [{ type: PropertyType.boolean, value }];\n}\n\n/**\n * Returns a \"best guess\" TypedValue for a given value.\n * @param value - The unknown value to check.\n * @returns A \"best guess\" TypedValue for the given value.\n */\nexport function toTypedValue(value: unknown): TypedValue {\n  if (value === null || value === undefined) {\n    return { type: 'undefined', value: undefined };\n  } else if (Number.isSafeInteger(value)) {\n    return { type: PropertyType.integer, value };\n  } else if (typeof value === 'number') {\n    return { type: PropertyType.decimal, value };\n  } else if (typeof value === 'boolean') {\n    return { type: PropertyType.boolean, value };\n  } else if (typeof value === 'string') {\n    return { type: PropertyType.string, value };\n  } else if (isQuantity(value)) {\n    return { type: PropertyType.Quantity, value };\n  } else if (isResource(value)) {\n    return { type: value.resourceType, value };\n  } else if (isCodeableConcept(value)) {\n    return { type: PropertyType.CodeableConcept, value };\n  } else if (isCoding(value)) {\n    return { type: PropertyType.Coding, value };\n  } else {\n    return { type: PropertyType.BackboneElement, value };\n  }\n}\n\n/**\n * Converts unknown object into a JavaScript boolean.\n * Note that this is different than the FHIRPath \"toBoolean\",\n * which has particular semantics around arrays, empty arrays, and type conversions.\n * @param obj - Any value or array of values.\n * @returns The converted boolean value according to FHIRPath rules.\n */\nexport function toJsBoolean(obj: TypedValue[]): boolean {\n  return obj.length === 0 ? false : !!obj[0].value;\n}\n\nexport function singleton(collection: TypedValue[], type?: string): TypedValue | undefined {\n  if (collection.length === 0) {\n    return undefined;\n  } else if (collection.length === 1 && (!type || collection[0].type === type)) {\n    return collection[0];\n  } else {\n    throw new Error(`Expected singleton of type ${type}, but found ${JSON.stringify(collection)}`);\n  }\n}\n\nexport interface GetTypedPropertyValueOptions {\n  /** (optional) URL of a resource profile for type resolution */\n  profileUrl?: string;\n}\n\n/**\n * Returns the value of the property and the property type.\n * Some property definitions support multiple types.\n * For example, \"Observation.value[x]\" can be \"valueString\", \"valueInteger\", \"valueQuantity\", etc.\n * According to the spec, there can only be one property for a given element definition.\n * This function returns the value and the type.\n * @param input - The base context (FHIR resource or backbone element).\n * @param path - The property path.\n * @param options - (optional) Additional options\n * @returns The value of the property and the property type.\n */\nexport function getTypedPropertyValue(\n  input: TypedValue,\n  path: string,\n  options?: GetTypedPropertyValueOptions\n): TypedValue[] | TypedValue | undefined {\n  if (!input.value) {\n    return undefined;\n  }\n\n  const elementDefinition = getElementDefinition(input.type, path, options?.profileUrl);\n  if (elementDefinition) {\n    return getTypedPropertyValueWithSchema(input, path, elementDefinition);\n  }\n\n  return getTypedPropertyValueWithoutSchema(input, path);\n}\n\n/**\n * Returns the value of the property and the property type using a type schema.\n * @param typedValue - The base context (FHIR resource or backbone element).\n * @param path - The property path.\n * @param element - The property element definition.\n * @returns The value of the property and the property type.\n */\nexport function getTypedPropertyValueWithSchema(\n  typedValue: TypedValue,\n  path: string,\n  element: InternalSchemaElement\n): TypedValue[] | TypedValue | undefined {\n  // Consider the following cases of the inputs:\n\n  // \"path\" input types:\n  // 1. Simple path, e.g., \"name\"\n  // 2. Choice-of-type without type, e.g., \"value[x]\"\n  // 3. Choice-of-type with type, e.g., \"valueBoolean\"\n\n  // \"element\" can be either:\n  // 1. Full ElementDefinition from a well-formed StructureDefinition\n  // 2. Partial ElementDefinition from base-schema.json\n\n  // \"types\" input types:\n  // 1. Simple single type, e.g., \"string\"\n  // 2. Choice-of-type with full array of types, e.g., [\"string\", \"integer\", \"Quantity\"]\n  // 3. Choice-of-type with single array of types, e.g., [\"Quantity\"]\n\n  // Note that FHIR Profiles can define a single type for a choice-of-type element.\n  // e.g. https://build.fhir.org/ig/HL7/US-Core/StructureDefinition-us-core-birthsex.html\n  // Therefore, cannot only check for endsWith('[x]') since FHIRPath uses this code path\n  // with a path of 'value' and expects Choice of Types treatment\n\n  const value = typedValue.value;\n  const types = element.type;\n  if (!types || types.length === 0) {\n    return undefined;\n  }\n\n  // The path parameter can be in both \"value[x]\" form and \"valueBoolean\" form.\n  // So we need to use the element path to find the type.\n  let resultValue: any = undefined;\n  let resultType = 'undefined';\n  let primitiveExtension: Extension[] | undefined = undefined;\n\n  const lastPathSegmentIndex = element.path.lastIndexOf('.');\n  const lastPathSegment = element.path.substring(lastPathSegmentIndex + 1);\n  for (const type of types) {\n    const candidatePath = lastPathSegment.replace('[x]', capitalize(type.code));\n    resultValue = value[candidatePath];\n    primitiveExtension = value['_' + candidatePath];\n    if (resultValue !== undefined || primitiveExtension !== undefined) {\n      resultType = type.code;\n      break;\n    }\n  }\n\n  // When checking for primitive extensions, we must use the \"resolved\" path.\n  // In the case of [x] choice-of-type, the type must be resolved to a single type.\n  if (primitiveExtension) {\n    if (Array.isArray(resultValue)) {\n      // Slice to avoid mutating the array in the input value\n      resultValue = resultValue.slice();\n      for (let i = 0; i < Math.max(resultValue.length, primitiveExtension.length); i++) {\n        resultValue[i] = assignPrimitiveExtension(resultValue[i], primitiveExtension[i]);\n      }\n    } else {\n      resultValue = assignPrimitiveExtension(resultValue, primitiveExtension);\n    }\n  }\n\n  if (isEmpty(resultValue)) {\n    return undefined;\n  }\n\n  if (resultType === 'Element' || resultType === 'BackboneElement') {\n    resultType = element.type[0].code;\n  }\n\n  if (Array.isArray(resultValue)) {\n    return resultValue.map((element) => toTypedValueWithType(element, resultType));\n  } else {\n    return toTypedValueWithType(resultValue, resultType);\n  }\n}\n\nfunction toTypedValueWithType(value: any, type: string): TypedValue {\n  if (type === 'Resource' && isResource(value)) {\n    type = value.resourceType;\n  }\n  return { type, value };\n}\n\n/**\n * Returns the value of the property and the property type using a type schema.\n * Note that because the type schema is not available, this function may be inaccurate.\n * In some cases, that is the desired behavior.\n * @param typedValue - The base context (FHIR resource or backbone element).\n * @param path - The property path.\n * @returns The value of the property and the property type.\n */\nexport function getTypedPropertyValueWithoutSchema(\n  typedValue: TypedValue,\n  path: string\n): TypedValue[] | TypedValue | undefined {\n  const input = typedValue.value;\n  if (!input || typeof input !== 'object') {\n    return undefined;\n  }\n\n  let result: TypedValue[] | TypedValue | undefined = undefined;\n\n  if (path in input) {\n    const propertyValue = (input as { [key: string]: unknown })[path];\n    if (Array.isArray(propertyValue)) {\n      result = propertyValue.map(toTypedValue);\n    } else {\n      result = toTypedValue(propertyValue);\n    }\n  } else {\n    // Only support property names that would be valid types\n    // Examples:\n    // value + valueString = ok, because \"string\" is valid\n    // value + valueDecimal = ok, because \"decimal\" is valid\n    // id + identifier = not ok, because \"entifier\" is not a valid type\n    // resource + resourceType = not ok, because \"type\" is not a valid type\n    const trimmedPath = path.endsWith('[x]') ? path.substring(0, path.length - 3) : path;\n    for (const propertyType of Object.values(PropertyType)) {\n      const propertyName = trimmedPath + capitalize(propertyType);\n      if (propertyName in input) {\n        const propertyValue = (input as { [key: string]: unknown })[propertyName];\n        if (Array.isArray(propertyValue)) {\n          result = propertyValue.map((v) => ({ type: propertyType, value: v }));\n        } else {\n          result = { type: propertyType, value: propertyValue };\n        }\n        break;\n      }\n    }\n  }\n\n  if (Array.isArray(result)) {\n    if (result.length === 0 || isEmpty(result[0])) {\n      return undefined;\n    }\n  } else if (isEmpty(result)) {\n    return undefined;\n  }\n\n  return result;\n}\n\n/**\n * Removes duplicates in array using FHIRPath equality rules.\n * @param arr - The input array.\n * @returns The result array with duplicates removed.\n */\nexport function removeDuplicates(arr: TypedValue[]): TypedValue[] {\n  const result: TypedValue[] = [];\n  for (const i of arr) {\n    let found = false;\n    for (const j of result) {\n      if (toJsBoolean(fhirPathEquals(i, j))) {\n        found = true;\n        break;\n      }\n    }\n    if (!found) {\n      result.push(i);\n    }\n  }\n  return result;\n}\n\n/**\n * Returns a negated FHIRPath boolean expression.\n * @param input - The input array.\n * @returns The negated type value array.\n */\nexport function fhirPathNot(input: TypedValue[]): TypedValue[] {\n  return booleanToTypedValue(!toJsBoolean(input));\n}\n\n/**\n * Determines if two arrays are equal according to FHIRPath equality rules.\n * @param x - The first array.\n * @param y - The second array.\n * @returns FHIRPath true if the arrays are equal.\n */\nexport function fhirPathArrayEquals(x: TypedValue[], y: TypedValue[]): TypedValue[] {\n  if (x.length === 0 || y.length === 0) {\n    return [];\n  }\n  if (x.length !== y.length) {\n    return booleanToTypedValue(false);\n  }\n  return booleanToTypedValue(x.every((val, index) => toJsBoolean(fhirPathEquals(val, y[index]))));\n}\n\n/**\n * Determines if two arrays are not equal according to FHIRPath equality rules.\n * @param x - The first array.\n * @param y - The second array.\n * @returns FHIRPath true if the arrays are not equal.\n */\nexport function fhirPathArrayNotEquals(x: TypedValue[], y: TypedValue[]): TypedValue[] {\n  if (x.length === 0 || y.length === 0) {\n    return [];\n  }\n  if (x.length !== y.length) {\n    return booleanToTypedValue(true);\n  }\n  return booleanToTypedValue(x.some((val, index) => !toJsBoolean(fhirPathEquals(val, y[index]))));\n}\n\n/**\n * Determines if two values are equal according to FHIRPath equality rules.\n * @param x - The first value.\n * @param y - The second value.\n * @returns True if equal.\n */\nexport function fhirPathEquals(x: TypedValue, y: TypedValue): TypedValue[] {\n  const xValue = x.value?.valueOf();\n  const yValue = y.value?.valueOf();\n  if (typeof xValue === 'number' && typeof yValue === 'number') {\n    return booleanToTypedValue(Math.abs(xValue - yValue) < 1e-8);\n  }\n  if (isQuantity(xValue) && isQuantity(yValue)) {\n    return booleanToTypedValue(isQuantityEquivalent(xValue, yValue));\n  }\n  if (typeof xValue === 'object' && typeof yValue === 'object') {\n    return booleanToTypedValue(deepEquals(x, y));\n  }\n  return booleanToTypedValue(xValue === yValue);\n}\n\n/**\n * Determines if two arrays are equivalent according to FHIRPath equality rules.\n * @param x - The first array.\n * @param y - The second array.\n * @returns FHIRPath true if the arrays are equivalent.\n */\nexport function fhirPathArrayEquivalent(x: TypedValue[], y: TypedValue[]): TypedValue[] {\n  if (x.length === 0 && y.length === 0) {\n    return booleanToTypedValue(true);\n  }\n  if (x.length !== y.length) {\n    return booleanToTypedValue(false);\n  }\n  x.sort(fhirPathEquivalentCompare);\n  y.sort(fhirPathEquivalentCompare);\n  return booleanToTypedValue(x.every((val, index) => toJsBoolean(fhirPathEquivalent(val, y[index]))));\n}\n\n/**\n * Determines if two values are equivalent according to FHIRPath equality rules.\n * @param x - The first value.\n * @param y - The second value.\n * @returns True if equivalent.\n */\nexport function fhirPathEquivalent(x: TypedValue, y: TypedValue): TypedValue[] {\n  const { type: xType, value: xValueRaw } = x;\n  const { type: yType, value: yValueRaw } = y;\n  const xValue = xValueRaw?.valueOf();\n  const yValue = yValueRaw?.valueOf();\n\n  if (typeof xValue === 'number' && typeof yValue === 'number') {\n    // Use more generous threshold than equality\n    // Decimal: values must be equal, comparison is done on values rounded to the precision of the least precise operand.\n    // Trailing zeroes after the decimal are ignored in determining precision.\n    return booleanToTypedValue(Math.abs(xValue - yValue) < 0.01);\n  }\n  if (isQuantity(xValue) && isQuantity(yValue)) {\n    return booleanToTypedValue(isQuantityEquivalent(xValue, yValue));\n  }\n\n  if (xType === 'Coding' && yType === 'Coding') {\n    if (typeof xValue !== 'object' || typeof yValue !== 'object') {\n      return booleanToTypedValue(false);\n    }\n    // \"In addition, for Coding values, equivalence is defined based on the code and system elements only.\n    // The version, display, and userSelected elements are ignored for the purposes of determining Coding equivalence.\"\n    // Source: https://hl7.org/fhir/fhirpath.html#changes\n\n    // We need to check if both `code` and `system` are equivalent.\n    // If both have undefined `system` fields, If so, then the two's `system` values must be compared.\n    // Essentially they must both be `undefined` or both the same.\n    return booleanToTypedValue(\n      (xValue as Coding).code === (yValue as Coding).code && (xValue as Coding).system === (yValue as Coding).system\n    );\n  }\n\n  if (typeof xValue === 'object' && typeof yValue === 'object') {\n    return booleanToTypedValue(deepEquals({ ...xValue, id: undefined }, { ...yValue, id: undefined }));\n  }\n  if (typeof xValue === 'string' && typeof yValue === 'string') {\n    // String: the strings must be the same, ignoring case and locale, and normalizing whitespace\n    // (see String Equivalence for more details).\n    return booleanToTypedValue(xValue.toLowerCase() === yValue.toLowerCase());\n  }\n  return booleanToTypedValue(xValue === yValue);\n}\n\n/**\n * Returns the sort order of two values for FHIRPath array equivalence.\n * @param x - The first value.\n * @param y - The second value.\n * @returns The sort order of the values.\n */\nfunction fhirPathEquivalentCompare(x: TypedValue, y: TypedValue): number {\n  const xValue = x.value?.valueOf();\n  const yValue = y.value?.valueOf();\n  if (typeof xValue === 'number' && typeof yValue === 'number') {\n    return xValue - yValue;\n  }\n  if (typeof xValue === 'string' && typeof yValue === 'string') {\n    return xValue.localeCompare(yValue);\n  }\n  return 0;\n}\n\n/**\n * Determines if the typed value is the desired type.\n * @param typedValue - The typed value to check.\n * @param desiredType - The desired type name.\n * @returns True if the typed value is of the desired type.\n */\nexport function fhirPathIs(typedValue: TypedValue, desiredType: string): boolean {\n  const { value } = typedValue;\n  if (value === undefined || value === null) {\n    return false;\n  }\n\n  let cleanType = desiredType;\n\n  if (cleanType.startsWith('System.')) {\n    cleanType = cleanType.substring('System.'.length);\n  }\n\n  if (cleanType.startsWith('FHIR.')) {\n    cleanType = cleanType.substring('FHIR.'.length);\n  }\n\n  switch (cleanType) {\n    case 'Boolean':\n      return typeof value === 'boolean';\n    case 'Decimal':\n    case 'Integer':\n      return typeof value === 'number';\n    case 'Date':\n      return isDateString(value);\n    case 'DateTime':\n      return isDateTimeString(value);\n    case 'Time':\n      return typeof value === 'string' && !!/^T\\d/.exec(value);\n    case 'Period':\n      return isPeriod(value);\n    case 'Quantity':\n      return isQuantity(value);\n    default:\n      return typedValue.type === cleanType || (typeof value === 'object' && value?.resourceType === cleanType);\n  }\n}\n\n/**\n * Returns true if the input value is a YYYY-MM-DD date string.\n * @param input - Unknown input value.\n * @returns True if the input is a date string.\n */\nexport function isDateString(input: unknown): input is string {\n  return typeof input === 'string' && !!validationRegexes.date.exec(input);\n}\n\n/**\n * Returns true if the input value is a YYYY-MM-DDThh:mm:ss.sssZ date/time string.\n * @param input - Unknown input value.\n * @returns True if the input is a date/time string.\n */\nexport function isDateTimeString(input: unknown): input is string {\n  return typeof input === 'string' && !!validationRegexes.dateTime.exec(input);\n}\n\n/**\n * Determines if the input is a Period object.\n * This is heuristic based, as we do not have strong typing at runtime.\n * @param input - The input value.\n * @returns True if the input is a period.\n */\nexport function isPeriod(input: unknown): input is Period {\n  return !!(\n    input &&\n    typeof input === 'object' &&\n    (('start' in input && isDateTimeString(input.start)) || ('end' in input && isDateTimeString(input.end)))\n  );\n}\n\n/**\n * Tries to convert an unknown input value to a Period object.\n * @param input - Unknown input value.\n * @returns A Period object or undefined.\n */\nexport function toPeriod(input: unknown): Period | undefined {\n  if (!input) {\n    return undefined;\n  }\n\n  if (isDateString(input)) {\n    return {\n      start: dateStringToInstantString(input, '0000-00-00T00:00:00.000Z'),\n      end: dateStringToInstantString(input, 'xxxx-12-31T23:59:59.999Z'),\n    };\n  }\n\n  if (isDateTimeString(input)) {\n    return { start: input, end: input };\n  }\n\n  if (isPeriod(input)) {\n    return input;\n  }\n\n  return undefined;\n}\n\nfunction dateStringToInstantString(input: string, fill: string): string {\n  // Input can be any subset of YYYY-MM-DDThh:mm:ss.sssZ\n  return input + fill.substring(input.length);\n}\n\n/**\n * Determines if the input is a Quantity object.\n * This is heuristic based, as we do not have strong typing at runtime.\n * @param input - The input value.\n * @returns True if the input is a quantity.\n */\nexport function isQuantity(input: unknown): input is Quantity {\n  return !!(input && typeof input === 'object' && 'value' in input && typeof (input as Quantity).value === 'number');\n}\n\nexport function isQuantityEquivalent(x: Quantity, y: Quantity): boolean {\n  return (\n    Math.abs((x.value as number) - (y.value as number)) < 0.01 &&\n    (x.unit === y.unit || x.code === y.code || x.unit === y.code || x.code === y.unit)\n  );\n}\n\n/**\n * Resource equality.\n * See: https://dmitripavlutin.com/how-to-compare-objects-in-javascript/#4-deep-equality\n * @param object1 - The first object.\n * @param object2 - The second object.\n * @returns True if the objects are equal.\n */\nfunction deepEquals<T1 extends object, T2 extends object>(object1: T1, object2: T2): boolean {\n  const keys1 = Object.keys(object1) as (keyof T1)[];\n  const keys2 = Object.keys(object2) as (keyof T2)[];\n  if (keys1.length !== keys2.length) {\n    return false;\n  }\n  for (const key of keys1) {\n    const val1 = object1[key] as unknown;\n    const val2 = object2[key as unknown as keyof T2] as unknown;\n    if (isObject(val1) && isObject(val2)) {\n      if (!deepEquals(val1, val2)) {\n        return false;\n      }\n    } else if (val1 !== val2) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction isObject(obj: unknown): obj is object {\n  return obj !== null && typeof obj === 'object';\n}\n\nfunction assignPrimitiveExtension(target: any, primitiveExtension: any): any {\n  if (primitiveExtension) {\n    if (typeof primitiveExtension !== 'object') {\n      throw new Error('Primitive extension must be an object');\n    }\n    return safeAssign(target ?? {}, primitiveExtension);\n  }\n  return target;\n}\n\n/**\n * For primitive string, number, boolean, the return value will be the corresponding\n * `String`, `Number`, or `Boolean` version of the type.\n * @param target - The value to have `source` properties assigned to.\n * @param source - An object to be assigned to `target`.\n * @returns The `target` value with the properties of `source` assigned to it.\n */\nfunction safeAssign(target: any, source: any): any {\n  delete source.__proto__; //eslint-disable-line no-proto\n  delete source.constructor;\n  return Object.assign(target, source);\n}\n", "import {\n  Attachment,\n  Bundle,\n  CodeableConcept,\n  Coding,\n  Device,\n  Extension,\n  ExtensionValue,\n  Identifier,\n  ObservationDefinition,\n  ObservationDefinitionQualifiedInterval,\n  Patient,\n  Practitioner,\n  QuestionnaireResponse,\n  QuestionnaireResponseItem,\n  QuestionnaireResponseItemAnswer,\n  Range,\n  Reference,\n  RelatedPerson,\n  Resource,\n} from '@medplum/fhirtypes';\nimport { getTypedPropertyValue } from './fhirpath/utils';\nimport { formatCodeableConcept, formatHumanName } from './format';\nimport { OperationOutcomeError, validationError } from './outcomes';\nimport { isReference, isResource } from './types';\n\n/**\n * QueryTypes defines the different ways to specify FHIR search parameters.\n *\n * Can be any valid input to the URLSearchParams() constructor.\n *\n * TypeScript definitions for URLSearchParams do not match runtime behavior.\n * The official spec only accepts string values.\n * Web browsers and Node.js automatically coerce values to strings.\n * See: https://github.com/microsoft/TypeScript/issues/32951\n */\nexport type QueryTypes =\n  | URLSearchParams\n  | string[][]\n  | Record<string, string | number | boolean | undefined>\n  | string\n  | undefined;\n\nexport type ProfileResource = Patient | Practitioner | RelatedPerson;\n\n/**\n * Allowed values for `code_challenge_method` in a PKCE exchange.\n */\nexport type CodeChallengeMethod = 'plain' | 'S256';\n\nexport interface Code {\n  code?: CodeableConcept;\n}\n\nexport type ResourceWithCode = Resource & Code;\n\nexport type WithId<T> = T & { id: string };\n\nexport function isResourceWithId<T extends Resource>(\n  resource: unknown,\n  resourceType?: T['resourceType']\n): resource is WithId<T> {\n  return isResource(resource, resourceType) && 'id' in resource && typeof resource.id === 'string';\n}\n\n/**\n * Creates a reference resource.\n * @param resource - The FHIR resource.\n * @returns A reference resource.\n */\nexport function createReference<T extends Resource>(resource: T): Reference<T> & { reference: string } {\n  const reference = getReferenceString(resource) ?? 'undefined/undefined';\n  const display = getDisplayString(resource);\n  return display === reference ? { reference } : { reference, display };\n}\n\n/**\n * Returns a reference string for a resource.\n * @param input - The FHIR resource or reference.\n * @returns A reference string of the form resourceType/id.\n */\nexport function getReferenceString(input: (Reference & { reference: string }) | WithId<Resource>): string;\nexport function getReferenceString(input: Reference | Resource): string | undefined;\nexport function getReferenceString(\n  input: Reference | Resource | (Reference & { reference: string }) | WithId<Resource>\n): string | undefined {\n  if (isReference(input)) {\n    return input.reference;\n  }\n  if (isResourceWithId(input)) {\n    return `${(input as Resource).resourceType}/${input.id}`;\n  }\n  return undefined;\n}\n\n/**\n * Returns the ID portion of a reference.\n * @param input - A FHIR reference or resource.\n * @returns The ID portion of a reference.\n */\nexport function resolveId(input: Reference | Resource | undefined): string | undefined {\n  if (!input) {\n    return undefined;\n  }\n  if (isReference(input)) {\n    return input.reference.split('/')[1];\n  }\n  return input.id;\n}\n\n/**\n * Parses a reference and returns a tuple of [ResourceType, ID].\n * @param reference - A reference to a FHIR resource.\n * @returns A tuple containing the `ResourceType` and the ID of the resource or `undefined` when `undefined` or an invalid reference is passed.\n */\nexport function parseReference<T extends Resource>(reference: Reference<T> | undefined): [T['resourceType'], string] {\n  if (reference?.reference === undefined) {\n    throw new OperationOutcomeError(validationError('Reference missing reference property.'));\n  }\n  const [type, id] = reference.reference.split('/') as [T['resourceType'] | '', string];\n  if (type === '' || id === '' || id === undefined) {\n    throw new OperationOutcomeError(validationError('Unable to parse reference string.'));\n  }\n  return [type, id];\n}\n\n/**\n * Returns true if the resource is a \"ProfileResource\".\n * @param resource - The FHIR resource.\n * @returns True if the resource is a \"ProfileResource\".\n */\nexport function isProfileResource(resource: Resource): resource is ProfileResource {\n  return (\n    resource.resourceType === 'Patient' ||\n    resource.resourceType === 'Practitioner' ||\n    resource.resourceType === 'RelatedPerson'\n  );\n}\n\n/**\n * Returns a display string for the resource.\n * @param resource - The input resource.\n * @returns Human friendly display string.\n */\nexport function getDisplayString(resource: Resource): string {\n  if (isProfileResource(resource)) {\n    const profileName = getProfileResourceDisplayString(resource);\n    if (profileName) {\n      return profileName;\n    }\n  }\n  if (resource.resourceType === 'Device') {\n    const deviceName = getDeviceDisplayString(resource);\n    if (deviceName) {\n      return deviceName;\n    }\n  }\n  if (resource.resourceType === 'MedicationRequest' && resource.medicationCodeableConcept) {\n    return formatCodeableConcept(resource.medicationCodeableConcept);\n  }\n  if (resource.resourceType === 'Subscription' && resource.criteria) {\n    return resource.criteria;\n  }\n  if (resource.resourceType === 'User' && resource.email) {\n    return resource.email;\n  }\n  if ('name' in resource && resource.name && typeof resource.name === 'string') {\n    return resource.name;\n  }\n  if ('code' in resource && resource.code) {\n    let code = resource.code;\n    if (Array.isArray(code)) {\n      code = code[0];\n    }\n    if (isCodeableConcept(code)) {\n      return formatCodeableConcept(code);\n    }\n    if (isTextObject(code)) {\n      return code.text;\n    }\n  }\n  return getReferenceString(resource) ?? '';\n}\n\n/**\n * Returns a display string for a profile resource if one is found.\n * @param resource - The profile resource.\n * @returns The display name if one is found.\n */\nfunction getProfileResourceDisplayString(resource: ProfileResource): string | undefined {\n  const names = resource.name;\n  if (names && names.length > 0) {\n    return formatHumanName(names[0]);\n  }\n  return undefined;\n}\n\n/**\n * Returns a display string for a device resource if one is found.\n * @param device - The device resource.\n * @returns The display name if one is found.\n */\nfunction getDeviceDisplayString(device: Device): string | undefined {\n  const names = device.deviceName;\n  if (names && names.length > 0) {\n    return names[0].name;\n  }\n  return undefined;\n}\n\n/**\n * Returns an image URL for the resource, if one is available.\n * @param resource - The input resource.\n * @returns The image URL for the resource or undefined.\n */\nexport function getImageSrc(resource: Resource): string | undefined {\n  if (!('photo' in resource)) {\n    return undefined;\n  }\n\n  const photo = resource.photo;\n  if (!photo) {\n    return undefined;\n  }\n\n  if (Array.isArray(photo)) {\n    for (const p of photo) {\n      const url = getPhotoImageSrc(p);\n      if (url) {\n        return url;\n      }\n    }\n  } else {\n    return getPhotoImageSrc(photo);\n  }\n\n  return undefined;\n}\n\nfunction getPhotoImageSrc(photo: Attachment): string | undefined {\n  if (photo.url && photo.contentType?.startsWith('image/')) {\n    return photo.url;\n  }\n  return undefined;\n}\n\n/**\n * Returns a Date property as a Date.\n * When working with JSON objects, Dates are often serialized as ISO-8601 strings.\n * When that happens, we need to safely convert to a proper Date object.\n * @param date - The date property value, which could be a string or a Date object.\n * @returns A Date object.\n */\nexport function getDateProperty(date: string | undefined): Date | undefined {\n  return date ? new Date(date) : undefined;\n}\n\n/**\n * Calculates the age in years from the birth date.\n * @param birthDateStr - The birth date or start date in ISO-8601 format YYYY-MM-DD.\n * @param endDateStr - Optional end date in ISO-8601 format YYYY-MM-DD. Default value is today.\n * @returns The age in years, months, and days.\n */\nexport function calculateAge(\n  birthDateStr: string,\n  endDateStr?: string\n): { years: number; months: number; days: number } {\n  const startDate = new Date(birthDateStr);\n  startDate.setUTCHours(0, 0, 0, 0);\n\n  const endDate = endDateStr ? new Date(endDateStr) : new Date();\n  endDate.setUTCHours(0, 0, 0, 0);\n\n  const startYear = startDate.getUTCFullYear();\n  const startMonth = startDate.getUTCMonth();\n  const startDay = startDate.getUTCDate();\n\n  const endYear = endDate.getUTCFullYear();\n  const endMonth = endDate.getUTCMonth();\n  const endDay = endDate.getUTCDate();\n\n  let years = endYear - startYear;\n  if (endMonth < startMonth || (endMonth === startMonth && endDay < startDay)) {\n    years--;\n  }\n\n  let months = endYear * 12 + endMonth - (startYear * 12 + startMonth);\n  if (endDay < startDay) {\n    months--;\n  }\n\n  const days = Math.floor((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24));\n\n  return { years, months, days };\n}\n\n/**\n * Calculates the age string for display using the age appropriate units.\n * If the age is greater than or equal to 2 years, then the age is displayed in years.\n * If the age is greater than or equal to 1 month, then the age is displayed in months.\n * Otherwise, the age is displayed in days.\n * @param birthDateStr - The birth date or start date in ISO-8601 format YYYY-MM-DD.\n * @param endDateStr - Optional end date in ISO-8601 format YYYY-MM-DD. Default value is today.\n * @returns The age string.\n */\nexport function calculateAgeString(birthDateStr: string, endDateStr?: string): string | undefined {\n  const { years, months, days } = calculateAge(birthDateStr, endDateStr);\n  if (years >= 2) {\n    return years.toString().padStart(3, '0') + 'Y';\n  } else if (months >= 1) {\n    return months.toString().padStart(3, '0') + 'M';\n  } else {\n    return days.toString().padStart(3, '0') + 'D';\n  }\n}\n\n/**\n * Returns all questionnaire answers as a map by link ID.\n * @param response - The questionnaire response resource.\n * @returns Questionnaire answers mapped by link ID.\n */\nexport function getQuestionnaireAnswers(\n  response: QuestionnaireResponse\n): Record<string, QuestionnaireResponseItemAnswer> {\n  const result: Record<string, QuestionnaireResponseItemAnswer> = {};\n  buildQuestionnaireAnswerItems(response.item, result);\n  return result;\n}\n\nfunction buildQuestionnaireAnswerItems(\n  items: QuestionnaireResponseItem[] | undefined,\n  result: Record<string, QuestionnaireResponseItemAnswer>\n): void {\n  if (items) {\n    for (const item of items) {\n      if (item.linkId && item.answer && item.answer.length > 0) {\n        result[item.linkId] = item.answer[0];\n      }\n      buildQuestionnaireAnswerItems(item.item, result);\n    }\n  }\n}\n\n/**\n * Returns an array of  questionnaire answers as a map by link ID.\n * @param response - The questionnaire response resource.\n * @returns Questionnaire answer arrays mapped by link ID.\n */\nexport function getAllQuestionnaireAnswers(\n  response: QuestionnaireResponse\n): Record<string, QuestionnaireResponseItemAnswer[]> {\n  const result: Record<string, QuestionnaireResponseItemAnswer[]> = {};\n  buildAllQuestionnaireAnswerItems(response.item, result);\n  return result;\n}\n\n/**\n * Recursively builds the questionnaire answer items map.\n * @param items - The current questionnaire response items.\n * @param result - The cumulative result map of answers.\n */\nfunction buildAllQuestionnaireAnswerItems(\n  items: QuestionnaireResponseItem[] | undefined,\n  result: Record<string, QuestionnaireResponseItemAnswer[]>\n): void {\n  if (items) {\n    for (const item of items) {\n      if (item.linkId && item.answer && item.answer.length > 0) {\n        if (result[item.linkId]) {\n          result[item.linkId] = [...result[item.linkId], ...item.answer];\n        } else {\n          result[item.linkId] = item.answer;\n        }\n      }\n      buildAllQuestionnaireAnswerItems(item.item, result);\n    }\n  }\n}\n\n/**\n * Returns the resource identifier for the given system.\n *\n * If multiple identifiers exist with the same system, the first one is returned.\n *\n * If the system is not found, then returns undefined.\n * @param resource - The resource to check.\n * @param system - The identifier system.\n * @returns The identifier value if found; otherwise undefined.\n */\nexport function getIdentifier(resource: Resource, system: string): string | undefined {\n  const identifiers = (resource as any).identifier;\n  if (!identifiers) {\n    return undefined;\n  }\n  const array = Array.isArray(identifiers) ? identifiers : [identifiers];\n  for (const identifier of array) {\n    if (identifier.system === system) {\n      return identifier.value;\n    }\n  }\n  return undefined;\n}\n\n/**\n * Sets a resource identifier for the given system.\n *\n * Note that this method is only available on resources that have an \"identifier\" property,\n * and that property must be an array of Identifier objects,\n * which is not true for all FHIR resources.\n *\n * If the identifier already exists, then the value is updated.\n *\n * Otherwise a new identifier is added.\n *\n * @param resource - The resource to add the identifier to.\n * @param system - The identifier system.\n * @param value - The identifier value.\n */\nexport function setIdentifier(resource: Resource & { identifier?: Identifier[] }, system: string, value: string): void {\n  const identifiers = resource.identifier;\n  if (!identifiers) {\n    resource.identifier = [{ system, value }];\n    return;\n  }\n  for (const identifier of identifiers) {\n    if (identifier.system === system) {\n      identifier.value = value;\n      return;\n    }\n  }\n  identifiers.push({ system, value });\n}\n\n/**\n * Returns an extension value by extension URLs.\n * @param resource - The base resource.\n * @param urls - Array of extension URLs.  Each entry represents a nested extension.\n * @returns The extension value if found; undefined otherwise.\n */\nexport function getExtensionValue(resource: any, ...urls: string[]): ExtensionValue | undefined {\n  const extension = getExtension(resource, ...urls);\n  if (!extension) {\n    return undefined;\n  }\n\n  const typedValue = getTypedPropertyValue({ type: 'Extension', value: extension }, 'value[x]');\n  if (!typedValue) {\n    return undefined;\n  }\n\n  return Array.isArray(typedValue) ? typedValue[0].value : typedValue.value;\n}\n\n/**\n * Returns an extension by extension URLs.\n * @param resource - The base resource.\n * @param urls - Array of extension URLs. Each entry represents a nested extension.\n * @returns The extension object if found; undefined otherwise.\n */\nexport function getExtension(resource: any, ...urls: string[]): Extension | undefined {\n  // Let curr be the current resource or extension. Extensions can be nested.\n  let curr: any = resource;\n\n  // For each of the urls, try to find a matching nested extension.\n  for (let i = 0; i < urls.length && curr; i++) {\n    curr = (curr?.extension as Extension[] | undefined)?.find((e) => e.url === urls[i]);\n  }\n\n  return curr;\n}\n\n/**\n * Returns the FHIR JSON string representation of the input value.\n *\n * Removes properties with empty string values.\n * Removes objects with zero properties.\n *\n * Does not modify the input value.\n * If the input value does not contain any empty properties, then the original value is returned.\n * Otherwise, a new value is returned with the empty properties removed.\n *\n * See: https://www.hl7.org/fhir/json.html\n *\n * @param value - The input value.\n * @param pretty - Optional flag to pretty-print the JSON.\n * @returns The resulting JSON string.\n */\nexport function stringify(value: any, pretty?: boolean): string {\n  const processedValue = removeEmptyFromUnknown(value);\n  return JSON.stringify(processedValue, null, pretty ? 2 : undefined) ?? '';\n}\n\n/**\n * Removes empty properties from an unknown value.\n *\n * Does not modify the input value.\n *\n * If the input value does not contain any empty properties, then the original value is returned.\n *\n * Otherwise, a new value is returned with the empty properties removed.\n *\n * @param value - The unknown input value.\n * @returns The value with empty properties removed.\n */\nfunction removeEmptyFromUnknown(value: unknown): any {\n  if (value === undefined || value === null || value === '') {\n    // For null, undefined, and empty strings, return undefined\n    return undefined;\n  }\n\n  if (typeof value === 'object') {\n    if (Array.isArray(value)) {\n      return removeEmptyFromArray(value);\n    }\n    return removeEmptyFromObject(value);\n  }\n\n  // Otherwise, return the primitive value\n  return value;\n}\n\n/**\n * Removes empty elements from an array.\n *\n * If the input array is empty, then undefined is returned.\n * Otherwise, a new array is returned with the empty values replaced with null.\n *\n * FHIR arrays must maintain the same length, so null is used to replace empty values.\n *\n * @param inputArray - The input array value.\n * @returns The array with empty values removed.\n */\nfunction removeEmptyFromArray(inputArray: unknown[]): any[] | undefined {\n  const len = inputArray.length;\n  if (len === 0) {\n    return undefined;\n  }\n  let newArray = undefined; // Only create a new array if needed\n  let count = 0;\n  for (let i = 0; i < len; i++) {\n    const inputElement = inputArray[i];\n    const processedElement = removeEmptyFromUnknown(inputElement);\n\n    if (processedElement !== inputElement && !newArray) {\n      newArray = Array.from(inputArray); // Clone only when a change is needed\n    }\n\n    if (processedElement === undefined) {\n      if (newArray) {\n        newArray[i] = null;\n      }\n    } else {\n      if (newArray) {\n        newArray[i] = processedElement; // Propagate changed element\n      }\n      count++;\n    }\n  }\n  if (count === 0) {\n    return undefined;\n  }\n  return newArray ?? inputArray;\n}\n\n/**\n * Removes empty properties from an object.\n *\n * If the input object is empty, then undefined is returned.\n *\n * @param inputObject - The input object value.\n * @returns The object with empty properties removed.\n */\nfunction removeEmptyFromObject(inputObject: Record<string, any>): Record<string, any> | undefined {\n  let newObject = undefined;\n  let count = 0;\n\n  // Use 'in' for faster key iteration\n  // Using `Object.keys()` and `Object.entries()` is 2x+ slower\n  // Using `Object.hasOwn` guard is about 50% slower\n  // We can safely skip the hasOwn check, because this value will be passed to JSON.stringify,\n  // which has its own property checking.\n  // eslint-disable-next-line guard-for-in\n  for (const key in inputObject) {\n    const inputValue = inputObject[key];\n    const processedValue = removeEmptyFromUnknown(inputValue);\n\n    // If the processed value is different than the input value, then we need to clone the object\n    if (processedValue !== inputValue && !newObject) {\n      newObject = { ...inputObject }; // Shallow clone only when a change is needed\n    }\n\n    if (processedValue === undefined) {\n      if (newObject) {\n        delete newObject[key];\n      }\n    } else {\n      if (newObject) {\n        newObject[key] = processedValue;\n      }\n      count++;\n    }\n  }\n\n  if (count === 0) {\n    return undefined;\n  }\n\n  return newObject ?? inputObject;\n}\n\n/**\n * Returns true if the value is empty (null, undefined, empty string, or empty object).\n * @param v - Any value.\n * @returns True if the value is an empty string or an empty object.\n */\nexport function isEmpty(v: unknown): boolean {\n  if (v === null || v === undefined) {\n    return true;\n  }\n\n  const t = typeof v;\n  if (t === 'string' || t === 'object') {\n    return !isPopulated(v);\n  }\n\n  return false;\n}\n\nexport type CanBePopulated = { length: number } | object;\n/**\n * Returns true if the value is a non-empty string, an object with a length property greater than zero, or a non-empty object\n * @param arg - Any value\n * @returns True if the value is a non-empty string, an object with a length property greater than zero, or a non-empty object\n */\nexport function isPopulated<T extends { length: number } | object>(arg: CanBePopulated | undefined | null): arg is T {\n  if (arg === null || arg === undefined) {\n    return false;\n  }\n  const t = typeof arg;\n\n  return (\n    (t === 'string' && arg !== '') ||\n    (t === 'object' && (('length' in arg && arg.length > 0) || Object.keys(arg).length > 0))\n  );\n}\n\n/**\n * Resource equality.\n * Ignores meta.versionId and meta.lastUpdated.\n * @param object1 - The first object.\n * @param object2 - The second object.\n * @param path - Optional path string.\n * @returns True if the objects are equal.\n */\nexport function deepEquals(object1: unknown, object2: unknown, path?: string): boolean {\n  if (object1 === object2) {\n    return true;\n  }\n  if (isEmpty(object1) && isEmpty(object2)) {\n    return true;\n  }\n  if (isEmpty(object1) || isEmpty(object2)) {\n    return false;\n  }\n  if (Array.isArray(object1) && Array.isArray(object2)) {\n    return deepEqualsArray(object1, object2);\n  }\n  if (Array.isArray(object1) || Array.isArray(object2)) {\n    return false;\n  }\n  if (isObject(object1) && isObject(object2)) {\n    return deepEqualsObject(object1, object2, path);\n  }\n  if (isObject(object1) || isObject(object2)) {\n    return false;\n  }\n  return false;\n}\n\nfunction deepEqualsArray(array1: unknown[], array2: unknown[]): boolean {\n  if (array1.length !== array2.length) {\n    return false;\n  }\n  for (let i = 0; i < array1.length; i++) {\n    if (!deepEquals(array1[i], array2[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction deepEqualsObject(\n  object1: Record<string, unknown>,\n  object2: Record<string, unknown>,\n  path: string | undefined\n): boolean {\n  const keySet = new Set<string>();\n  Object.keys(object1).forEach((k) => keySet.add(k));\n  Object.keys(object2).forEach((k) => keySet.add(k));\n  if (path === 'meta') {\n    keySet.delete('versionId');\n    keySet.delete('lastUpdated');\n    keySet.delete('author');\n  }\n  for (const key of keySet) {\n    const val1 = object1[key];\n    const val2 = object2[key];\n    if (!deepEquals(val1, val2, key)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Checks if value includes all fields and values of pattern.\n * It doesn't matter if value has extra fields, values, etc.\n * @param value - The object being tested against pattern.\n * @param pattern - The object pattern/shape checked to exist within value.\n * @returns True if value includes all fields and values of pattern.\n */\nexport function deepIncludes(value: any, pattern: any): boolean {\n  if (isEmpty(value)) {\n    return true;\n  }\n  if (isEmpty(pattern)) {\n    return false;\n  }\n  if (Array.isArray(value) && Array.isArray(pattern)) {\n    return deepIncludesArray(value, pattern);\n  }\n  if (Array.isArray(value) || Array.isArray(pattern)) {\n    return false;\n  }\n  if (isObject(value) && isObject(pattern)) {\n    return deepIncludesObject(value, pattern);\n  } else if (isObject(value) || isObject(pattern)) {\n    return false;\n  }\n  return value === pattern;\n}\n\nfunction deepIncludesArray(value: any[], pattern: any[]): boolean {\n  return pattern.every((patternVal) => value.some((valueVal) => deepIncludes(valueVal, patternVal)));\n}\n\nfunction deepIncludesObject(value: { [key: string]: unknown }, pattern: { [key: string]: unknown }): boolean {\n  return Object.entries(pattern).every(\n    ([patternKey, patternVal]) => patternKey in value && deepIncludes(value[patternKey], patternVal)\n  );\n}\n\n/**\n * Creates a deep clone of the input value.\n *\n * Limitations:\n *  - Only supports JSON primitives and arrays.\n *  - Does not support Functions, lambdas, etc.\n *  - Does not support circular references.\n *\n * See: https://web.dev/structured-clone/\n * See: https://stackoverflow.com/questions/40488190/how-is-structured-clone-algorithm-different-from-deep-copy\n * @param input - The input to clone.\n * @returns A deep clone of the input.\n */\nexport function deepClone<T>(input: T): T {\n  return input === undefined ? input : (JSON.parse(JSON.stringify(input)) as T);\n}\n\n/**\n * Returns true if the input string is a UUID.\n * @param input - The input string.\n * @returns True if the input string matches the UUID format.\n */\nexport function isUUID(input: string): input is string {\n  return /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i.test(input);\n}\n\n/**\n * Returns true if the input is an object.\n * @param obj - The candidate object.\n * @returns True if the input is a non-null non-undefined object.\n */\nexport function isObject(obj: unknown): obj is Record<string, unknown> {\n  return obj !== null && typeof obj === 'object';\n}\n\n/**\n * Returns true if the input array is an array of strings.\n * @param arr - Input array.\n * @returns True if the input array is an array of strings.\n */\nexport function isStringArray(arr: any[]): arr is string[] {\n  return arr.every(isString);\n}\n\n/**\n * Returns true if the input value is a string.\n * @param value - The candidate value.\n * @returns True if the input value is a string.\n */\nexport function isString(value: unknown): value is string {\n  return typeof value === 'string';\n}\n\n/**\n * Returns true if the input value is a Coding object.\n * This is a heuristic check based on the presence of the \"code\" property.\n * @param value - The candidate value.\n * @returns True if the input value is a Coding.\n */\nexport function isCoding(value: unknown): value is Coding & { code: string } {\n  return isObject(value) && 'code' in value && typeof value.code === 'string';\n}\n\n/**\n * Returns true if the input value is a CodeableConcept object.\n * This is a heuristic check based on the presence of the \"coding\" property.\n * @param value - The candidate value.\n * @returns True if the input value is a CodeableConcept.\n */\nexport function isCodeableConcept(value: unknown): value is CodeableConcept & { coding: Coding[] } {\n  return isObject(value) && 'coding' in value && Array.isArray(value.coding) && value.coding.every(isCoding);\n}\n\n/**\n * Returns true if the input value is an object with a string text property.\n * This is a heuristic check based on the presence of the \"text\" property.\n * @param value - The candidate value.\n * @returns True if the input value is a text object.\n */\nexport function isTextObject(value: unknown): value is { text: string } {\n  return isObject(value) && 'text' in value && typeof value.text === 'string';\n}\n\n// Precompute hex octets\n// See: https://stackoverflow.com/a/55200387\nconst byteToHex: string[] = [];\nfor (let n = 0; n < 256; n++) {\n  byteToHex.push(n.toString(16).padStart(2, '0'));\n}\n\n/**\n * Converts an ArrayBuffer to hex string.\n * See: https://stackoverflow.com/a/55200387\n * @param arrayBuffer - The input array buffer.\n * @returns The resulting hex string.\n */\nexport function arrayBufferToHex(arrayBuffer: ArrayBufferLike | ArrayBufferView): string {\n  const buffer = normalizeArrayBufferView(arrayBuffer);\n  const bytes = new Uint8Array(buffer);\n  const result: string[] = new Array(bytes.length);\n  for (let i = 0; i < bytes.length; i++) {\n    result[i] = byteToHex[bytes[i]];\n  }\n  return result.join('');\n}\n\n/**\n * Converts an ArrayBuffer to a base-64 encoded string.\n * @param arrayBuffer - The input array buffer.\n * @returns The base-64 encoded string.\n */\nexport function arrayBufferToBase64(arrayBuffer: ArrayBufferLike | ArrayBufferView): string {\n  const buffer = normalizeArrayBufferView(arrayBuffer);\n  const bytes = new Uint8Array(buffer);\n  const result: string[] = new Array(bytes.length);\n  for (let i = 0; i < bytes.length; i++) {\n    result[i] = String.fromCharCode(bytes[i]);\n  }\n  return window.btoa(result.join(''));\n}\n\n/**\n * Normalizes an `ArrayBufferLike` (eg. an `ArrayBuffer`) to a raw `ArrayBufferLike` (without a view). If the passed buffer is a view, it gives the raw `ArrayBufferLike`.\n *\n * This is useful in cases where you need to operate on the raw bytes of an `ArrayBuffer` where a `TypedArray` (eg. `Uint32Array`) might be passed in.\n * This ensures that you will always operate on the raw bytes rather than accidentally truncating the input by operating on the elements of the view.\n *\n * @param typedArrayOrBuffer - The `ArrayBufferLike` (either `TypedArray` or raw `ArrayBuffer`) to normalize to raw `ArrayBuffer`.\n * @returns The raw `ArrayBuffer` without a view.\n */\nexport function normalizeArrayBufferView(typedArrayOrBuffer: ArrayBufferLike | ArrayBufferView): ArrayBufferLike {\n  return ArrayBuffer.isView(typedArrayOrBuffer) ? typedArrayOrBuffer.buffer : typedArrayOrBuffer;\n}\n\nexport function capitalize(word: string): string {\n  if (!word) {\n    return '';\n  }\n  return word.charAt(0).toUpperCase() + word.substring(1);\n}\n\nexport function isLowerCase(c: string): boolean {\n  return c === c.toLowerCase() && c !== c.toUpperCase();\n}\n\nexport function isComplexTypeCode(code: string): boolean {\n  return code.length > 0 && code.startsWith(code[0].toUpperCase());\n}\n\n/**\n * Returns the difference between two paths which is often suitable to use as a key in a `Record<string, InternalSchemaElement>`\n * @param parentPath - The parent path that will be removed from `path`.\n * @param path - The element path that should be a child of `parentPath`.\n * @returns - The difference between `path` and `parentPath` or `undefined` if `path` is not a child of `parentPath`.\n */\nexport function getPathDifference(parentPath: string, path: string): string | undefined {\n  const parentPathPrefix = parentPath + '.';\n  if (path.startsWith(parentPathPrefix)) {\n    return path.slice(parentPathPrefix.length);\n  }\n  return undefined;\n}\n\n/**\n * Tries to find a code string for a given system within a given codeable concept.\n * @param concept - The codeable concept.\n * @param system - The system string.\n * @returns The code if found; otherwise undefined.\n */\nexport function getCodeBySystem(concept: CodeableConcept, system: string): string | undefined {\n  return concept.coding?.find((coding) => coding.system === system)?.code;\n}\n\n/**\n * Sets a code for a given system within a given codeable concept.\n * @param concept - The codeable concept.\n * @param system - The system string.\n * @param code - The code value.\n */\nexport function setCodeBySystem(concept: CodeableConcept, system: string, code: string): void {\n  if (!concept.coding) {\n    concept.coding = [];\n  }\n  const coding = concept.coding.find((c) => c.system === system);\n  if (coding) {\n    coding.code = code;\n  } else {\n    concept.coding.push({ system, code });\n  }\n}\n\n/**\n * Tries to find an observation interval for the given patient and value.\n * @param definition - The observation definition.\n * @param patient - The patient.\n * @param value - The observation value.\n * @param category - Optional interval category restriction.\n * @returns The observation interval if found; otherwise undefined.\n */\nexport function findObservationInterval(\n  definition: ObservationDefinition,\n  patient: Patient,\n  value: number,\n  category?: 'reference' | 'critical' | 'absolute'\n): ObservationDefinitionQualifiedInterval | undefined {\n  return definition.qualifiedInterval?.find(\n    (interval) =>\n      observationIntervalMatchesPatient(interval, patient) &&\n      observationIntervalMatchesValue(interval, value, definition.quantitativeDetails?.decimalPrecision) &&\n      (category === undefined || interval.category === category)\n  );\n}\n\n/**\n * Tries to find an observation reference range for the given patient and condition names.\n * @param definition - The observation definition.\n * @param patient - The patient.\n * @param names - Optional condition names.\n * @returns The observation interval if found; otherwise undefined.\n */\nexport function findObservationReferenceRange(\n  definition: ObservationDefinition,\n  patient: Patient,\n  names?: string[]\n): ObservationDefinitionQualifiedInterval | undefined {\n  return findObservationReferenceRanges(definition, patient, names)[0];\n}\n\n/**\n * Returns all matching observation reference range for the given patient and condition names.\n * @param definition - The observation definition.\n * @param patient - The patient.\n * @param names - Optional condition names.\n * @returns The observation intervals if found; otherwise an empty array.\n */\nexport function findObservationReferenceRanges(\n  definition: ObservationDefinition,\n  patient: Patient,\n  names?: string[]\n): ObservationDefinitionQualifiedInterval[] {\n  return (\n    definition.qualifiedInterval?.filter(\n      (interval) =>\n        observationIntervalMatchesPatient(interval, patient) && (!names || names.includes(interval.condition as string))\n    ) ?? []\n  );\n}\n\n/**\n * Returns true if the patient matches the observation interval.\n * @param interval - The observation interval.\n * @param patient - The patient.\n * @returns True if the patient matches the observation interval.\n */\nfunction observationIntervalMatchesPatient(\n  interval: ObservationDefinitionQualifiedInterval,\n  patient: Patient\n): boolean {\n  return observationIntervalMatchesGender(interval, patient) && observationIntervalMatchesAge(interval, patient);\n}\n\n/**\n * Returns true if the patient gender matches the observation interval.\n * @param interval - The observation interval.\n * @param patient - The patient.\n * @returns True if the patient gender matches the observation interval.\n */\nfunction observationIntervalMatchesGender(interval: ObservationDefinitionQualifiedInterval, patient: Patient): boolean {\n  return !interval.gender || interval.gender === patient.gender;\n}\n\n/**\n * Returns true if the patient age matches the observation interval.\n * @param interval - The observation interval.\n * @param patient - The patient.\n * @returns True if the patient age matches the observation interval.\n */\nfunction observationIntervalMatchesAge(interval: ObservationDefinitionQualifiedInterval, patient: Patient): boolean {\n  return !interval.age || matchesRange(calculateAge(patient.birthDate as string).years, interval.age);\n}\n\n/**\n * Returns true if the value matches the observation interval.\n * @param interval - The observation interval.\n * @param value - The observation value.\n * @param precision - Optional precision in number of digits.\n * @returns True if the value matches the observation interval.\n */\nfunction observationIntervalMatchesValue(\n  interval: ObservationDefinitionQualifiedInterval,\n  value: number,\n  precision?: number\n): boolean {\n  return !!interval.range && matchesRange(value, interval.range, precision);\n}\n\n/**\n * Returns true if the value is in the range accounting for precision.\n * @param value - The numeric value.\n * @param range - The numeric range.\n * @param precision - Optional precision in number of digits.\n * @returns True if the value is within the range.\n */\nexport function matchesRange(value: number, range: Range, precision?: number): boolean {\n  return (\n    (range.low?.value === undefined || preciseGreaterThanOrEquals(value, range.low.value, precision)) &&\n    (range.high?.value === undefined || preciseLessThanOrEquals(value, range.high.value, precision))\n  );\n}\n\n/**\n * Returns the input number rounded to the specified number of digits.\n * @param a - The input number.\n * @param precision - The precision in number of digits.\n * @returns The number rounded to the specified number of digits.\n */\nexport function preciseRound(a: number, precision: number): number {\n  return parseFloat(a.toFixed(precision));\n}\n\n/**\n * Returns true if the two numbers are equal to the given precision.\n * @param a - The first number.\n * @param b - The second number.\n * @param precision - Optional precision in number of digits.\n * @returns True if the two numbers are equal to the given precision.\n */\nexport function preciseEquals(a: number, b: number, precision?: number): boolean {\n  return toPreciseInteger(a, precision) === toPreciseInteger(b, precision);\n}\n\n/**\n * Returns true if the first number is less than the second number to the given precision.\n * @param a - The first number.\n * @param b - The second number.\n * @param precision - Optional precision in number of digits.\n * @returns True if the first number is less than the second number to the given precision.\n */\nexport function preciseLessThan(a: number, b: number, precision?: number): boolean {\n  return toPreciseInteger(a, precision) < toPreciseInteger(b, precision);\n}\n\n/**\n * Returns true if the first number is greater than the second number to the given precision.\n * @param a - The first number.\n * @param b - The second number.\n * @param precision - Optional precision in number of digits.\n * @returns True if the first number is greater than the second number to the given precision.\n */\nexport function preciseGreaterThan(a: number, b: number, precision?: number): boolean {\n  return toPreciseInteger(a, precision) > toPreciseInteger(b, precision);\n}\n\n/**\n * Returns true if the first number is less than or equal to the second number to the given precision.\n * @param a - The first number.\n * @param b - The second number.\n * @param precision - Optional precision in number of digits.\n * @returns True if the first number is less than or equal to the second number to the given precision.\n */\nexport function preciseLessThanOrEquals(a: number, b: number, precision?: number): boolean {\n  return toPreciseInteger(a, precision) <= toPreciseInteger(b, precision);\n}\n\n/**\n * Returns true if the first number is greater than or equal to the second number to the given precision.\n * @param a - The first number.\n * @param b - The second number.\n * @param precision - Optional precision in number of digits.\n * @returns True if the first number is greater than or equal to the second number to the given precision.\n */\nexport function preciseGreaterThanOrEquals(a: number, b: number, precision?: number): boolean {\n  return toPreciseInteger(a, precision) >= toPreciseInteger(b, precision);\n}\n\n/**\n * Returns an integer representation of the number with the given precision.\n * For example, if precision is 2, then 1.2345 will be returned as 123.\n * @param a - The number.\n * @param precision - Optional precision in number of digits.\n * @returns The integer with the given precision.\n */\nfunction toPreciseInteger(a: number, precision?: number): number {\n  if (precision === undefined) {\n    return a;\n  }\n  return Math.round(a * Math.pow(10, precision));\n}\n\n/**\n * Finds the first resource in the input array that matches the specified code and system.\n * @param resources - The array of resources to search.\n * @param code - The code to search for.\n * @param system - The system to search for.\n * @returns The first resource in the input array that matches the specified code and system, or undefined if no such resource is found.\n */\nexport function findResourceByCode(\n  resources: ResourceWithCode[],\n  code: CodeableConcept | string,\n  system: string\n): ResourceWithCode | undefined {\n  return resources.find((r) =>\n    typeof code === 'string'\n      ? getCodeBySystem(r.code || {}, system) === code\n      : getCodeBySystem(r.code || {}, system) === getCodeBySystem(code, system)\n  );\n}\n\nexport function arrayify<T>(value: T | T[] | undefined): T[] | undefined {\n  if (value === undefined) {\n    return undefined;\n  } else if (Array.isArray(value)) {\n    return value;\n  } else {\n    return [value];\n  }\n}\n\nexport function singularize<T>(value: T | T[] | undefined): T | undefined {\n  if (Array.isArray(value)) {\n    return value[0];\n  } else {\n    return value;\n  }\n}\n\n/**\n * Sleeps for the specified number of milliseconds.\n * @param ms - Time delay in milliseconds\n * @returns A promise that resolves after the specified number of milliseconds.\n */\nexport const sleep = (ms: number): Promise<void> =>\n  new Promise((resolve) => {\n    setTimeout(resolve, ms);\n  });\n\n/**\n * Splits a string into an array of strings using the specified delimiter.\n * Unlike the built-in split function, this function will split the string into a maximum of exactly n parts.\n * Trailing empty strings are included in the result.\n * @param str - The string to split.\n * @param delim - The delimiter.\n * @param n - The maximum number of parts to split the string into.\n * @returns The resulting array of strings.\n */\nexport function splitN(str: string, delim: string, n: number): string[] {\n  const result: string[] = [];\n  for (let i = 0; i < n - 1; i++) {\n    const delimIndex = str.indexOf(delim);\n    if (delimIndex < 0) {\n      break;\n    } else {\n      result.push(str.slice(0, delimIndex));\n      str = str.slice(delimIndex + delim.length);\n    }\n  }\n  result.push(str);\n  return result;\n}\n\n/**\n * Memoizes the result of a parameterless function\n * @param fn - The function to be wrapped\n * @returns The result of the first invocation of the wrapped function\n */\nexport function lazy<T>(fn: () => T): () => T {\n  let result: T;\n  let executed = false;\n\n  return function (): T {\n    if (!executed) {\n      result = fn();\n      executed = true;\n    }\n    return result;\n  };\n}\n\nexport function append<T>(array: T[] | undefined, value: T): T[] {\n  if (!array) {\n    return [value];\n  }\n  array.push(value);\n  return array;\n}\n\n/**\n * Sorts an array of strings in place using the localeCompare method.\n *\n * This method will mutate the input array.\n *\n * @param array - The array of strings to sort.\n * @returns The sorted array of strings.\n */\nexport function sortStringArray(array: string[]): string[] {\n  return array.sort((a, b) => a.localeCompare(b));\n}\n\n/**\n * Ensures the given URL has a trailing slash.\n * @param url - The URL to ensure has a trailing slash.\n * @returns The URL with a trailing slash.\n */\nexport function ensureTrailingSlash(url: string): string {\n  return url.endsWith('/') ? url : url + '/';\n}\n\n/**\n * Ensures the given URL has no leading slash.\n * @param url - The URL to ensure has no leading slash.\n * @returns The URL string with no slash.\n */\nexport function ensureNoLeadingSlash(url: string): string {\n  return url.startsWith('/') ? url.slice(1) : url;\n}\n\n/**\n * Concatenates the given base URL and URL.\n *\n * If the URL is absolute, it is returned as-is.\n *\n * @param baseUrl - The base URL.\n * @param path - The URL to concat. Can be relative or absolute.\n * @returns The concatenated URL.\n */\nexport function concatUrls(baseUrl: string | URL, path: string): string {\n  return new URL(ensureNoLeadingSlash(path), ensureTrailingSlash(baseUrl.toString())).toString();\n}\n\n/**\n * Concatenates a given base URL and path, ensuring the URL has the appropriate `ws://` or `wss://` protocol instead of `http://` or `https://`.\n *\n * @param baseUrl - The base URL.\n * @param path - The URL to concat. Can be relative or absolute.\n * @returns The concatenated WebSocket URL.\n */\nexport function getWebSocketUrl(baseUrl: URL | string, path: string): string {\n  return concatUrls(baseUrl, path).toString().replace('http://', 'ws://').replace('https://', 'wss://');\n}\n\n/**\n * Converts the given `query` to a string.\n *\n * @param query - The query to convert. The type can be any member of `QueryTypes`.\n * @returns The query as a string.\n */\nexport function getQueryString(query: QueryTypes): string {\n  if (typeof query === 'object' && !Array.isArray(query) && !(query instanceof URLSearchParams)) {\n    query = Object.fromEntries(Object.entries(query).filter((entry) => entry[1] !== undefined));\n  }\n  // @ts-expect-error Technically `Record<string, string, number, boolean>` is not valid to pass into `URLSearchParams` constructor since `boolean` and `number`\n  // are not considered to be valid values based on the WebIDL definition from WhatWG. The current runtime behavior relies on implementation-specific coercion to string under the hood.\n  // Source: https://url.spec.whatwg.org/#dom-urlsearchparams-urlsearchparams:~:text=6.2.%20URLSearchParams,)%20init%20%3D%20%22%22)%3B\n  return new URLSearchParams(query).toString();\n}\n\nexport const VALID_HOSTNAME_REGEX =\n  /^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-_]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-_]*[A-Za-z0-9])$/;\n\n/**\n * Tests whether a given input is a valid hostname.\n *\n * __NOTE: Does not validate that the input is a valid domain name, only a valid hostname.__\n *\n * @param input - The input to test.\n * @returns True if `input` is a valid hostname, otherwise returns false.\n *\n * ### Valid matches:\n * - foo\n * - foo.com\n * - foo.bar.com\n * - foo.org\n * - foo.bar.co.uk\n * - localhost\n * - LOCALHOST\n * - foo-bar-baz\n * - foo_bar\n * - foobar123\n *\n * ### Invalid matches:\n * - foo.com/bar\n * - https://foo.com\n * - foo_-bar_-\n * - foo | rm -rf /\n */\nexport function isValidHostname(input: string): boolean {\n  return VALID_HOSTNAME_REGEX.test(input);\n}\n\n/**\n * Adds the supplied profileUrl to the resource.meta.profile if it is not already\n * specified\n * @param resource - A FHIR resource\n * @param profileUrl - The profile URL to add\n * @returns The resource\n */\nexport function addProfileToResource<T extends Resource = Resource>(resource: T, profileUrl: string): T {\n  if (!resource?.meta?.profile?.includes(profileUrl)) {\n    resource.meta = resource.meta ?? {};\n    resource.meta.profile = resource.meta.profile ?? [];\n    resource.meta.profile.push(profileUrl);\n  }\n  return resource;\n}\n\n/**\n * Returns a Map of resources from a bundle, using the specified identifier system as the key.\n * @param resourceBundle - The bundle of resources.\n * @param identifierSystem - The identifier system to use for keys.\n * @returns Map of resources keyed by identifier value for the specified system.\n */\nexport function mapByIdentifier<T extends Resource = Resource>(\n  resourceBundle: Bundle<T>,\n  identifierSystem: string\n): Map<string, T> {\n  const resourceMap = new Map<string, T>(\n    resourceBundle.entry\n      ?.filter((e) => !!e.resource)\n      .map((e) => [getIdentifier(e.resource as Resource, identifierSystem) as string, e.resource as T])\n      .filter(([i]) => i !== undefined) as [string, T][]\n  );\n  return resourceMap;\n}\n\n/**\n * Removes the supplied profileUrl from the resource.meta.profile if it is present\n * @param resource - A FHIR resource\n * @param profileUrl - The profile URL to remove\n * @returns The resource\n */\nexport function removeProfileFromResource<T extends Resource = Resource>(resource: T, profileUrl: string): T {\n  if (resource?.meta?.profile?.includes(profileUrl)) {\n    const index = resource.meta.profile.indexOf(profileUrl);\n    resource.meta.profile.splice(index, 1);\n  }\n  return resource;\n}\n\nexport function flatMapFilter<T, U>(arr: T[] | undefined, fn: (value: T, idx: number) => U | undefined): U[] {\n  const result: U[] = [];\n  if (!arr) {\n    return result;\n  }\n\n  for (let i = 0; i < arr.length; i++) {\n    const resultValue = fn(arr[i], i);\n    if (Array.isArray(resultValue)) {\n      result.push(...resultValue.flat());\n    } else if (resultValue !== undefined) {\n      result.push(resultValue);\n    }\n  }\n  return result;\n}\n\n/**\n * Returns the escaped HTML string of the input string.\n * @param unsafe - The unsafe HTML string to escape.\n * @returns The escaped HTML string.\n */\nexport function escapeHtml(unsafe: string): string {\n  return unsafe\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/\u201C/g, '&ldquo;')\n    .replace(/\u201D/g, '&rdquo;')\n    .replace(/\u2018/g, '&lsquo;')\n    .replace(/\u2019/g, '&rsquo;')\n    .replace(/\u2026/g, '&hellip;');\n}\n", "import {\n  Address,\n  CodeableConcept,\n  Coding,\n  HumanName,\n  Money,\n  Observation,\n  ObservationComponent,\n  Period,\n  Quantity,\n  Range,\n  Reference,\n  Timing,\n  TimingRepeat,\n} from '@medplum/fhirtypes';\nimport { TypedValue } from './types';\nimport { capitalize, stringify } from './utils';\n\nexport interface AddressFormatOptions {\n  all?: boolean;\n  use?: boolean;\n  lineSeparator?: string;\n}\n\nexport interface HumanNameFormatOptions {\n  all?: boolean;\n  prefix?: boolean;\n  suffix?: boolean;\n  use?: boolean;\n}\n\n/**\n * Converts a typed value to a string.\n * @param typedValue - The typed value to convert to a string.\n * @returns The string representation of the typed value.\n */\nexport function typedValueToString(typedValue: TypedValue | undefined): string {\n  if (!typedValue) {\n    return '';\n  }\n  switch (typedValue.type) {\n    case 'Address':\n      return formatAddress(typedValue.value);\n    case 'CodeableConcept':\n      return formatCodeableConcept(typedValue.value);\n    case 'Coding':\n      return formatCoding(typedValue.value);\n    case 'ContactPoint':\n      return typedValue.value.value;\n    case 'HumanName':\n      return formatHumanName(typedValue.value);\n    case 'Quantity':\n      return formatQuantity(typedValue.value);\n    case 'Reference':\n      return formatReferenceString(typedValue.value);\n    default:\n      return typedValue.value.toString();\n  }\n}\n\n/**\n * Formats a FHIR Reference as a string.\n * @param value - The reference to format.\n * @returns The formatted reference string.\n */\nexport function formatReferenceString(value: Reference | undefined): string {\n  if (!value) {\n    return '';\n  }\n  return value.display ?? value.reference ?? stringify(value);\n}\n\n/**\n * Formats a FHIR Address as a string.\n * @param address - The address to format.\n * @param options - Optional address format options.\n * @returns The formatted address string.\n */\nexport function formatAddress(address: Address | undefined, options?: AddressFormatOptions): string {\n  if (!address) {\n    return '';\n  }\n\n  const builder = [];\n\n  if (address.line) {\n    builder.push(...address.line);\n  }\n\n  if (address.city || address.state || address.postalCode) {\n    const cityStateZip = [];\n    if (address.city) {\n      cityStateZip.push(address.city);\n    }\n    if (address.state) {\n      cityStateZip.push(address.state);\n    }\n    if (address.postalCode) {\n      cityStateZip.push(address.postalCode);\n    }\n    builder.push(cityStateZip.join(', '));\n  }\n\n  if (address.use && (options?.all || options?.use)) {\n    builder.push('[' + address.use + ']');\n  }\n\n  return builder.join(options?.lineSeparator ?? ', ').trim();\n}\n\n/**\n * Formats a FHIR HumanName as a string.\n * @param name - The name to format.\n * @param options - Optional name format options.\n * @returns The formatted name string.\n */\nexport function formatHumanName(name: HumanName | undefined, options?: HumanNameFormatOptions): string {\n  if (!name) {\n    return '';\n  }\n\n  const builder = [];\n\n  if (name.prefix && options?.prefix !== false) {\n    builder.push(...name.prefix);\n  }\n\n  if (name.given) {\n    builder.push(...name.given);\n  }\n\n  if (name.family) {\n    builder.push(name.family);\n  }\n\n  if (name.suffix && options?.suffix !== false) {\n    builder.push(...name.suffix);\n  }\n\n  if (name.use && (options?.all || options?.use)) {\n    builder.push('[' + name.use + ']');\n  }\n\n  if (builder.length === 0) {\n    const textStr = ensureString(name.text);\n    if (textStr) {\n      return textStr;\n    }\n  }\n\n  return builder.join(' ').trim();\n}\n\n/**\n * Formats the given name portion of a FHIR HumanName element.\n * @param name - The name to format.\n * @returns The formatted given name string.\n */\nexport function formatGivenName(name: HumanName): string {\n  const builder: string[] = [];\n  if (name.given) {\n    builder.push(...name.given);\n  }\n  return builder.join(' ').trim();\n}\n\n/**\n * Formats the family name portion of a FHIR HumanName element.\n * @param name - The name to format.\n * @returns The formatted family name string.\n */\nexport function formatFamilyName(name: HumanName): string {\n  return ensureString(name.family) ?? '';\n}\n\n/**\n * Returns true if the given date object is a valid date.\n * Dates can be invalid if created by parsing an invalid string.\n * @param date - A date object.\n * @returns Returns true if the date is a valid date.\n */\nexport function isValidDate(date: Date): boolean {\n  return date instanceof Date && !isNaN(date.getTime());\n}\n\n/**\n * Formats a FHIR date string as a human readable string.\n * Handles missing values and invalid dates.\n * @param date - The date to format.\n * @param locales - Optional locales.\n * @param options - Optional date format options.\n * @returns The formatted date string.\n */\nexport function formatDate(\n  date: string | undefined,\n  locales?: Intl.LocalesArgument,\n  options?: Intl.DateTimeFormatOptions\n): string {\n  if (!date) {\n    return '';\n  }\n  const d = new Date(date);\n  if (!isValidDate(d)) {\n    return '';\n  }\n  d.setUTCHours(0, 0, 0, 0);\n  return d.toLocaleDateString(locales, { timeZone: 'UTC', ...options });\n}\n\n/**\n * Formats a FHIR time string as a human readable string.\n * Handles missing values and invalid dates.\n * @param time - The date to format.\n * @param locales - Optional locales.\n * @param options - Optional time format options.\n * @returns The formatted time string.\n */\nexport function formatTime(\n  time: string | undefined,\n  locales?: Intl.LocalesArgument,\n  options?: Intl.DateTimeFormatOptions\n): string {\n  if (!time) {\n    return '';\n  }\n  const d = new Date('2000-01-01T' + time + 'Z');\n  if (!isValidDate(d)) {\n    return '';\n  }\n  return d.toLocaleTimeString(locales, options);\n}\n\n/**\n * Formats a FHIR dateTime string as a human readable string.\n * Handles missing values and invalid dates.\n * @param dateTime - The dateTime to format.\n * @param locales - Optional locales.\n * @param options - Optional dateTime format options.\n * @returns The formatted dateTime string.\n */\nexport function formatDateTime(\n  dateTime: string | undefined,\n  locales?: Intl.LocalesArgument,\n  options?: Intl.DateTimeFormatOptions\n): string {\n  if (!dateTime) {\n    return '';\n  }\n  const d = new Date(dateTime);\n  if (!isValidDate(d)) {\n    return '';\n  }\n  return d.toLocaleString(locales, options);\n}\n\n/**\n * Formats a FHIR Period as a human readable string.\n * @param period - The period to format.\n * @param locales - Optional locales.\n * @param options - Optional period format options.\n * @returns The formatted period string.\n */\nexport function formatPeriod(\n  period: Period | undefined,\n  locales?: Intl.LocalesArgument,\n  options?: Intl.DateTimeFormatOptions\n): string {\n  if (!period || (!period.start && !period.end)) {\n    return '';\n  }\n  return formatDateTime(period.start, locales, options) + ' - ' + formatDateTime(period.end, locales, options);\n}\n\nconst unitAdverbForm: Record<string, string> = {\n  s: 'every second',\n  min: 'every minute',\n  h: 'hourly',\n  d: 'daily',\n  wk: 'weekly',\n  mo: 'monthly',\n  a: 'annually',\n};\n\nconst singularUnits: Record<string, string> = {\n  s: 'second',\n  min: 'minute',\n  h: 'hour',\n  d: 'day',\n  wk: 'week',\n  mo: 'month',\n  a: 'year',\n};\n\nconst pluralUnits: Record<string, string> = {\n  s: 'seconds',\n  min: 'minutes',\n  h: 'hours',\n  d: 'days',\n  wk: 'weeks',\n  mo: 'months',\n  a: 'years',\n};\n\n/**\n * Formats a FHIR Timing as a human readable string.\n * @param timing - The timing to format.\n * @returns The formatted timing string.\n */\nexport function formatTiming(timing: Timing | undefined): string {\n  if (!timing) {\n    return '';\n  }\n\n  const builder: string[] = [];\n  formatTimingRepeat(builder, timing.repeat);\n\n  if (timing.event) {\n    builder.push(timing.event.map((d) => formatDateTime(d)).join(', '));\n  }\n\n  return capitalize(builder.join(' ').trim());\n}\n\n/**\n * Formats a FHIR Timing repeat element as a human readable string.\n * @param builder - The output string builder.\n * @param repeat - The timing repeat element.\n */\nfunction formatTimingRepeat(builder: string[], repeat: TimingRepeat | undefined): void {\n  if (!repeat?.periodUnit) {\n    // Period unit is the only required field\n    return;\n  }\n\n  const frequency = repeat.frequency ?? 1;\n  const period = repeat.period ?? 1;\n  const periodUnit = repeat.periodUnit;\n\n  if (frequency === 1 && period === 1) {\n    builder.push(unitAdverbForm[periodUnit]);\n  } else {\n    if (frequency === 1) {\n      builder.push('once');\n    } else {\n      builder.push(frequency + ' times');\n    }\n\n    if (period === 1) {\n      builder.push('per ' + singularUnits[periodUnit]);\n    } else {\n      builder.push('per ' + period + ' ' + pluralUnits[periodUnit]);\n    }\n  }\n\n  if (repeat.dayOfWeek) {\n    builder.push('on ' + repeat.dayOfWeek.map(capitalize).join(', '));\n  }\n\n  if (repeat.timeOfDay) {\n    builder.push('at ' + repeat.timeOfDay.map((t) => formatTime(t)).join(', '));\n  }\n}\n\n/**\n * Returns a human-readable string for a FHIR Range datatype, taking into account one-sided ranges\n * @param range - A FHIR Range element\n * @param precision - Number of decimal places to display in the rendered quantity values\n * @param exclusive - If true, one-sided ranges will be rendered with the `>` or `<` bounds rather than `>=` or `<=`\n * @returns A human-readable string representation of the Range\n */\nexport function formatRange(range: Range | undefined, precision?: number, exclusive = false): string {\n  if (exclusive && precision === undefined) {\n    throw new Error('Precision must be specified for exclusive ranges');\n  }\n\n  // Extract high and low range endpoints, explicitly ignoring any comparator\n  // since Range uses SimpleQuantity variants (see http://www.hl7.org/fhir/datatypes.html#Range)\n  const low = range?.low && { ...range.low, comparator: undefined };\n  const high = range?.high && { ...range.high, comparator: undefined };\n  if (low?.value === undefined && high?.value === undefined) {\n    return '';\n  }\n\n  if (low?.value !== undefined && high?.value === undefined) {\n    // Lower bound only\n    if (exclusive && precision !== undefined) {\n      low.value = preciseDecrement(low.value, precision);\n      return `> ${formatQuantity(low, precision)}`;\n    }\n    return `>= ${formatQuantity(low, precision)}`;\n  } else if (low?.value === undefined && high?.value !== undefined) {\n    // Upper bound only\n    if (exclusive && precision !== undefined) {\n      high.value = preciseIncrement(high.value, precision);\n      return `< ${formatQuantity(high, precision)}`;\n    }\n    return `<= ${formatQuantity(high, precision)}`;\n  } else {\n    // Double-sided range\n    if (low?.unit === high?.unit) {\n      delete low?.unit; // Format like \"X - Y units\" instead of \"X units - Y units\"\n    }\n    return `${formatQuantity(low, precision)} - ${formatQuantity(high, precision)}`;\n  }\n}\n\n/**\n * Returns a human-readable string for a FHIR Quantity datatype, taking into account units and comparators\n * @param quantity - A FHIR Quantity element\n * @param precision - Number of decimal places to display in the rendered quantity values\n * @returns A human-readable string representation of the Quantity\n */\nexport function formatQuantity(quantity: Quantity | undefined, precision?: number): string {\n  if (!quantity) {\n    return '';\n  }\n\n  const result = [];\n\n  if (quantity.comparator) {\n    result.push(quantity.comparator);\n    result.push(' ');\n  }\n\n  if (quantity.value !== undefined) {\n    if (precision !== undefined) {\n      result.push(quantity.value.toFixed(precision));\n    } else {\n      result.push(quantity.value);\n    }\n  }\n\n  if (quantity.unit) {\n    if (quantity.unit !== '%' && result[result.length - 1] !== ' ') {\n      result.push(' ');\n    }\n    result.push(quantity.unit);\n  }\n\n  return result.join('').trim();\n}\n\nexport function formatMoney(money: Money | undefined): string {\n  if (money?.value === undefined) {\n    return '';\n  }\n\n  return money.value.toLocaleString(undefined, {\n    style: 'currency',\n    currency: money.currency ?? 'USD',\n    currencyDisplay: 'narrowSymbol',\n  });\n}\n\n/**\n * Formats a CodeableConcept element as a string.\n * @param codeableConcept - A FHIR CodeableConcept element\n * @returns The codeable concept as a string.\n */\nexport function formatCodeableConcept(codeableConcept: CodeableConcept | undefined): string {\n  if (!codeableConcept) {\n    return '';\n  }\n  const textStr = ensureString(codeableConcept.text);\n  if (textStr) {\n    return textStr;\n  }\n  if (codeableConcept.coding) {\n    return codeableConcept.coding.map((c) => formatCoding(c)).join(', ');\n  }\n  return '';\n}\n\n/**\n * Formats a Coding element as a string.\n * @param coding - A FHIR Coding element\n * @param includeCode - If true, includes both the code and display if available\n * @returns The coding as a string.\n */\nexport function formatCoding(coding: Coding | undefined, includeCode?: boolean): string {\n  const display = ensureString(coding?.display);\n  if (display) {\n    const code = includeCode ? ensureString(coding?.code) : undefined;\n    return `${display}${code ? ' (' + code + ')' : ''}`;\n  }\n\n  return ensureString(coding?.code) ?? '';\n}\n\n/**\n * Formats a FHIR Observation resource value as a string.\n * @param obs - A FHIR Observation resource.\n * @returns A human-readable string representation of the Observation.\n */\nexport function formatObservationValue(obs: Observation | ObservationComponent | undefined): string {\n  if (!obs) {\n    return '';\n  }\n\n  const result = [];\n\n  if (obs.valueQuantity) {\n    result.push(formatQuantity(obs.valueQuantity));\n  } else if (obs.valueCodeableConcept) {\n    result.push(formatCodeableConcept(obs.valueCodeableConcept));\n  } else {\n    const valueString = ensureString(obs.valueString);\n    if (valueString) {\n      result.push(valueString);\n    }\n  }\n\n  if ('component' in obs) {\n    result.push((obs.component as ObservationComponent[]).map((c) => formatObservationValue(c)).join(' / '));\n  }\n\n  return result.join(' / ').trim();\n}\n\n/**\n * Ensures the input is a string.\n * While the TypeScript type definitions for FHIR resources are strict, the actual input data can be malformed.\n * We use this method to protect against runtime errors.\n * @param input - The input to ensure is a string.\n * @returns The input as a string, or undefined if not a string.\n */\nfunction ensureString(input: unknown): string | undefined {\n  return typeof input === 'string' ? input : undefined;\n}\n\n/**\n * Returns the input number increased by the `n` units of the specified precision\n * @param a - The input number.\n * @param precision - The precision in number of digits.\n * @param n - (default 1) The number of units to add.\n * @returns The result of the increment.\n */\nfunction preciseIncrement(a: number, precision: number, n = 1): number {\n  return (toPreciseInteger(a, precision) + n) * Math.pow(10, -precision);\n}\n\n/**\n * Returns the input number decreased by the `n` units of the specified precision\n * @param a - The input number.\n * @param precision - The precision in number of digits.\n * @param n - (default 1) The number of units to subtract.\n * @returns The result of the decrement.\n */\nfunction preciseDecrement(a: number, precision: number, n = 1): number {\n  return (toPreciseInteger(a, precision) - n) * Math.pow(10, -precision);\n}\n\n/**\n * Returns an integer representation of the number with the given precision.\n * For example, if precision is 2, then 1.2345 will be returned as 123.\n * @param a - The number.\n * @param precision - Optional precision in number of digits.\n * @returns The integer with the given precision.\n */\nfunction toPreciseInteger(a: number, precision?: number): number {\n  if (precision === undefined) {\n    return a;\n  }\n  return Math.round(a * Math.pow(10, precision));\n}\n", "import {\n  Bundle,\n  CodeableConcept,\n  Coding,\n  ElementDefinition,\n  Reference,\n  Resource,\n  ResourceType,\n  SearchParameter,\n  StructureDefinition,\n} from '@medplum/fhirtypes';\nimport { formatHumanName } from './format';\nimport { SearchParameterDetails } from './search/details';\nimport { InternalSchemaElement, InternalTypeSchema, getAllDataTypes, tryGetDataType } from './typeschema/types';\nimport { capitalize, getReferenceString, isResourceWithId } from './utils';\n\nexport type TypeName<T> = T extends string\n  ? 'string'\n  : T extends number\n    ? 'number'\n    : T extends boolean\n      ? 'boolean'\n      : T extends undefined\n        ? 'undefined'\n        : 'object';\n\nexport interface TypedValue {\n  readonly type: string;\n  readonly value: any;\n}\n\n/**\n * List of property types.\n * http://www.hl7.org/fhir/valueset-defined-types.html\n * The list here includes additions found from StructureDefinition resources.\n */\nexport const PropertyType = {\n  Address: 'Address',\n  Age: 'Age',\n  Annotation: 'Annotation',\n  Attachment: 'Attachment',\n  BackboneElement: 'BackboneElement',\n  CodeableConcept: 'CodeableConcept',\n  Coding: 'Coding',\n  ContactDetail: 'ContactDetail',\n  ContactPoint: 'ContactPoint',\n  Contributor: 'Contributor',\n  Count: 'Count',\n  DataRequirement: 'DataRequirement',\n  Distance: 'Distance',\n  Dosage: 'Dosage',\n  Duration: 'Duration',\n  Expression: 'Expression',\n  Extension: 'Extension',\n  HumanName: 'HumanName',\n  Identifier: 'Identifier',\n  MarketingStatus: 'MarketingStatus',\n  Meta: 'Meta',\n  Money: 'Money',\n  Narrative: 'Narrative',\n  ParameterDefinition: 'ParameterDefinition',\n  Period: 'Period',\n  Population: 'Population',\n  ProdCharacteristic: 'ProdCharacteristic',\n  ProductShelfLife: 'ProductShelfLife',\n  Quantity: 'Quantity',\n  Range: 'Range',\n  Ratio: 'Ratio',\n  Reference: 'Reference',\n  RelatedArtifact: 'RelatedArtifact',\n  SampledData: 'SampledData',\n  Signature: 'Signature',\n  SubstanceAmount: 'SubstanceAmount',\n  SystemString: 'http://hl7.org/fhirpath/System.String',\n  Timing: 'Timing',\n  TriggerDefinition: 'TriggerDefinition',\n  UsageContext: 'UsageContext',\n  base64Binary: 'base64Binary',\n  boolean: 'boolean',\n  canonical: 'canonical',\n  code: 'code',\n  date: 'date',\n  dateTime: 'dateTime',\n  decimal: 'decimal',\n  id: 'id',\n  instant: 'instant',\n  integer: 'integer',\n  markdown: 'markdown',\n  oid: 'oid',\n  positiveInt: 'positiveInt',\n  string: 'string',\n  time: 'time',\n  unsignedInt: 'unsignedInt',\n  uri: 'uri',\n  url: 'url',\n  uuid: 'uuid',\n} as const;\n\n/**\n * An IndexedStructureDefinition is a lookup-optimized version of a StructureDefinition.\n *\n * StructureDefinition resources contain schema information for other resource types.\n * These schemas can be used to automatically generate user interface elements for\n * resources.\n *\n * However, a StructureDefinition resource is not optimized for realtime lookups.  All\n * resource types, sub types, and property definitions are stored in a flat array of\n * ElementDefinition objects.  Therefore, to lookup the schema for a property (i.e., \"Patient.name\")\n * requires a linear scan of all ElementDefinition objects\n *\n * A StructureDefinition resource contains information about one or more types.\n * For example, the \"Patient\" StructureDefinition includes \"Patient\", \"Patient_Contact\",\n * \"Patient_Communication\", and \"Patient_Link\".  This is inefficient.\n *\n * Instead, we create an indexed version of the StructureDefinition, called IndexedStructureDefinition.\n * In an IndexedStructureDefinition, retrieving a property definition is a hashtable lookup.\n *\n * The hierarchy is:\n *   IndexedStructureDefinition - top level for one resource type\n *   TypeSchema - one per resource type and all contained BackboneElements\n *   PropertySchema - one per property/field\n */\nexport interface IndexedStructureDefinition {\n  types: Record<string, TypeInfo>;\n}\n\n/**\n * An indexed TypeSchema.\n *\n * Example:  The IndexedStructureDefinition for \"Patient\" would include the following TypeSchemas:\n *   1) Patient\n *   2) Patient_Contact\n *   3) Patient_Communication\n *   4) Patient_Link\n */\nexport interface TypeInfo {\n  searchParams?: Record<string, SearchParameter>;\n  searchParamsDetails?: Record<string, SearchParameterDetails>;\n}\n\n/**\n * Indexes a bundle of SearchParameter resources for faster lookup.\n * @param bundle - A FHIR bundle SearchParameter resources.\n * @see {@link IndexedStructureDefinition} for more details on indexed StructureDefinitions.\n */\nexport function indexSearchParameterBundle(bundle: Bundle<SearchParameter>): void {\n  for (const entry of bundle.entry ?? []) {\n    const resource = entry.resource as SearchParameter;\n    if (resource.resourceType === 'SearchParameter') {\n      indexSearchParameter(resource);\n    }\n  }\n}\n\nexport function indexDefaultSearchParameters(bundle: StructureDefinition[] | Bundle): void {\n  const maybeSDs = Array.isArray(bundle) ? bundle : (bundle.entry?.map((e) => e.resource) ?? []);\n  for (const sd of maybeSDs) {\n    if (sd?.resourceType === 'StructureDefinition' && sd.kind === 'resource') {\n      getOrInitTypeSchema(sd.type);\n    }\n  }\n}\n\nfunction getOrInitTypeSchema(resourceType: string): TypeInfo {\n  let typeSchema = globalSchema.types[resourceType];\n  if (!typeSchema) {\n    typeSchema = {\n      searchParamsDetails: {},\n    } as TypeInfo;\n    globalSchema.types[resourceType] = typeSchema;\n  }\n\n  // Binary has no search parameters; not even those inherited from Resource\n  if (!typeSchema.searchParams && resourceType !== 'Binary') {\n    typeSchema.searchParams = {\n      _id: {\n        base: [resourceType],\n        code: '_id',\n        type: 'token',\n        expression: resourceType + '.id',\n      } as SearchParameter,\n      _lastUpdated: {\n        base: [resourceType],\n        code: '_lastUpdated',\n        type: 'date',\n        expression: resourceType + '.meta.lastUpdated',\n      } as SearchParameter,\n      _compartment: {\n        base: [resourceType],\n        code: '_compartment',\n        type: 'reference',\n        expression: resourceType + '.meta.compartment',\n      } as SearchParameter,\n      _profile: {\n        base: [resourceType],\n        code: '_profile',\n        type: 'uri',\n        expression: resourceType + '.meta.profile',\n      } as SearchParameter,\n      _security: {\n        base: [resourceType],\n        code: '_security',\n        type: 'token',\n        expression: resourceType + '.meta.security',\n      } as SearchParameter,\n      _source: {\n        base: [resourceType],\n        code: '_source',\n        type: 'uri',\n        expression: resourceType + '.meta.source',\n      } as SearchParameter,\n      _tag: {\n        base: [resourceType],\n        code: '_tag',\n        type: 'token',\n        expression: resourceType + '.meta.tag',\n      } as SearchParameter,\n    };\n  }\n\n  return typeSchema;\n}\n\n/**\n * Indexes a SearchParameter resource for fast lookup.\n * Indexes by SearchParameter.code, which is the query string parameter name.\n * @param searchParam - The SearchParameter resource.\n * @see {@link IndexedStructureDefinition} for more details on indexed StructureDefinitions.\n */\nexport function indexSearchParameter(searchParam: SearchParameter): void {\n  for (const resourceType of searchParam.base ?? []) {\n    const typeSchema = getOrInitTypeSchema(resourceType);\n\n    if (!typeSchema.searchParams) {\n      typeSchema.searchParams = {};\n    }\n\n    typeSchema.searchParams[searchParam.code as string] = searchParam;\n  }\n}\n\n/**\n * Returns the type name for an ElementDefinition.\n * @param elementDefinition - The element definition.\n * @returns The Medplum type name.\n */\nexport function getElementDefinitionTypeName(elementDefinition: ElementDefinition): string {\n  const code = elementDefinition.type?.[0]?.code as string;\n  return code === 'BackboneElement' || code === 'Element'\n    ? buildTypeName((elementDefinition.base?.path ?? elementDefinition.path)?.split('.') as string[])\n    : code;\n}\n\nexport function buildTypeName(components: string[]): string {\n  if (components.length === 1) {\n    return components[0];\n  }\n  return components.map(capitalize).join('');\n}\n\n/**\n * Returns true if the type schema is a non-abstract FHIR resource.\n * @param typeSchema - The type schema to check.\n * @returns True if the type schema is a non-abstract FHIR resource.\n */\nexport function isResourceTypeSchema(typeSchema: InternalTypeSchema): boolean {\n  return typeSchema.kind === 'resource' && typeSchema.name !== 'Resource' && typeSchema.name !== 'DomainResource';\n}\n\n/**\n * Returns an array of all resource types.\n * Note that this is based on globalSchema, and will only return resource types that are currently in memory.\n * @returns An array of all resource types.\n */\nexport function getResourceTypes(): ResourceType[] {\n  return Object.values(getAllDataTypes())\n    .filter(isResourceTypeSchema)\n    .map((schema) => schema.name as ResourceType);\n}\n\n/**\n * Returns the search parameters for the resource type indexed by search code.\n * @param resourceType - The resource type.\n * @returns The search parameters for the resource type indexed by search code.\n */\nexport function getSearchParameters(resourceType: string): Record<string, SearchParameter> | undefined {\n  return globalSchema.types[resourceType]?.searchParams;\n}\n\n/**\n * Returns a search parameter for a resource type by search code.\n * @param resourceType - The FHIR resource type.\n * @param code - The search parameter code.\n * @returns The search parameter if found, otherwise undefined.\n */\nexport function getSearchParameter(resourceType: string, code: string): SearchParameter | undefined {\n  return globalSchema.types[resourceType]?.searchParams?.[code];\n}\n\n/**\n * Returns a human friendly display name for a FHIR element definition path.\n * @param path - The FHIR element definition path.\n * @returns The best guess of the display name.\n */\nexport function getPathDisplayName(path: string): string {\n  // Get the property name, which is the remainder after the last period\n  // For example, for path \"Patient.birthDate\"\n  // the property name is \"birthDate\"\n  const propertyName = path.replaceAll('[x]', '').split('.').pop() as string;\n\n  return getPropertyDisplayName(propertyName);\n}\n\n/**\n * Returns a human friendly display name for a FHIR element property or slice name\n * @param propertyName - The FHIR element property or slice name\n * @returns The best guess of the display name.\n */\nexport function getPropertyDisplayName(propertyName: string): string {\n  let words: string[];\n  // CodeQL flags the regex below for potential ReDoS (Regex Denial of Service), so limit input size\n  // https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\n  if (propertyName.length < 100) {\n    /*\n    Split into words looking for acronyms and camelCase\n\n    [A-Z]+(?![a-z])\n    This part of the regular expression matches a sequence of one or more uppercase letters ([A-Z]+)\n    but only if they are not followed by a lowercase letter. The (?![a-z]) is a negative lookahead assertion,\n    meaning it checks for the absence of a lowercase letter ([a-z]) following the uppercase letters but does\n    not include it in the match. This effectively captures acronyms or any series of consecutive uppercase letters.\n\n    [A-Z]?[a-z]+\n    This part matches a single, optional, uppercase letter followed by one or more lowercase letters ([a-z]+).\n    This pattern is suitable for matching words in camelCase format, where a word begins with a lowercase letter\n    but can optionally start with an uppercase letter (like in the middle of camelCase).\n\n    \\d+\n    Matches a sequence of one or more digits into their own word\n    */\n    words = propertyName.match(/[A-Z]+(?![a-z])|[A-Z]?[a-z]+|\\d+/g) ?? [];\n  } else {\n    // fallback to splitting on capital letters\n    words = propertyName.split(/(?=[A-Z])/);\n  }\n\n  // Capitalize the first letter of each word\n  // Join together with spaces in between\n  // Then normalize whitespace to single space character\n  // For example, for property name \"birthDate\",\n  // the display name is \"Birth Date\".\n  return words.map(capitalizeDisplayWord).join(' ').replace('_', ' ').replace(/\\s+/g, ' ');\n}\n\nconst capitalizedWords = new Set(['ID', 'IP', 'PKCE', 'JWKS', 'URI', 'URL', 'OMB', 'UDI']);\n\nfunction capitalizeDisplayWord(word: string): string {\n  const upper = word.toUpperCase();\n  if (word === upper) {\n    return word;\n  }\n  if (capitalizedWords.has(upper)) {\n    return upper;\n  }\n  return upper.charAt(0) + word.slice(1);\n}\n\n/**\n * Returns an element definition by type and property name.\n * @param typeName - The type name.\n * @param propertyName - The property name.\n * @param profileUrl - (optional) The URL of the current resource profile\n * @returns The element definition if found.\n */\nexport function getElementDefinition(\n  typeName: string,\n  propertyName: string,\n  profileUrl?: string\n): InternalSchemaElement | undefined {\n  const typeSchema = tryGetDataType(typeName, profileUrl);\n  if (!typeSchema) {\n    return undefined;\n  }\n  return getElementDefinitionFromElements(typeSchema.elements, propertyName);\n}\n\n/**\n * Returns an element definition from mapping of elements by property name.\n * @param elements  - A mapping of property names to element definitions\n * @param propertyName - The property name of interest\n * @returns The element definition if found.\n */\nexport function getElementDefinitionFromElements(\n  elements: InternalTypeSchema['elements'],\n  propertyName: string\n): InternalSchemaElement | undefined {\n  // Always try to match the exact property name first\n  const simpleMatch = elements[propertyName] ?? elements[propertyName + '[x]'];\n  if (simpleMatch) {\n    return simpleMatch;\n  }\n\n  // The propertyName can be a \"choice of type\" property, such as \"value[x]\", but in resolved form \"valueString\".\n  // So we need to iterate through all the elements and find the one that matches.\n  // Try to split on each capital letter, and see if that matches an element.\n  for (let i = 0; i < propertyName.length; i++) {\n    const c = propertyName[i];\n    if (c >= 'A' && c <= 'Z') {\n      const testProperty = propertyName.slice(0, i) + '[x]';\n      const element = elements[testProperty];\n      if (element) {\n        return element;\n      }\n    }\n  }\n\n  // Otherwise, no matches.\n  return undefined;\n}\n\n/**\n * Returns true if the value is a TypedValue.\n * @param value - The unknown value to check.\n * @returns True if the value is a TypedValue.\n */\nexport function isTypedValue(value: unknown): value is TypedValue {\n  return !!(value && typeof value === 'object' && 'type' in value && 'value' in value);\n}\n\n/**\n * Type guard to validate that an object is a FHIR resource\n * @param value - The object to check\n * @param resourceType - Checks that the resource is of the given type\n * @returns True if the input is of type 'object' and contains property 'resourceType'\n */\nexport function isResource<T extends Resource>(value: unknown, resourceType?: T['resourceType']): value is T {\n  if (!value || typeof value !== 'object') {\n    return false;\n  }\n  if (!('resourceType' in value)) {\n    return false;\n  }\n  if (resourceType && value.resourceType !== resourceType) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * Type guard to validate that an object is a FHIR reference\n * @param value - The object to check\n * @returns True if the input is of type 'object' and contains property 'reference'\n */\nexport function isReference(value: unknown): value is Reference & { reference: string } {\n  return !!(value && typeof value === 'object' && 'reference' in value && typeof value.reference === 'string');\n}\n\n/**\n * Global schema singleton.\n */\nexport const globalSchema: IndexedStructureDefinition = { types: {} };\n\n/**\n * Output the string representation of a value, suitable for use as part of a search query.\n * @param v - The value to format as a string\n * @returns The stringified value\n */\nexport function stringifyTypedValue(v: TypedValue): string {\n  switch (v.type) {\n    case PropertyType.uuid:\n    case PropertyType.uri:\n    case PropertyType.url:\n    case PropertyType.string:\n    case PropertyType.oid:\n    case PropertyType.markdown:\n    case PropertyType.id:\n    case PropertyType.code:\n    case PropertyType.canonical:\n    case PropertyType.base64Binary:\n    case PropertyType.SystemString:\n    case PropertyType.date:\n    case PropertyType.dateTime:\n    case PropertyType.instant:\n      // many types are represented as string primitives\n      return v.value as string;\n    case PropertyType.Identifier:\n      return `${v.value.system ?? ''}|${v.value.value}`;\n    case PropertyType.Coding:\n      return stringifyCoding(v.value);\n    case PropertyType.CodeableConcept:\n      return (v.value as CodeableConcept).coding?.map(stringifyCoding).join(',') ?? v.value.text;\n    case PropertyType.HumanName:\n      if (v.value.text) {\n        return v.value.text;\n      }\n      return formatHumanName(v.value);\n    case PropertyType.unsignedInt:\n    case PropertyType.positiveInt:\n    case PropertyType.integer:\n    case PropertyType.decimal:\n      return (v.value as number).toString();\n    case PropertyType.boolean:\n      return v.value ? 'true' : 'false';\n    case PropertyType.Extension:\n      return v.value.url;\n    case PropertyType.ContactPoint:\n      return v.value.value;\n    case PropertyType.Quantity:\n    case PropertyType.Age:\n    case PropertyType.Count:\n    case PropertyType.Duration:\n      return `${v.value.value}|${v.value.system ?? ''}|${v.value.code ?? v.value.unit ?? ''}`;\n    case PropertyType.Reference:\n      return v.value.reference;\n    default:\n      if (isResourceWithId(v.value)) {\n        return getReferenceString(v.value);\n      }\n      return JSON.stringify(v);\n  }\n}\n\nfunction stringifyCoding(coding: Coding | undefined): string {\n  if (!coding) {\n    return '';\n  }\n  return `${coding.system ?? ''}|${coding.code}`;\n}\n", "export function parseDateString(str: string): string {\n  if (str.startsWith('T')) {\n    // If a time string,\n    // then normalize to full length.\n    return str + 'T00:00:00.000Z'.substring(str.length);\n  }\n\n  if (str.length <= 10) {\n    // If a local date (i.e., \"2021-01-01\"),\n    // then return as-is.\n    return str;\n  }\n\n  try {\n    // Try to normalize to UTC\n    return new Date(str).toISOString();\n  } catch (_err) {\n    // Fallback to original input\n    // This happens on unsupported time formats such as \"2021-01-01T12\"\n    return str;\n  }\n}\n", "import { Reference, Resource } from '@medplum/fhirtypes';\nimport { Atom, AtomContext } from '../fhirlexer/parse';\nimport { PropertyType, TypedValue, isResource } from '../types';\nimport { calculateAge, getExtension, isEmpty, resolveId } from '../utils';\nimport { DotAtom, SymbolAtom } from './atoms';\nimport { parseDateString } from './date';\nimport { booleanToTypedValue, fhirPathIs, isQuantity, removeDuplicates, toJsBoolean, toTypedValue } from './utils';\n\n/*\n * Collection of FHIRPath\n * See: https://hl7.org/fhirpath/#functions\n */\n\nexport type FhirPathFunction = (context: AtomContext, input: TypedValue[], ...args: Atom[]) => TypedValue[];\n\n/**\n * Temporary placholder for unimplemented methods.\n * @returns Empty array.\n */\nconst stub: FhirPathFunction = (): [] => [];\n\nexport const functions: Record<string, FhirPathFunction> = {\n  /*\n   * 5.1 Existence\n   * See: https://hl7.org/fhirpath/#existence\n   */\n\n  /**\n   * Returns true if the input collection is empty ({ }) and false otherwise.\n   *\n   * See: https://hl7.org/fhirpath/#empty-boolean\n   * @param _context - The evaluation context.\n   * @param input - The input collection.\n   * @returns True if the input collection is empty ({ }) and false otherwise.\n   */\n  empty: (_context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    return booleanToTypedValue(input.length === 0 || input.every((e) => isEmpty(e.value)));\n  },\n\n  /**\n   * Returns true if the input collection is not empty ({ }) and false otherwise.\n   *\n   * @param _context - The evaluation context.\n   * @param input - The input collection.\n   * @returns True if the input collection is not empty ({ }) and false otherwise.\n   */\n  hasValue: (_context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    return booleanToTypedValue(input.length !== 0);\n  },\n\n  /**\n   * Returns true if the collection has unknown elements, and false otherwise.\n   * This is the opposite of empty(), and as such is a shorthand for empty().not().\n   * If the input collection is empty ({ }), the result is false.\n   *\n   * The function can also take an optional criteria to be applied to the collection\n   * prior to the determination of the exists. In this case, the function is shorthand\n   * for where(criteria).exists().\n   *\n   * See: https://hl7.org/fhirpath/#existscriteria-expression-boolean\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @param criteria - The evaluation criteria.\n   * @returns True if the collection has unknown elements, and false otherwise.\n   */\n  exists: (context: AtomContext, input: TypedValue[], criteria?: Atom): TypedValue[] => {\n    if (criteria) {\n      return booleanToTypedValue(input.filter((e) => toJsBoolean(criteria.eval(context, [e]))).length > 0);\n    } else {\n      return booleanToTypedValue(input.length > 0 && input.every((e) => !isEmpty(e.value)));\n    }\n  },\n\n  /**\n   * Returns true if for every element in the input collection, criteria evaluates to true.\n   * Otherwise, the result is false.\n   *\n   * If the input collection is empty ({ }), the result is true.\n   *\n   * See: https://hl7.org/fhirpath/#allcriteria-expression-boolean\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @param criteria - The evaluation criteria.\n   * @returns True if for every element in the input collection, criteria evaluates to true.\n   */\n  all: (context: AtomContext, input: TypedValue[], criteria: Atom): TypedValue[] => {\n    return booleanToTypedValue(input.every((e) => toJsBoolean(criteria.eval(context, [e]))));\n  },\n\n  /**\n   * Takes a collection of Boolean values and returns true if all the items are true.\n   * If unknown items are false, the result is false.\n   * If the input is empty ({ }), the result is true.\n   *\n   * See: https://hl7.org/fhirpath/#alltrue-boolean\n   * @param _context - The evaluation context.\n   * @param input - The input collection.\n   * @returns True if all the items are true.\n   */\n  allTrue: (_context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    for (const value of input) {\n      if (!value.value) {\n        return booleanToTypedValue(false);\n      }\n    }\n    return booleanToTypedValue(true);\n  },\n\n  /**\n   * Takes a collection of Boolean values and returns true if unknown of the items are true.\n   * If all the items are false, or if the input is empty ({ }), the result is false.\n   *\n   * See: https://hl7.org/fhirpath/#anytrue-boolean\n   * @param _context - The evaluation context.\n   * @param input - The input collection.\n   * @returns True if unknown of the items are true.\n   */\n  anyTrue: (_context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    for (const value of input) {\n      if (value.value) {\n        return booleanToTypedValue(true);\n      }\n    }\n    return booleanToTypedValue(false);\n  },\n\n  /**\n   * Takes a collection of Boolean values and returns true if all the items are false.\n   * If unknown items are true, the result is false.\n   * If the input is empty ({ }), the result is true.\n   *\n   * See: https://hl7.org/fhirpath/#allfalse-boolean\n   * @param _context - The evaluation context.\n   * @param input - The input collection.\n   * @returns True if all the items are false.\n   */\n  allFalse: (_context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    for (const value of input) {\n      if (value.value) {\n        return booleanToTypedValue(false);\n      }\n    }\n    return booleanToTypedValue(true);\n  },\n\n  /**\n   * Takes a collection of Boolean values and returns true if unknown of the items are false.\n   * If all the items are true, or if the input is empty ({ }), the result is false.\n   *\n   * See: https://hl7.org/fhirpath/#anyfalse-boolean\n   * @param _context - The evaluation context.\n   * @param input - The input collection.\n   * @returns True if for every element in the input collection, criteria evaluates to true.\n   */\n  anyFalse: (_context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    for (const value of input) {\n      if (!value.value) {\n        return booleanToTypedValue(true);\n      }\n    }\n    return booleanToTypedValue(false);\n  },\n\n  /**\n   * Returns true if all items in the input collection are members of the collection passed\n   * as the other argument. Membership is determined using the = (Equals) (=) operation.\n   *\n   * Conceptually, this function is evaluated by testing each element in the input collection\n   * for membership in the other collection, with a default of true. This means that if the\n   * input collection is empty ({ }), the result is true, otherwise if the other collection\n   * is empty ({ }), the result is false.\n   *\n   * See: http://hl7.org/fhirpath/#subsetofother-collection-boolean\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @param other - The atom representing the collection of elements.\n   * @returns True if all items in the input collection are members of the other collection.\n   */\n  subsetOf: (context: AtomContext, input: TypedValue[], other: Atom): TypedValue[] => {\n    if (input.length === 0) {\n      return booleanToTypedValue(true);\n    }\n\n    const otherArray = other.eval(context, getRootInput(context));\n    if (otherArray.length === 0) {\n      return booleanToTypedValue(false);\n    }\n\n    return booleanToTypedValue(input.every((e) => otherArray.some((o) => o.value === e.value)));\n  },\n\n  /**\n   * Returns true if all items in the collection passed as the other argument are members of\n   * the input collection. Membership is determined using the = (Equals) (=) operation.\n   *\n   * Conceptually, this function is evaluated by testing each element in the other collection\n   * for membership in the input collection, with a default of true. This means that if the\n   * other collection is empty ({ }), the result is true, otherwise if the input collection\n   * is empty ({ }), the result is false.\n   *\n   * See: http://hl7.org/fhirpath/#supersetofother-collection-boolean\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @param other - The atom representing the collection of elements.\n   * @returns True if all items in the other collection are members of the input collection.\n   */\n  supersetOf: (context: AtomContext, input: TypedValue[], other: Atom): TypedValue[] => {\n    const otherArray = other.eval(context, getRootInput(context));\n    if (otherArray.length === 0) {\n      return booleanToTypedValue(true);\n    }\n\n    if (input.length === 0) {\n      return booleanToTypedValue(false);\n    }\n\n    return booleanToTypedValue(otherArray.every((e) => input.some((o) => o.value === e.value)));\n  },\n\n  /**\n   * Returns the integer count of the number of items in the input collection.\n   * Returns 0 when the input collection is empty.\n   *\n   * See: https://hl7.org/fhirpath/#count-integer\n   * @param _context - The evaluation context.\n   * @param input - The input collection.\n   * @returns The integer count of the number of items in the input collection.\n   */\n  count: (_context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    return [{ type: PropertyType.integer, value: input.length }];\n  },\n\n  /**\n   * Returns a collection containing only the unique items in the input collection.\n   * To determine whether two items are the same, the = (Equals) (=) operator is used,\n   * as defined below.\n   *\n   * If the input collection is empty ({ }), the result is empty.\n   *\n   * Note that the order of elements in the input collection is not guaranteed to be\n   * preserved in the result.\n   *\n   * See: https://hl7.org/fhirpath/#distinct-collection\n   * @param _context - The evaluation context.\n   * @param input - The input collection.\n   * @returns The integer count of the number of items in the input collection.\n   */\n  distinct: (_context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    const result: TypedValue[] = [];\n    for (const value of input) {\n      if (!result.some((e) => e.value === value.value)) {\n        result.push(value);\n      }\n    }\n    return result;\n  },\n\n  /**\n   * Returns true if all the items in the input collection are distinct.\n   * To determine whether two items are distinct, the = (Equals) (=) operator is used,\n   * as defined below.\n   *\n   * See: https://hl7.org/fhirpath/#isdistinct-boolean\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @returns The integer count of the number of items in the input collection.\n   */\n  isDistinct: (context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    return booleanToTypedValue(input.length === functions.distinct(context, input).length);\n  },\n\n  /*\n   * 5.2 Filtering and projection\n   */\n\n  /**\n   * Returns a collection containing only those elements in the input collection\n   * for which the stated criteria expression evaluates to true.\n   * Elements for which the expression evaluates to false or empty ({ }) are not\n   * included in the result.\n   *\n   * If the input collection is empty ({ }), the result is empty.\n   *\n   * If the result of evaluating the condition is other than a single boolean value,\n   * the evaluation will end and signal an error to the calling environment,\n   * consistent with singleton evaluation of collections behavior.\n   *\n   * See: https://hl7.org/fhirpath/#wherecriteria-expression-collection\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @param criteria - The condition atom.\n   * @returns A collection containing only those elements in the input collection for which the stated criteria expression evaluates to true.\n   */\n  where: (context: AtomContext, input: TypedValue[], criteria: Atom): TypedValue[] => {\n    return input.filter((e) => toJsBoolean(criteria.eval(context, [e])));\n  },\n\n  /**\n   * Evaluates the projection expression for each item in the input collection.\n   * The result of each evaluation is added to the output collection. If the\n   * evaluation results in a collection with multiple items, all items are added\n   * to the output collection (collections resulting from evaluation of projection\n   * are flattened). This means that if the evaluation for an element results in\n   * the empty collection ({ }), no element is added to the result, and that if\n   * the input collection is empty ({ }), the result is empty as well.\n   *\n   * See: http://hl7.org/fhirpath/#selectprojection-expression-collection\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @param criteria - The condition atom.\n   * @returns A collection containing only those elements in the input collection for which the stated criteria expression evaluates to true.\n   */\n  select: (context: AtomContext, input: TypedValue[], criteria: Atom): TypedValue[] => {\n    return input.map((e) => criteria.eval({ parent: context, variables: { $this: e } }, [e])).flat();\n  },\n\n  /**\n   * A version of select that will repeat the projection and add it to the output\n   * collection, as long as the projection yields new items (as determined by\n   * the = (Equals) (=) operator).\n   *\n   * See: http://hl7.org/fhirpath/#repeatprojection-expression-collection\n   */\n  repeat: stub,\n\n  /**\n   * Returns a collection that contains all items in the input collection that\n   * are of the given type or a subclass thereof. If the input collection is\n   * empty ({ }), the result is empty. The type argument is an identifier that\n   * must resolve to the name of a type in a model\n   *\n   * See: http://hl7.org/fhirpath/#oftypetype-type-specifier-collection\n   * @param _context - The evaluation context.\n   * @param input - The input collection.\n   * @param criteria - The condition atom.\n   * @returns A collection containing only those elements in the input collection that are of the given type or a subclass thereof.\n   */\n  ofType: (_context: AtomContext, input: TypedValue[], criteria: Atom): TypedValue[] => {\n    return input.filter((e) => e.type === (criteria as SymbolAtom).name);\n  },\n\n  /*\n   * 5.3 Subsetting\n   */\n\n  /**\n   * Will return the single item in the input if there is just one item.\n   * If the input collection is empty ({ }), the result is empty.\n   * If there are multiple items, an error is signaled to the evaluation environment.\n   * This function is useful for ensuring that an error is returned if an assumption\n   * about cardinality is violated at run-time.\n   *\n   * See: https://hl7.org/fhirpath/#single-collection\n   * @param _context - The evaluation context.\n   * @param input - The input collection.\n   * @returns The single item in the input if there is just one item.\n   */\n  single: (_context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    if (input.length > 1) {\n      throw new Error('Expected input length one for single()');\n    }\n    return input.length === 0 ? [] : input.slice(0, 1);\n  },\n\n  /**\n   * Returns a collection containing only the first item in the input collection.\n   * This function is equivalent to item[0], so it will return an empty collection if the input collection has no items.\n   *\n   * See: https://hl7.org/fhirpath/#first-collection\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @returns A collection containing only the first item in the input collection.\n   */\n  first: (context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    return input.length === 0 ? [] : input.slice(0, 1);\n  },\n\n  /**\n   * Returns a collection containing only the last item in the input collection.\n   * Will return an empty collection if the input collection has no items.\n   *\n   * See: https://hl7.org/fhirpath/#last-collection\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @returns A collection containing only the last item in the input collection.\n   */\n  last: (context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    return input.length === 0 ? [] : input.slice(input.length - 1, input.length);\n  },\n\n  /**\n   * Returns a collection containing all but the first item in the input collection.\n   * Will return an empty collection if the input collection has no items, or only one item.\n   *\n   * See: https://hl7.org/fhirpath/#tail-collection\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @returns A collection containing all but the first item in the input collection.\n   */\n  tail: (context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    return input.length === 0 ? [] : input.slice(1, input.length);\n  },\n\n  /**\n   * Returns a collection containing all but the first num items in the input collection.\n   * Will return an empty collection if there are no items remaining after the\n   * indicated number of items have been skipped, or if the input collection is empty.\n   * If num is less than or equal to zero, the input collection is simply returned.\n   *\n   * See: https://hl7.org/fhirpath/#skipnum-integer-collection\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @param num - The atom representing the number of elements to skip.\n   * @returns A collection containing all but the first item in the input collection.\n   */\n  skip: (context: AtomContext, input: TypedValue[], num: Atom): TypedValue[] => {\n    const numValue = num.eval(context, input)[0]?.value;\n    if (typeof numValue !== 'number') {\n      throw new Error('Expected a number for skip(num)');\n    }\n    if (numValue >= input.length) {\n      return [];\n    }\n    if (numValue <= 0) {\n      return input;\n    }\n    return input.slice(numValue, input.length);\n  },\n\n  /**\n   * Returns a collection containing the first num items in the input collection,\n   * or less if there are less than num items.\n   * If num is less than or equal to 0, or if the input collection is empty ({ }),\n   * take returns an empty collection.\n   *\n   * See: https://hl7.org/fhirpath/#takenum-integer-collection\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @param num - The atom representing the number of elements to take.\n   * @returns A collection containing the first num items in the input collection.\n   */\n  take: (context: AtomContext, input: TypedValue[], num: Atom): TypedValue[] => {\n    const numValue = num.eval(context, input)[0]?.value;\n    if (typeof numValue !== 'number') {\n      throw new Error('Expected a number for take(num)');\n    }\n    if (numValue >= input.length) {\n      return input;\n    }\n    if (numValue <= 0) {\n      return [];\n    }\n    return input.slice(0, numValue);\n  },\n\n  /**\n   * Returns the set of elements that are in both collections.\n   * Duplicate items will be eliminated by this function.\n   * Order of items is not guaranteed to be preserved in the result of this function.\n   *\n   * See: http://hl7.org/fhirpath/#intersectother-collection-collection\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @param other - The atom representing the collection of elements to intersect.\n   * @returns A collection containing the elements that are in both collections.\n   */\n  intersect: (context: AtomContext, input: TypedValue[], other: Atom): TypedValue[] => {\n    if (!other) {\n      return input;\n    }\n    const otherArray = other.eval(context, getRootInput(context));\n    const result: TypedValue[] = [];\n    for (const value of input) {\n      if (!result.some((e) => e.value === value.value) && otherArray.some((e) => e.value === value.value)) {\n        result.push(value);\n      }\n    }\n    return result;\n  },\n\n  /**\n   * Returns the set of elements that are not in the other collection.\n   * Duplicate items will not be eliminated by this function, and order will be preserved.\n   *\n   * e.g. (1 | 2 | 3).exclude(2) returns (1 | 3).\n   *\n   * See: http://hl7.org/fhirpath/#excludeother-collection-collection\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @param other - The atom representing the collection of elements to exclude.\n   * @returns A collection containing the elements that are in the input collection but not the other collection.\n   */\n  exclude: (context: AtomContext, input: TypedValue[], other: Atom): TypedValue[] => {\n    if (!other) {\n      return input;\n    }\n    const otherArray = other.eval(context, getRootInput(context));\n    const result: TypedValue[] = [];\n    for (const value of input) {\n      if (!otherArray.some((e) => e.value === value.value)) {\n        result.push(value);\n      }\n    }\n    return result;\n  },\n\n  /*\n   * 5.4. Combining\n   *\n   * See: https://hl7.org/fhirpath/#combining\n   */\n\n  /**\n   * Merge the two collections into a single collection,\n   * eliminating unknown duplicate values (using = (Equals) (=) to determine equality).\n   * There is no expectation of order in the resulting collection.\n   *\n   * In other words, this function returns the distinct list of elements from both inputs.\n   *\n   * See: http://hl7.org/fhirpath/#unionother-collection\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @param other - The atom representing the collection of elements to merge.\n   * @returns A collection containing the elements that represent the union of both collections.\n   */\n  union: (context: AtomContext, input: TypedValue[], other: Atom): TypedValue[] => {\n    if (!other) {\n      return input;\n    }\n    const otherArray = other.eval(context, getRootInput(context));\n    return removeDuplicates([...input, ...otherArray]);\n  },\n\n  /**\n   * Merge the input and other collections into a single collection\n   * without eliminating duplicate values. Combining an empty collection\n   * with a non-empty collection will return the non-empty collection.\n   *\n   * There is no expectation of order in the resulting collection.\n   *\n   * See: http://hl7.org/fhirpath/#combineother-collection-collection\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @param other - The atom representing the collection of elements to merge.\n   * @returns A collection containing the elements that represent the combination of both collections including duplicates.\n   */\n  combine: (context: AtomContext, input: TypedValue[], other: Atom): TypedValue[] => {\n    if (!other) {\n      return input;\n    }\n    const otherArray = other.eval(context, getRootInput(context));\n    return [...input, ...otherArray];\n  },\n\n  /**\n   * Returns true if the input is a value HTML element.\n   *\n   * See: https://hl7.org/fhir/fhirpath.html#variables\n   * @param _context - The evaluation context.\n   * @param _input - The input collection.\n   * @param _other - The atom representing the collection of elements to validate the html.\n   * @returns A collection of boolean values\n   */\n  htmlChecks: (_context: AtomContext, _input: TypedValue[], _other: Atom): TypedValue[] => {\n    return [toTypedValue(true)];\n  },\n\n  /*\n   * 5.5. Conversion\n   *\n   * See: https://hl7.org/fhirpath/#conversion\n   */\n\n  /**\n   * The iif function in FHIRPath is an immediate if,\n   * also known as a conditional operator (such as C\u2019s ? : operator).\n   *\n   * The criterion expression is expected to evaluate to a Boolean.\n   *\n   * If criterion is true, the function returns the value of the true-result argument.\n   *\n   * If criterion is false or an empty collection, the function returns otherwise-result,\n   * unless the optional otherwise-result is not given, in which case the function returns an empty collection.\n   *\n   * Note that short-circuit behavior is expected in this function. In other words,\n   * true-result should only be evaluated if the criterion evaluates to true,\n   * and otherwise-result should only be evaluated otherwise. For implementations,\n   * this means delaying evaluation of the arguments.\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @param criterion - The atom representing the conditional.\n   * @param trueResult - The atom to be used if the conditional evaluates to true.\n   * @param otherwiseResult - Optional atom to be used if the conditional evaluates to false.\n   * @returns The result of the iif function.\n   */\n  iif: (\n    context: AtomContext,\n    input: TypedValue[],\n    criterion: Atom,\n    trueResult: Atom,\n    otherwiseResult?: Atom\n  ): TypedValue[] => {\n    const evalResult = criterion.eval(context, input);\n    if (evalResult.length > 1 || (evalResult.length === 1 && typeof evalResult[0].value !== 'boolean')) {\n      throw new Error('Expected criterion to evaluate to a Boolean');\n    }\n\n    if (toJsBoolean(evalResult)) {\n      return trueResult.eval(context, input);\n    }\n\n    if (otherwiseResult) {\n      return otherwiseResult.eval(context, input);\n    }\n\n    return [];\n  },\n\n  /**\n   * Converts an input collection to a boolean.\n   *\n   * If the input collection contains a single item, this function will return a single boolean if:\n   *   1) the item is a Boolean\n   *   2) the item is an Integer and is equal to one of the possible integer representations of Boolean values\n   *   3) the item is a Decimal that is equal to one of the possible decimal representations of Boolean values\n   *   4) the item is a String that is equal to one of the possible string representations of Boolean values\n   *\n   * If the item is not one the above types, or the item is a String, Integer, or Decimal, but is not equal to one of the possible values convertible to a Boolean, the result is empty.\n   *\n   * See: https://hl7.org/fhirpath/#toboolean-boolean\n   * @param _context - The evaluation context.\n   * @param input - The input collection.\n   * @returns The input converted to boolean value.\n   */\n  toBoolean: (_context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    if (input.length === 0) {\n      return [];\n    }\n    const [{ value }] = validateInput(input, 1);\n    if (typeof value === 'boolean') {\n      return [{ type: PropertyType.boolean, value }];\n    }\n    if (typeof value === 'number') {\n      if (value === 0 || value === 1) {\n        return booleanToTypedValue(!!value);\n      }\n    }\n    if (typeof value === 'string') {\n      const lowerStr = value.toLowerCase();\n      if (['true', 't', 'yes', 'y', '1', '1.0'].includes(lowerStr)) {\n        return booleanToTypedValue(true);\n      }\n      if (['false', 'f', 'no', 'n', '0', '0.0'].includes(lowerStr)) {\n        return booleanToTypedValue(false);\n      }\n    }\n    return [];\n  },\n\n  /**\n   * If the input collection contains a single item, this function will return true if:\n   *   1) the item is a Boolean\n   *   2) the item is an Integer that is equal to one of the possible integer representations of Boolean values\n   *   3) the item is a Decimal that is equal to one of the possible decimal representations of Boolean values\n   *   4) the item is a String that is equal to one of the possible string representations of Boolean values\n   *\n   * If the item is not one of the above types, or the item is a String, Integer, or Decimal, but is not equal to one of the possible values convertible to a Boolean, the result is false.\n   *\n   * Possible values for Integer, Decimal, and String are described in the toBoolean() function.\n   *\n   * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.\n   *\n   * If the input collection is empty, the result is empty.\n   *\n   * See: http://hl7.org/fhirpath/#convertstoboolean-boolean\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @returns True if the input can be converted to boolean.\n   */\n  convertsToBoolean: (context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    if (input.length === 0) {\n      return [];\n    }\n    return booleanToTypedValue(functions.toBoolean(context, input).length === 1);\n  },\n\n  /**\n   * Returns the integer representation of the input.\n   *\n   * If the input collection contains a single item, this function will return a single integer if:\n   *   1) the item is an Integer\n   *   2) the item is a String and is convertible to an integer\n   *   3) the item is a Boolean, where true results in a 1 and false results in a 0.\n   *\n   * If the item is not one the above types, the result is empty.\n   *\n   * If the item is a String, but the string is not convertible to an integer (using the regex format (\\\\+|-)?\\d+), the result is empty.\n   *\n   * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.\n   *\n   * If the input collection is empty, the result is empty.\n   *\n   * See: https://hl7.org/fhirpath/#tointeger-integer\n   * @param _context - The evaluation context.\n   * @param input - The input collection.\n   * @returns The string representation of the input.\n   */\n  toInteger: (_context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    if (input.length === 0) {\n      return [];\n    }\n    const [{ value }] = validateInput(input, 1);\n    if (typeof value === 'number') {\n      return [{ type: PropertyType.integer, value }];\n    }\n    if (typeof value === 'string' && /^[+-]?\\d+$/.exec(value)) {\n      return [{ type: PropertyType.integer, value: parseInt(value, 10) }];\n    }\n    if (typeof value === 'boolean') {\n      return [{ type: PropertyType.integer, value: value ? 1 : 0 }];\n    }\n    return [];\n  },\n\n  /**\n   * Returns true if the input can be converted to string.\n   *\n   * If the input collection contains a single item, this function will return true if:\n   *   1) the item is an Integer\n   *   2) the item is a String and is convertible to an Integer\n   *   3) the item is a Boolean\n   *   4) If the item is not one of the above types, or the item is a String, but is not convertible to an Integer (using the regex format (\\\\+|-)?\\d+), the result is false.\n   *\n   * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.\n   *\n   * If the input collection is empty, the result is empty.\n   *\n   * See: https://hl7.org/fhirpath/#convertstointeger-boolean\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @returns True if the input can be converted to an integer.\n   */\n  convertsToInteger: (context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    if (input.length === 0) {\n      return [];\n    }\n    return booleanToTypedValue(functions.toInteger(context, input).length === 1);\n  },\n\n  /**\n   * If the input collection contains a single item, this function will return a single date if:\n   *   1) the item is a Date\n   *   2) the item is a DateTime\n   *   3) the item is a String and is convertible to a Date\n   *\n   * If the item is not one of the above types, the result is empty.\n   *\n   * If the item is a String, but the string is not convertible to a Date (using the format YYYY-MM-DD), the result is empty.\n   *\n   * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.\n   *\n   * If the input collection is empty, the result is empty.\n   *\n   * See: https://hl7.org/fhirpath/#todate-date\n   * @param _context - The evaluation context.\n   * @param input - The input collection.\n   * @returns The value converted to a date if possible; otherwise empty array.\n   */\n  toDate: (_context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    if (input.length === 0) {\n      return [];\n    }\n    const [{ value }] = validateInput(input, 1);\n    if (typeof value === 'string' && /^\\d{4}(-\\d{2}(-\\d{2})?)?/.exec(value)) {\n      return [{ type: PropertyType.date, value: parseDateString(value) }];\n    }\n    return [];\n  },\n\n  /**\n   * If the input collection contains a single item, this function will return true if:\n   *   1) the item is a Date\n   *   2) the item is a DateTime\n   *   3) the item is a String and is convertible to a Date\n   *\n   * If the item is not one of the above types, or is not convertible to a Date (using the format YYYY-MM-DD), the result is false.\n   *\n   * If the item contains a partial date (e.g. '2012-01'), the result is a partial date.\n   *\n   * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.\n   *\n   * If the input collection is empty, the result is empty.\n   *\n   * See: https://hl7.org/fhirpath/#convertstodate-boolean\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @returns True if the item can be converted to a date.\n   */\n  convertsToDate: (context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    if (input.length === 0) {\n      return [];\n    }\n    return booleanToTypedValue(functions.toDate(context, input).length === 1);\n  },\n\n  /**\n   * If the input collection contains a single item, this function will return a single datetime if:\n   *   1) the item is a DateTime\n   *   2) the item is a Date, in which case the result is a DateTime with the year, month, and day of the Date, and the time components empty (not set to zero)\n   *   3) the item is a String and is convertible to a DateTime\n   *\n   * If the item is not one of the above types, the result is empty.\n   *\n   * If the item is a String, but the string is not convertible to a DateTime (using the format YYYY-MM-DDThh:mm:ss.fff(+|-)hh:mm), the result is empty.\n   *\n   * If the item contains a partial datetime (e.g. '2012-01-01T10:00'), the result is a partial datetime.\n   *\n   * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.\n   *\n   * If the input collection is empty, the result is empty.\n   *\n   * See: https://hl7.org/fhirpath/#todatetime-datetime\n   * @param _context - The evaluation context.\n   * @param input - The input collection.\n   * @returns The value converted to a datetime if possible; otherwise empty array.\n   */\n  toDateTime: (_context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    if (input.length === 0) {\n      return [];\n    }\n    const [{ value }] = validateInput(input, 1);\n    if (typeof value === 'string' && /^\\d{4}(-\\d{2}(-\\d{2})?)?/.exec(value)) {\n      return [{ type: PropertyType.dateTime, value: parseDateString(value) }];\n    }\n    return [];\n  },\n\n  /**\n   * If the input collection contains a single item, this function will return true if:\n   *   1) the item is a DateTime\n   *   2) the item is a Date\n   *   3) the item is a String and is convertible to a DateTime\n   *\n   * If the item is not one of the above types, or is not convertible to a DateTime (using the format YYYY-MM-DDThh:mm:ss.fff(+|-)hh:mm), the result is false.\n   *\n   * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.\n   *\n   * If the input collection is empty, the result is empty.\n   *\n   * See: https://hl7.org/fhirpath/#convertstodatetime-boolean\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @returns True if the item can be converted to a dateTime.\n   */\n  convertsToDateTime: (context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    if (input.length === 0) {\n      return [];\n    }\n    return booleanToTypedValue(functions.toDateTime(context, input).length === 1);\n  },\n\n  /**\n   * If the input collection contains a single item, this function will return a single decimal if:\n   *   1) the item is an Integer or Decimal\n   *   2) the item is a String and is convertible to a Decimal\n   *   3) the item is a Boolean, where true results in a 1.0 and false results in a 0.0.\n   *   4) If the item is not one of the above types, the result is empty.\n   *\n   * If the item is a String, but the string is not convertible to a Decimal (using the regex format (\\\\+|-)?\\d+(\\.\\d+)?), the result is empty.\n   *\n   * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.\n   *\n   * If the input collection is empty, the result is empty.\n   *\n   * See: https://hl7.org/fhirpath/#decimal-conversion-functions\n   * @param _context - The evaluation context.\n   * @param input - The input collection.\n   * @returns The value converted to a decimal if possible; otherwise empty array.\n   */\n  toDecimal: (_context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    if (input.length === 0) {\n      return [];\n    }\n    const [{ value }] = validateInput(input, 1);\n    if (typeof value === 'number') {\n      return [{ type: PropertyType.decimal, value }];\n    }\n    if (typeof value === 'string' && /^-?\\d{1,9}(\\.\\d{1,9})?$/.exec(value)) {\n      return [{ type: PropertyType.decimal, value: parseFloat(value) }];\n    }\n    if (typeof value === 'boolean') {\n      return [{ type: PropertyType.decimal, value: value ? 1 : 0 }];\n    }\n    return [];\n  },\n\n  /**\n   * If the input collection contains a single item, this function will true if:\n   *   1) the item is an Integer or Decimal\n   *   2) the item is a String and is convertible to a Decimal\n   *   3) the item is a Boolean\n   *\n   * If the item is not one of the above types, or is not convertible to a Decimal (using the regex format (\\\\+|-)?\\d+(\\.\\d+)?), the result is false.\n   *\n   * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.\n   *\n   * If the input collection is empty, the result is empty.\n   *\n   * See: https://hl7.org/fhirpath/#convertstodecimal-boolean\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @returns The value converted to a decimal if possible; otherwise empty array.\n   */\n  convertsToDecimal: (context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    if (input.length === 0) {\n      return [];\n    }\n    return booleanToTypedValue(functions.toDecimal(context, input).length === 1);\n  },\n\n  /**\n   * If the input collection contains a single item, this function will return a single quantity if:\n   *   1) the item is an Integer, or Decimal, where the resulting quantity will have the default unit ('1')\n   *   2) the item is a Quantity\n   *   3) the item is a String and is convertible to a Quantity\n   *   4) the item is a Boolean, where true results in the quantity 1.0 '1', and false results in the quantity 0.0 '1'\n   *\n   * If the item is not one of the above types, the result is empty.\n   *\n   * See: https://hl7.org/fhirpath/#quantity-conversion-functions\n   * @param _context - The evaluation context.\n   * @param input - The input collection.\n   * @returns The value converted to a quantity if possible; otherwise empty array.\n   */\n  toQuantity: (_context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    if (input.length === 0) {\n      return [];\n    }\n    const [{ value }] = validateInput(input, 1);\n    if (isQuantity(value)) {\n      return [{ type: PropertyType.Quantity, value }];\n    }\n    if (typeof value === 'number') {\n      return [{ type: PropertyType.Quantity, value: { value, unit: '1' } }];\n    }\n    if (typeof value === 'string' && /^-?\\d{1,9}(\\.\\d{1,9})?/.exec(value)) {\n      return [{ type: PropertyType.Quantity, value: { value: parseFloat(value), unit: '1' } }];\n    }\n    if (typeof value === 'boolean') {\n      return [{ type: PropertyType.Quantity, value: { value: value ? 1 : 0, unit: '1' } }];\n    }\n    return [];\n  },\n\n  /**\n   * If the input collection contains a single item, this function will return true if:\n   *   1) the item is an Integer, Decimal, or Quantity\n   *   2) the item is a String that is convertible to a Quantity\n   *   3) the item is a Boolean\n   *\n   * If the item is not one of the above types, or is not convertible to a Quantity using the following regex format:\n   *\n   *     (?'value'(\\+|-)?\\d+(\\.\\d+)?)\\s*('(?'unit'[^']+)'|(?'time'[a-zA-Z]+))?\n   *\n   * then the result is false.\n   *\n   * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.\n   *\n   * If the input collection is empty, the result is empty.\n   *\n   * If the unit argument is provided, it must be the string representation of a UCUM code (or a FHIRPath calendar duration keyword), and is used to determine whether the input quantity can be converted to the given unit, according to the unit conversion rules specified by UCUM. If the input quantity can be converted, the result is true, otherwise, the result is false.\n   *\n   * See: https://hl7.org/fhirpath/#convertstoquantityunit-string-boolean\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @returns True if the item can be converted to a quantity.\n   */\n  convertsToQuantity: (context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    if (input.length === 0) {\n      return [];\n    }\n    return booleanToTypedValue(functions.toQuantity(context, input).length === 1);\n  },\n\n  /**\n   * Returns the string representation of the input.\n   *\n   * If the input collection contains a single item, this function will return a single String if:\n   *\n   *  1) the item in the input collection is a String\n   *  2) the item in the input collection is an Integer, Decimal, Date, Time, DateTime, or Quantity the output will contain its String representation\n   *  3) the item is a Boolean, where true results in 'true' and false in 'false'.\n   *\n   * If the item is not one of the above types, the result is false.\n   *\n   * See: https://hl7.org/fhirpath/#tostring-string\n   * @param _context - The evaluation context.\n   * @param input - The input collection.\n   * @returns The string representation of the input.\n   */\n  toString: (_context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    if (input.length === 0) {\n      return [];\n    }\n    const [{ value }] = validateInput(input, 1);\n    if (value === null || value === undefined) {\n      return [];\n    }\n    if (isQuantity(value)) {\n      return [{ type: PropertyType.string, value: `${value.value} '${value.unit}'` }];\n    }\n    return [{ type: PropertyType.string, value: (value as boolean | number | string).toString() }];\n  },\n\n  /**\n   * Returns true if the input can be converted to string.\n   *\n   * If the input collection contains a single item, this function will return true if:\n   *   1) the item is a String\n   *   2) the item is an Integer, Decimal, Date, Time, or DateTime\n   *   3) the item is a Boolean\n   *   4) the item is a Quantity\n   *\n   * If the item is not one of the above types, the result is false.\n   *\n   * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.\n   *\n   * If the input collection is empty, the result is empty.\n   *\n   * See: https://hl7.org/fhirpath/#tostring-string\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @returns True if the item can be converted to a string\n   */\n  convertsToString: (context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    if (input.length === 0) {\n      return [];\n    }\n    return booleanToTypedValue((functions.toString as unknown as FhirPathFunction)(context, input).length === 1);\n  },\n\n  /**\n   * If the input collection contains a single item, this function will return a single time if:\n   *   1) the item is a Time\n   *   2) the item is a String and is convertible to a Time\n   *\n   * If the item is not one of the above types, the result is empty.\n   *\n   * If the item is a String, but the string is not convertible to a Time (using the format hh:mm:ss.fff(+|-)hh:mm), the result is empty.\n   *\n   * If the item contains a partial time (e.g. '10:00'), the result is a partial time.\n   *\n   * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.\n   *\n   * If the input collection is empty, the result is empty.\n   *\n   * See: https://hl7.org/fhirpath/#totime-time\n   * @param _context - The evaluation context.\n   * @param input - The input collection.\n   * @returns The value converted to a time if possible; otherwise empty array.\n   */\n  toTime: (_context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    if (input.length === 0) {\n      return [];\n    }\n    const [{ value }] = validateInput(input, 1);\n    if (typeof value === 'string') {\n      const match = /^T?(\\d{2}(:\\d{2}(:\\d{2})?)?)/.exec(value);\n      if (match) {\n        return [{ type: PropertyType.time, value: parseDateString('T' + match[1]) }];\n      }\n    }\n    return [];\n  },\n\n  /**\n   * If the input collection contains a single item, this function will return true if:\n   *   1) the item is a Time\n   *   2) the item is a String and is convertible to a Time\n   *\n   * If the item is not one of the above types, or is not convertible to a Time (using the format hh:mm:ss.fff(+|-)hh:mm), the result is false.\n   *\n   * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.\n   *\n   * If the input collection is empty, the result is empty.\n   *\n   * See: https://hl7.org/fhirpath/#convertstotime-boolean\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @returns True if the item can be converted to a time.\n   */\n  convertsToTime: (context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    if (input.length === 0) {\n      return [];\n    }\n    return booleanToTypedValue(functions.toTime(context, input).length === 1);\n  },\n\n  /*\n   * 5.6. String Manipulation.\n   *\n   * See: https://hl7.org/fhirpath/#string-manipulation\n   */\n\n  /**\n   * Returns the 0-based index of the first position substring is found in the input string, or -1 if it is not found.\n   *\n   * If substring is an empty string (''), the function returns 0.\n   *\n   * If the input or substring is empty ({ }), the result is empty ({ }).\n   *\n   * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.\n   *\n   * See: https://hl7.org/fhirpath/#indexofsubstring-string-integer\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @param substringAtom - The substring to search for.\n   * @returns The index of the substring.\n   */\n  indexOf: (context: AtomContext, input: TypedValue[], substringAtom: Atom): TypedValue[] => {\n    return applyStringFunc((str, substring) => str.indexOf(substring as string), context, input, substringAtom);\n  },\n\n  /**\n   * Returns the part of the string starting at position start (zero-based). If length is given, will return at most length number of characters from the input string.\n   *\n   * If start lies outside the length of the string, the function returns empty ({ }). If there are less remaining characters in the string than indicated by length, the function returns just the remaining characters.\n   *\n   * If the input or start is empty, the result is empty.\n   *\n   * If an empty length is provided, the behavior is the same as if length had not been provided.\n   *\n   * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @param startAtom - The start index atom.\n   * @param lengthAtom - Optional length atom.\n   * @returns The substring.\n   */\n  substring: (context: AtomContext, input: TypedValue[], startAtom: Atom, lengthAtom?: Atom): TypedValue[] => {\n    return applyStringFunc(\n      (str, start, length) => {\n        const startIndex = start as number;\n        const endIndex = length ? startIndex + (length as number) : str.length;\n        return startIndex < 0 || startIndex >= str.length ? undefined : str.substring(startIndex, endIndex);\n      },\n      context,\n      input,\n      startAtom,\n      lengthAtom\n    );\n  },\n\n  /**\n   * Returns true when the input string starts with the given prefix.\n   *\n   * If prefix is the empty string (''), the result is true.\n   *\n   * If the input collection is empty, the result is empty.\n   *\n   * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.\n   *\n   * See: https://hl7.org/fhirpath/#startswithprefix-string-boolean\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @param prefixAtom - The prefix substring to test.\n   * @returns True if the input string starts with the given prefix string.\n   */\n  startsWith: (context: AtomContext, input: TypedValue[], prefixAtom: Atom): TypedValue[] => {\n    return applyStringFunc((str, prefix) => str.startsWith(prefix as string), context, input, prefixAtom);\n  },\n\n  /**\n   * Returns true when the input string ends with the given suffix.\n   *\n   * If suffix is the empty string (''), the result is true.\n   *\n   * If the input collection is empty, the result is empty.\n   *\n   * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.\n   *\n   * See: https://hl7.org/fhirpath/#endswithsuffix-string-boolean\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @param suffixAtom - The suffix substring to test.\n   * @returns True if the input string ends with the given suffix string.\n   */\n  endsWith: (context: AtomContext, input: TypedValue[], suffixAtom: Atom): TypedValue[] => {\n    return applyStringFunc((str, suffix) => str.endsWith(suffix as string), context, input, suffixAtom);\n  },\n\n  /**\n   * Returns true when the given substring is a substring of the input string.\n   *\n   * If substring is the empty string (''), the result is true.\n   *\n   * If the input collection is empty, the result is empty.\n   *\n   * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.\n   *\n   * See: https://hl7.org/fhirpath/#containssubstring-string-boolean\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @param substringAtom - The substring to test.\n   * @returns True if the input string contains the given substring.\n   */\n  contains: (context: AtomContext, input: TypedValue[], substringAtom: Atom): TypedValue[] => {\n    return applyStringFunc((str, substring) => str.includes(substring as string), context, input, substringAtom);\n  },\n\n  /**\n   * Returns the input string with all characters converted to upper case.\n   * If the input collection is empty, the result is empty.\n   *\n   * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.\n   *\n   * See: https://hl7.org/fhirpath/#upper-string\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @returns The string converted to upper case.\n   */\n  upper: (context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    return applyStringFunc((str) => str.toUpperCase(), context, input);\n  },\n\n  /**\n   * Returns the input string with all characters converted to lower case.\n   *\n   * If the input collection is empty, the result is empty.\n   *\n   * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.\n   *\n   * See: https://hl7.org/fhirpath/#lower-string\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @returns The string converted to lower case.\n   */\n  lower: (context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    return applyStringFunc((str) => str.toLowerCase(), context, input);\n  },\n\n  /**\n   * Returns the input string with all instances of pattern replaced with substitution. If the substitution is the empty string (''),\n   * instances of pattern are removed from the result. If pattern is the empty string (''), every character in the input string is\n   * surrounded by the substitution, e.g. 'abc'.replace('','x') becomes 'xaxbxcx'.\n   *\n   * If the input collection, pattern, or substitution are empty, the result is empty ({ }).\n   *\n   * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.\n   *\n   * See: https://hl7.org/fhirpath/#replacepattern-string-substitution-string-string\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @param patternAtom - The pattern to search for.\n   * @param substitionAtom - The substition to replace with.\n   * @returns The string with all instances of the search pattern replaced with the substitution string.\n   */\n  replace: (context: AtomContext, input: TypedValue[], patternAtom: Atom, substitionAtom: Atom): TypedValue[] => {\n    return applyStringFunc(\n      (str, pattern, substition) => str.replaceAll(pattern as string, substition as string),\n      context,\n      input,\n      patternAtom,\n      substitionAtom\n    );\n  },\n\n  /**\n   * Returns true when the value matches the given regular expression. Regular expressions should function consistently, regardless of any culture- and locale-specific settings in the environment, should be case-sensitive, use 'single line' mode and allow Unicode characters.\n   *\n   * If the input collection or regex are empty, the result is empty ({ }).\n   *\n   * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.\n   *\n   * See: https://hl7.org/fhirpath/#matchesregex-string-boolean\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @param regexAtom - The regular expression atom.\n   * @returns True if the input string matches the given regular expression.\n   */\n  matches: (context: AtomContext, input: TypedValue[], regexAtom: Atom): TypedValue[] => {\n    return applyStringFunc((str, regex) => !!new RegExp(regex as string).exec(str), context, input, regexAtom);\n  },\n\n  /**\n   * Matches the input using the regular expression in regex and replaces each match with the substitution string. The substitution may refer to identified match groups in the regular expression.\n   *\n   * If the input collection, regex, or substitution are empty, the result is empty ({ }).\n   *\n   * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.\n   *\n   * See: https://hl7.org/fhirpath/#replacematchesregex-string-substitution-string-string\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @param regexAtom - The regular expression atom.\n   * @param substitionAtom - The substition to replace with.\n   * @returns The string with all instances of the search pattern replaced with the substitution string.\n   */\n  replaceMatches: (context: AtomContext, input: TypedValue[], regexAtom: Atom, substitionAtom: Atom): TypedValue[] => {\n    return applyStringFunc(\n      (str, pattern, substition) => str.replaceAll(new RegExp(pattern as string, 'g'), substition as string),\n      context,\n      input,\n      regexAtom,\n      substitionAtom\n    );\n  },\n\n  /**\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @returns The index of the substring.\n   */\n  length: (context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    return applyStringFunc((str) => str.length, context, input);\n  },\n\n  /**\n   * Returns the list of characters in the input string. If the input collection is empty ({ }), the result is empty.\n   *\n   * See: https://hl7.org/fhirpath/#tochars-collection\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @returns Array of characters.\n   */\n  toChars: (context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    return applyStringFunc((str) => (str ? str.split('') : undefined), context, input);\n  },\n\n  /*\n   * Additional string functions\n   * See: https://build.fhir.org/ig/HL7/FHIRPath/#additional-string-functions\n   * STU Note: the contents of this section are Standard for Trial Use (STU)\n   */\n\n  encode: stub,\n  decode: stub,\n  escape: stub,\n  unescape: stub,\n  trim: stub,\n  split: stub,\n\n  /**\n   * The join function takes a collection of strings and joins them into a single string, optionally using the given separator.\n   *\n   * If the input is empty, the result is empty.\n   *\n   * If no separator is specified, the strings are directly concatenated.\n   *\n   * See: https://build.fhir.org/ig/HL7/FHIRPath/#joinseparator-string--string\n   *\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @param separatorAtom - Optional separator atom.\n   * @returns The joined string.\n   */\n  join: (context: AtomContext, input: TypedValue[], separatorAtom: Atom): TypedValue[] => {\n    const separator = separatorAtom?.eval(context, getRootInput(context))[0]?.value ?? '';\n    if (typeof separator !== 'string') {\n      throw new Error('Separator must be a string.');\n    }\n    return [{ type: PropertyType.string, value: input.map((i) => i.value?.toString() ?? '').join(separator) }];\n  },\n\n  /*\n   * 5.7. Math\n   */\n\n  /**\n   * Returns the absolute value of the input. When taking the absolute value of a quantity, the unit is unchanged.\n   *\n   * If the input collection is empty, the result is empty.\n   *\n   * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.\n   *\n   * See: https://hl7.org/fhirpath/#abs-integer-decimal-quantity\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @returns A collection containing the result.\n   */\n  abs: (context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    return applyMathFunc(Math.abs, context, input);\n  },\n\n  /**\n   * Returns the first integer greater than or equal to the input.\n   *\n   * If the input collection is empty, the result is empty.\n   *\n   * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.\n   *\n   * See: https://hl7.org/fhirpath/#ceiling-integer\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @returns A collection containing the result.\n   */\n  ceiling: (context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    return applyMathFunc(Math.ceil, context, input);\n  },\n\n  /**\n   * Returns e raised to the power of the input.\n   *\n   * If the input collection contains an Integer, it will be implicitly converted to a Decimal and the result will be a Decimal.\n   *\n   * If the input collection is empty, the result is empty.\n   *\n   * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.\n   *\n   * See: https://hl7.org/fhirpath/#exp-decimal\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @returns A collection containing the result.\n   */\n  exp: (context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    return applyMathFunc(Math.exp, context, input);\n  },\n\n  /**\n   * Returns the first integer less than or equal to the input.\n   *\n   * If the input collection is empty, the result is empty.\n   *\n   * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.\n   *\n   * See: https://hl7.org/fhirpath/#floor-integer\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @returns A collection containing the result.\n   */\n  floor: (context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    return applyMathFunc(Math.floor, context, input);\n  },\n\n  /**\n   * Returns the natural logarithm of the input (i.e. the logarithm base e).\n   *\n   * When used with an Integer, it will be implicitly converted to a Decimal.\n   *\n   * If the input collection is empty, the result is empty.\n   *\n   * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.\n   *\n   * See: https://hl7.org/fhirpath/#ln-decimal\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @returns A collection containing the result.\n   */\n  ln: (context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    return applyMathFunc(Math.log, context, input);\n  },\n\n  /**\n   * Returns the logarithm base base of the input number.\n   *\n   * When used with Integers, the arguments will be implicitly converted to Decimal.\n   *\n   * If base is empty, the result is empty.\n   *\n   * If the input collection is empty, the result is empty.\n   *\n   * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.\n   *\n   * See: https://hl7.org/fhirpath/#logbase-decimal-decimal\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @param baseAtom - The logarithm base.\n   * @returns A collection containing the result.\n   */\n  log: (context: AtomContext, input: TypedValue[], baseAtom: Atom): TypedValue[] => {\n    return applyMathFunc((value, base) => Math.log(value) / Math.log(base as number), context, input, baseAtom);\n  },\n\n  /**\n   * Raises a number to the exponent power. If this function is used with Integers, the result is an Integer. If the function is used with Decimals, the result is a Decimal. If the function is used with a mixture of Integer and Decimal, the Integer is implicitly converted to a Decimal and the result is a Decimal.\n   *\n   * If the power cannot be represented (such as the -1 raised to the 0.5), the result is empty.\n   *\n   * If the input is empty, or exponent is empty, the result is empty.\n   *\n   * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.\n   *\n   * See: https://hl7.org/fhirpath/#powerexponent-integer-decimal-integer-decimal\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @param expAtom - The exponent power.\n   * @returns A collection containing the result.\n   */\n  power: (context: AtomContext, input: TypedValue[], expAtom: Atom): TypedValue[] => {\n    return applyMathFunc(Math.pow as (x: number, ...args: unknown[]) => number, context, input, expAtom);\n  },\n\n  /**\n   * Rounds the decimal to the nearest whole number using a traditional round (i.e. 0.5 or higher will round to 1). If specified, the precision argument determines the decimal place at which the rounding will occur. If not specified, the rounding will default to 0 decimal places.\n   *\n   * If specified, the number of digits of precision must be >= 0 or the evaluation will end and signal an error to the calling environment.\n   *\n   * If the input collection contains a single item of type Integer, it will be implicitly converted to a Decimal.\n   *\n   * If the input collection is empty, the result is empty.\n   *\n   * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.\n   *\n   * See: https://hl7.org/fhirpath/#roundprecision-integer-decimal\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @returns A collection containing the result.\n   */\n  round: (context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    return applyMathFunc(Math.round, context, input);\n  },\n\n  /**\n   * Returns the square root of the input number as a Decimal.\n   *\n   * If the square root cannot be represented (such as the square root of -1), the result is empty.\n   *\n   * If the input collection is empty, the result is empty.\n   *\n   * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.\n   *\n   * Note that this function is equivalent to raising a number of the power of 0.5 using the power() function.\n   *\n   * See: https://hl7.org/fhirpath/#sqrt-decimal\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @returns A collection containing the result.\n   */\n  sqrt: (context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    return applyMathFunc(Math.sqrt, context, input);\n  },\n\n  /**\n   * Returns the integer portion of the input.\n   *\n   * If the input collection is empty, the result is empty.\n   *\n   * If the input collection contains multiple items, the evaluation of the expression will end and signal an error to the calling environment.\n   *\n   * See: https://hl7.org/fhirpath/#truncate-integer\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @returns A collection containing the result.\n   */\n  truncate: (context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    return applyMathFunc((x) => x | 0, context, input);\n  },\n\n  /*\n   * 5.8. Tree navigation\n   */\n\n  children: stub,\n\n  descendants: stub,\n\n  /*\n   * 5.9. Utility functions\n   */\n\n  /**\n   * Adds a String representation of the input collection to the diagnostic log,\n   * using the name argument as the name in the log. This log should be made available\n   * to the user in some appropriate fashion. Does not change the input, so returns\n   * the input collection as output.\n   *\n   * If the projection argument is used, the trace would log the result of evaluating\n   * the project expression on the input, but still return the input to the trace\n   * function unchanged.\n   *\n   * See: https://hl7.org/fhirpath/#tracename-string-projection-expression-collection\n   * @param _context - The evaluation context.\n   * @param input - The input collection.\n   * @param _nameAtom - The log name.\n   * @returns The input collection.\n   */\n  trace: (_context: AtomContext, input: TypedValue[], _nameAtom: Atom): TypedValue[] => {\n    return input;\n  },\n\n  /**\n   * Returns the current date and time, including timezone offset.\n   *\n   * See: https://hl7.org/fhirpath/#now-datetime\n   * @returns The current dateTime.\n   */\n  now: (): TypedValue[] => {\n    return [{ type: PropertyType.dateTime, value: new Date().toISOString() }];\n  },\n\n  /**\n   * Returns the current time.\n   *\n   * See: https://hl7.org/fhirpath/#timeofday-time\n   * @returns The current time string.\n   */\n  timeOfDay: (): TypedValue[] => {\n    return [{ type: PropertyType.time, value: new Date().toISOString().substring(11) }];\n  },\n\n  /**\n   * Returns the current date.\n   *\n   * See: https://hl7.org/fhirpath/#today-date\n   * @returns The current date string.\n   */\n  today: (): TypedValue[] => {\n    return [{ type: PropertyType.date, value: new Date().toISOString().substring(0, 10) }];\n  },\n\n  /**\n   * Calculates the difference between two dates or date/times.\n   *\n   * This is not part of the official FHIRPath spec.\n   *\n   * IBM FHIR issue: https://github.com/IBM/FHIR/issues/1014\n   * IBM FHIR PR: https://github.com/IBM/FHIR/pull/1023\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @param startAtom - The start date/time.\n   * @param endAtom - The end date/time.\n   * @param unitsAtom - Which units to return (\"years\", \"months\", or \"days\").\n   * @returns The Quantity of time between the two dates.\n   */\n  between: (\n    context: AtomContext,\n    input: TypedValue[],\n    startAtom: Atom,\n    endAtom: Atom,\n    unitsAtom: Atom\n  ): TypedValue[] => {\n    const startDate = functions.toDateTime(context, startAtom.eval(context, input));\n    if (startDate.length === 0) {\n      throw new Error('Invalid start date');\n    }\n    const endDate = functions.toDateTime(context, endAtom.eval(context, input));\n    if (endDate.length === 0) {\n      throw new Error('Invalid end date');\n    }\n    const unit = unitsAtom.eval(context, input)[0]?.value as string;\n    if (unit !== 'years' && unit !== 'months' && unit !== 'days') {\n      throw new Error('Invalid units');\n    }\n    const age = calculateAge(startDate[0].value, endDate[0].value);\n    return [{ type: PropertyType.Quantity, value: { value: age[unit], unit } }];\n  },\n\n  /*\n   * 6.3 Types\n   */\n\n  /**\n   * The is() function is supported for backwards compatibility with previous\n   * implementations of FHIRPath. Just as with the is keyword, the type argument\n   * is an identifier that must resolve to the name of a type in a model.\n   *\n   * For implementations with compile-time typing, this requires special-case\n   * handling when processing the argument to treat it as a type specifier rather\n   * than an identifier expression:\n   * @param _context - The evaluation context.\n   * @param input - The input collection.\n   * @param typeAtom - The desired type.\n   * @returns True if the input element is of the desired type.\n   */\n  is: (_context: AtomContext, input: TypedValue[], typeAtom: Atom): TypedValue[] => {\n    let typeName = '';\n    if (typeAtom instanceof SymbolAtom) {\n      typeName = typeAtom.name;\n    } else if (typeAtom instanceof DotAtom) {\n      typeName = (typeAtom.left as SymbolAtom).name + '.' + (typeAtom.right as SymbolAtom).name;\n    }\n    if (!typeName) {\n      return [];\n    }\n    return input.map((value) => ({ type: PropertyType.boolean, value: fhirPathIs(value, typeName) }));\n  },\n\n  /*\n   * 6.5 Boolean logic\n   */\n\n  /**\n   * 6.5.3. not() : Boolean\n   *\n   * Returns true if the input collection evaluates to false, and false if it evaluates to true. Otherwise, the result is empty ({ }):\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @returns True if the input evaluates to false.\n   */\n  not: (context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    return functions.toBoolean(context, input).map((value) => ({ type: PropertyType.boolean, value: !value.value }));\n  },\n\n  /*\n   * Additional functions\n   * See: https://hl7.org/fhir/fhirpath.html#functions\n   */\n\n  /**\n   * For each item in the collection, if it is a string that is a uri (or canonical or url), locate the target of the reference, and add it to the resulting collection. If the item does not resolve to a resource, the item is ignored and nothing is added to the output collection.\n   * The items in the collection may also represent a Reference, in which case the Reference.reference is resolved.\n   * @param _context - The evaluation context.\n   * @param input - The input collection.\n   * @returns The resolved resource.\n   */\n  resolve: (_context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    return input\n      .map((e) => {\n        const value = e.value;\n        let refStr: string | undefined;\n        if (typeof value === 'string') {\n          refStr = value;\n        } else if (typeof value === 'object') {\n          const ref = value as Reference;\n          if (ref.resource) {\n            return toTypedValue(ref.resource);\n          }\n          if (ref.reference) {\n            refStr = ref.reference;\n          } else if (ref.type && ref.identifier) {\n            refStr = `${ref.type}?identifier=${ref.identifier.system}|${ref.identifier.value}`;\n          }\n        }\n        if (refStr?.includes('?')) {\n          const [resourceType] = refStr.split('?');\n          return { type: resourceType, value: { resourceType } };\n        }\n        if (refStr?.includes('/')) {\n          const [resourceType, id] = refStr.split('/');\n          return { type: resourceType, value: { resourceType, id } };\n        }\n        return { type: PropertyType.BackboneElement, value: undefined };\n      })\n      .filter((e) => !!e.value);\n  },\n\n  /**\n   * The as operator can be used to treat a value as a specific type.\n   * @param _context - The evaluation context.\n   * @param input - The input value.\n   * @returns The value as the specific type.\n   */\n  as: (_context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    return input;\n  },\n\n  /*\n   * 12. Formal Specifications\n   */\n\n  /**\n   * Returns the type of the input.\n   *\n   * 12.2. Model Information\n   *\n   * The model information returned by the reflection function type() is specified as an\n   * XML Schema document (xsd) and included in this specification at the following link:\n   * https://hl7.org/fhirpath/modelinfo.xsd\n   *\n   * See: https://hl7.org/fhirpath/#model-information\n   * @param _context - The evaluation context.\n   * @param input - The input collection.\n   * @returns The type of the input value.\n   */\n  type: (_context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    return input.map(({ value }) => {\n      if (typeof value === 'boolean') {\n        return { type: PropertyType.BackboneElement, value: { namespace: 'System', name: 'Boolean' } };\n      }\n      if (typeof value === 'number') {\n        return { type: PropertyType.BackboneElement, value: { namespace: 'System', name: 'Integer' } };\n      }\n      if (isResource(value)) {\n        return {\n          type: PropertyType.BackboneElement,\n          value: { namespace: 'FHIR', name: value.resourceType },\n        };\n      }\n      return { type: PropertyType.BackboneElement, value: null };\n    });\n  },\n\n  conformsTo: (context: AtomContext, input: TypedValue[], systemAtom: Atom): TypedValue[] => {\n    const system = systemAtom.eval(context, input)[0].value as string;\n    if (!system.startsWith('http://hl7.org/fhir/StructureDefinition/')) {\n      throw new Error('Expected a StructureDefinition URL');\n    }\n    const expectedResourceType = system.replace('http://hl7.org/fhir/StructureDefinition/', '');\n    return input.map((value) => ({\n      type: PropertyType.boolean,\n      value: value.value?.resourceType === expectedResourceType,\n    }));\n  },\n\n  /*\n   * SQL-on-FHIR utilities\n   */\n\n  /**\n   * Returns an opaque value to be used as the primary key for the row associated with the resource.\n   *\n   * In many cases the value may just be the resource id, but exceptions are described below.\n   * This function is used in tandem with getReferenceKey(), which returns an equal value from references that point to this resource.\n   *\n   * The returned KeyType is implementation dependent, but must be a FHIR primitive type that can be used for efficient joins in the\n   * system\u2019s underlying data storage. Integers, strings, UUIDs, and other primitive types are appropriate.\n   *\n   * See: https://build.fhir.org/ig/FHIR/sql-on-fhir-v2/StructureDefinition-ViewDefinition.html#getresourcekey--keytype\n   *\n   * @param _context - The evaluation context.\n   * @param input - The input collection.\n   * @returns The resource key.\n   */\n  getResourceKey: (_context: AtomContext, input: TypedValue[]): TypedValue[] => {\n    const resource = input[0].value as Resource;\n    if (!resource?.id) {\n      return [];\n    }\n    return [{ type: PropertyType.id, value: resource.id }];\n  },\n\n  /**\n   * Returns an opaque value that represents the database key of the row being referenced.\n   *\n   * The value returned must be equal to the getResourceKey() value returned on the resource itself.\n   *\n   * Users may pass an optional resource type (e.g., Patient or Observation) to indicate the expected type that the reference should point to.\n   * The getReferenceKey() will return an empty collection (effectively null since FHIRPath always returns collections) if the reference is not of the expected type.\n   * For example, Observation.subject.getReferenceKey(Patient) would return a row key if the subject is a Patient, or the empty collection (i.e., {}) if it is not.\n   *\n   * The returned KeyType is implementation dependent, but must be a FHIR primitive type that can be used for efficient joins in the systems underlying data storage.\n   * Integers, strings, UUIDs, and other primitive types are appropriate.\n   *\n   * See: https://build.fhir.org/ig/FHIR/sql-on-fhir-v2/StructureDefinition-ViewDefinition.html#getreferencekeyresource-type-specifier--keytype\n   *\n   * @param context - The evaluation context.\n   * @param input - The input collection.\n   * @param typeAtom - Optional expected resource type.\n   * @returns The reference key.\n   */\n  getReferenceKey: (context: AtomContext, input: TypedValue[], typeAtom: Atom): TypedValue[] => {\n    const reference = input[0].value as Reference;\n    if (!reference?.reference) {\n      return [];\n    }\n\n    let typeName = '';\n    if (typeAtom instanceof SymbolAtom) {\n      typeName = typeAtom.name;\n    }\n    if (typeName && !reference.reference.startsWith(typeName + '/')) {\n      return [];\n    }\n\n    return [{ type: PropertyType.id, value: resolveId(reference) }];\n  },\n\n  extension: (context: AtomContext, input: TypedValue[], urlAtom: Atom): TypedValue[] => {\n    const url = urlAtom.eval(context, input)[0].value as string;\n    const resource = input?.[0]?.value;\n    if (resource) {\n      const extension = getExtension(resource, url);\n      if (extension) {\n        return [{ type: PropertyType.Extension, value: extension }];\n      }\n    }\n    return [];\n  },\n};\n\n/*\n * Helper utilities\n */\n\nfunction applyStringFunc<T>(\n  func: (str: string, ...args: unknown[]) => T | undefined,\n  context: AtomContext,\n  input: TypedValue[],\n  ...argsAtoms: (Atom | undefined)[]\n): TypedValue[] {\n  if (input.length === 0) {\n    return [];\n  }\n  const [{ value }] = validateInput(input, 1);\n  if (typeof value !== 'string') {\n    throw new Error('String function cannot be called with non-string');\n  }\n  const result = func(value, ...argsAtoms.map((atom) => atom?.eval(context, input)[0]?.value));\n  if (result === undefined) {\n    return [];\n  }\n  if (Array.isArray(result)) {\n    return result.map(toTypedValue);\n  }\n  return [toTypedValue(result)];\n}\n\nfunction applyMathFunc(\n  func: (x: number, ...args: unknown[]) => number,\n  context: AtomContext,\n  input: TypedValue[],\n  ...argsAtoms: Atom[]\n): TypedValue[] {\n  if (input.length === 0) {\n    return [];\n  }\n  const [{ value }] = validateInput(input, 1);\n  const quantity = isQuantity(value);\n  const numberInput = quantity ? value.value : value;\n  if (typeof numberInput !== 'number') {\n    throw new Error('Math function cannot be called with non-number');\n  }\n  const result = func(numberInput, ...argsAtoms.map((atom) => atom.eval(context, input)[0]?.value));\n  const type = quantity ? PropertyType.Quantity : input[0].type;\n  const returnValue = quantity ? { ...value, value: result } : result;\n  return [{ type, value: returnValue }];\n}\n\nfunction validateInput(input: TypedValue[], count: number): TypedValue[] {\n  if (input.length !== count) {\n    throw new Error(`Expected ${count} arguments`);\n  }\n  for (const element of input) {\n    if (element === null || element === undefined) {\n      throw new Error('Expected non-null argument');\n    }\n  }\n  return input;\n}\n\nfunction getRootInput(context: AtomContext): [TypedValue] {\n  let last = context;\n  while (last.parent?.variables.$this) {\n    last = last.parent;\n  }\n  return [last.variables.$this];\n}\n", "import { ResourceType } from '@medplum/fhirtypes';\nimport { Atom, AtomContext, InfixOperatorAtom, PrefixOperatorAtom } from '../fhirlexer/parse';\nimport { PropertyType, TypedValue, isResource } from '../types';\nimport { functions } from './functions';\nimport {\n  booleanToTypedValue,\n  fhirPathArrayEquals,\n  fhirPathArrayEquivalent,\n  fhirPathArrayNotEquals,\n  fhirPathEquals,\n  fhirPathIs,\n  fhirPathNot,\n  getTypedPropertyValue,\n  isQuantity,\n  removeDuplicates,\n  singleton,\n  toTypedValue,\n} from './utils';\n\nexport class FhirPathAtom implements Atom {\n  readonly original: string;\n  readonly child: Atom;\n\n  constructor(original: string, child: Atom) {\n    this.original = original;\n    this.child = child;\n  }\n\n  eval(context: AtomContext, input: TypedValue[]): TypedValue[] {\n    try {\n      if (input.length > 0) {\n        const result = [];\n        for (const e of input) {\n          result.push(this.child.eval({ parent: context, variables: { $this: e } }, [e]));\n        }\n        return result.flat();\n      } else {\n        return this.child.eval(context, []);\n      }\n    } catch (error) {\n      throw new Error(`FhirPathError on \"${this.original}\": ${error}`, { cause: error });\n    }\n  }\n\n  toString(): string {\n    return this.child.toString();\n  }\n}\n\nexport class LiteralAtom implements Atom {\n  public readonly value: TypedValue;\n\n  constructor(value: TypedValue) {\n    this.value = value;\n  }\n\n  eval(): TypedValue[] {\n    return [this.value];\n  }\n\n  toString(): string {\n    const value = this.value.value;\n    if (typeof value === 'string') {\n      return `'${value}'`;\n    }\n    return value.toString();\n  }\n}\n\nexport class SymbolAtom implements Atom {\n  readonly name: string;\n\n  constructor(name: string) {\n    this.name = name;\n  }\n\n  eval(context: AtomContext, input: TypedValue[]): TypedValue[] {\n    if (this.name === '$this') {\n      return input;\n    }\n    const variableValue = this.getVariable(context);\n    if (variableValue) {\n      return [variableValue];\n    }\n    if (this.name.startsWith('%')) {\n      throw new Error(`Undefined variable ${this.name}`);\n    }\n    return input.flatMap((e) => this.evalValue(e)).filter((e) => e?.value !== undefined) as TypedValue[];\n  }\n\n  private getVariable(context: AtomContext): TypedValue | undefined {\n    const value = context.variables[this.name];\n    if (value !== undefined) {\n      return value;\n    }\n\n    if (context.parent) {\n      return this.getVariable(context.parent);\n    }\n\n    return undefined;\n  }\n\n  private evalValue(typedValue: TypedValue): TypedValue[] | TypedValue | undefined {\n    const input = typedValue.value;\n    if (!input || typeof input !== 'object') {\n      return undefined;\n    }\n\n    if (isResource(input, this.name as ResourceType)) {\n      return typedValue;\n    }\n\n    return getTypedPropertyValue(typedValue, this.name);\n  }\n\n  toString(): string {\n    return this.name;\n  }\n}\n\nexport class EmptySetAtom implements Atom {\n  eval(): [] {\n    return [];\n  }\n\n  toString(): string {\n    return '{}';\n  }\n}\n\nexport class UnaryOperatorAtom extends PrefixOperatorAtom {\n  readonly impl: (x: TypedValue[]) => TypedValue[];\n\n  constructor(operator: string, child: Atom, impl: (x: TypedValue[]) => TypedValue[]) {\n    super(operator, child);\n    this.impl = impl;\n  }\n\n  eval(context: AtomContext, input: TypedValue[]): TypedValue[] {\n    return this.impl(this.child.eval(context, input));\n  }\n\n  toString(): string {\n    return this.operator + this.child.toString();\n  }\n}\n\nexport class AsAtom extends InfixOperatorAtom {\n  constructor(left: Atom, right: Atom) {\n    super('as', left, right);\n  }\n\n  eval(context: AtomContext, input: TypedValue[]): TypedValue[] {\n    return functions.ofType(context, this.left.eval(context, input), this.right);\n  }\n}\n\nexport abstract class BooleanInfixOperatorAtom extends InfixOperatorAtom {\n  abstract eval(context: AtomContext, input: TypedValue[]): TypedValue[];\n}\n\nexport class ArithemticOperatorAtom extends BooleanInfixOperatorAtom {\n  readonly impl: (x: number, y: number) => number | boolean;\n\n  constructor(operator: string, left: Atom, right: Atom, impl: (x: number, y: number) => number | boolean) {\n    super(operator, left, right);\n    this.impl = impl;\n  }\n\n  eval(context: AtomContext, input: TypedValue[]): TypedValue[] {\n    const leftEvalResult = this.left.eval(context, input);\n    if (leftEvalResult.length !== 1) {\n      return [];\n    }\n    const rightEvalResult = this.right.eval(context, input);\n    if (rightEvalResult.length !== 1) {\n      return [];\n    }\n    const leftValue = leftEvalResult[0].value;\n    const rightValue = rightEvalResult[0].value;\n    const leftNumber = isQuantity(leftValue) ? leftValue.value : leftValue;\n    const rightNumber = isQuantity(rightValue) ? rightValue.value : rightValue;\n    const result = this.impl(leftNumber, rightNumber);\n    if (typeof result === 'boolean') {\n      return booleanToTypedValue(result);\n    } else if (isQuantity(leftValue)) {\n      return [{ type: PropertyType.Quantity, value: { ...leftValue, value: result } }];\n    } else {\n      return [toTypedValue(result)];\n    }\n  }\n}\n\nexport class ConcatAtom extends InfixOperatorAtom {\n  constructor(left: Atom, right: Atom) {\n    super('&', left, right);\n  }\n\n  eval(context: AtomContext, input: TypedValue[]): TypedValue[] {\n    const leftValue = this.left.eval(context, input);\n    const rightValue = this.right.eval(context, input);\n    const result = [...leftValue, ...rightValue];\n    if (result.length > 0 && result.every((e) => typeof e.value === 'string')) {\n      return [{ type: PropertyType.string, value: result.map((e) => e.value as string).join('') }];\n    }\n    return result;\n  }\n}\n\nexport class ContainsAtom extends BooleanInfixOperatorAtom {\n  constructor(left: Atom, right: Atom) {\n    super('contains', left, right);\n  }\n\n  eval(context: AtomContext, input: TypedValue[]): TypedValue[] {\n    const leftValue = this.left.eval(context, input);\n    const rightValue = this.right.eval(context, input);\n    return booleanToTypedValue(leftValue.some((e) => e.value === rightValue[0].value));\n  }\n}\n\nexport class InAtom extends BooleanInfixOperatorAtom {\n  constructor(left: Atom, right: Atom) {\n    super('in', left, right);\n  }\n\n  eval(context: AtomContext, input: TypedValue[]): TypedValue[] {\n    const left = singleton(this.left.eval(context, input));\n    const right = this.right.eval(context, input);\n    if (!left) {\n      return [];\n    }\n    return booleanToTypedValue(right.some((e) => fhirPathEquals(left, e)[0].value));\n  }\n}\n\nexport class DotAtom extends InfixOperatorAtom {\n  constructor(left: Atom, right: Atom) {\n    super('.', left, right);\n  }\n\n  eval(context: AtomContext, input: TypedValue[]): TypedValue[] {\n    return this.right.eval(context, this.left.eval(context, input));\n  }\n\n  toString(): string {\n    return `${this.left.toString()}.${this.right.toString()}`;\n  }\n}\n\nexport class UnionAtom extends InfixOperatorAtom {\n  constructor(left: Atom, right: Atom) {\n    super('|', left, right);\n  }\n\n  eval(context: AtomContext, input: TypedValue[]): TypedValue[] {\n    const leftResult = this.left.eval(context, input);\n    const rightResult = this.right.eval(context, input);\n    return removeDuplicates([...leftResult, ...rightResult]);\n  }\n}\n\nexport class EqualsAtom extends BooleanInfixOperatorAtom {\n  constructor(left: Atom, right: Atom) {\n    super('=', left, right);\n  }\n\n  eval(context: AtomContext, input: TypedValue[]): TypedValue[] {\n    const leftValue = this.left.eval(context, input);\n    const rightValue = this.right.eval(context, input);\n    return fhirPathArrayEquals(leftValue, rightValue);\n  }\n}\n\nexport class NotEqualsAtom extends BooleanInfixOperatorAtom {\n  constructor(left: Atom, right: Atom) {\n    super('!=', left, right);\n  }\n\n  eval(context: AtomContext, input: TypedValue[]): TypedValue[] {\n    const leftValue = this.left.eval(context, input);\n    const rightValue = this.right.eval(context, input);\n    return fhirPathArrayNotEquals(leftValue, rightValue);\n  }\n}\n\nexport class EquivalentAtom extends BooleanInfixOperatorAtom {\n  constructor(left: Atom, right: Atom) {\n    super('~', left, right);\n  }\n\n  eval(context: AtomContext, input: TypedValue[]): TypedValue[] {\n    const leftValue = this.left.eval(context, input);\n    const rightValue = this.right.eval(context, input);\n    return fhirPathArrayEquivalent(leftValue, rightValue);\n  }\n}\n\nexport class NotEquivalentAtom extends BooleanInfixOperatorAtom {\n  constructor(left: Atom, right: Atom) {\n    super('!~', left, right);\n  }\n\n  eval(context: AtomContext, input: TypedValue[]): TypedValue[] {\n    const leftValue = this.left.eval(context, input);\n    const rightValue = this.right.eval(context, input);\n    return fhirPathNot(fhirPathArrayEquivalent(leftValue, rightValue));\n  }\n}\n\nexport class IsAtom extends BooleanInfixOperatorAtom {\n  constructor(left: Atom, right: Atom) {\n    super('is', left, right);\n  }\n\n  eval(context: AtomContext, input: TypedValue[]): TypedValue[] {\n    const leftValue = this.left.eval(context, input);\n    if (leftValue.length !== 1) {\n      return [];\n    }\n    const typeName = (this.right as SymbolAtom).name;\n    return booleanToTypedValue(fhirPathIs(leftValue[0], typeName));\n  }\n}\n\n/**\n * 6.5.1. and\n * Returns true if both operands evaluate to true,\n * false if either operand evaluates to false,\n * and the empty collection otherwise.\n */\nexport class AndAtom extends BooleanInfixOperatorAtom {\n  constructor(left: Atom, right: Atom) {\n    super('and', left, right);\n  }\n\n  eval(context: AtomContext, input: TypedValue[]): TypedValue[] {\n    const left = singleton(this.left.eval(context, input), 'boolean');\n    const right = singleton(this.right.eval(context, input), 'boolean');\n    if (left?.value === true && right?.value === true) {\n      return booleanToTypedValue(true);\n    }\n    if (left?.value === false || right?.value === false) {\n      return booleanToTypedValue(false);\n    }\n    return [];\n  }\n}\n\n/**\n * 6.5.2. or\n * Returns false if both operands evaluate to false,\n * true if either operand evaluates to true,\n * and empty (`{ }`) otherwise:\n */\nexport class OrAtom extends BooleanInfixOperatorAtom {\n  constructor(left: Atom, right: Atom) {\n    super('or', left, right);\n  }\n\n  eval(context: AtomContext, input: TypedValue[]): TypedValue[] {\n    const left = singleton(this.left.eval(context, input), 'boolean');\n    const right = singleton(this.right.eval(context, input), 'boolean');\n    if (left?.value === false && right?.value === false) {\n      return booleanToTypedValue(false);\n    } else if (left?.value || right?.value) {\n      return booleanToTypedValue(true);\n    } else {\n      return [];\n    }\n  }\n}\n\n/**\n * 6.5.4. xor\n * Returns true if exactly one of the operands evaluates to true,\n * false if either both operands evaluate to true or both operands evaluate to false,\n * and the empty collection otherwise.\n */\nexport class XorAtom extends BooleanInfixOperatorAtom {\n  constructor(left: Atom, right: Atom) {\n    super('xor', left, right);\n  }\n\n  eval(context: AtomContext, input: TypedValue[]): TypedValue[] {\n    const left = singleton(this.left.eval(context, input), 'boolean');\n    const right = singleton(this.right.eval(context, input), 'boolean');\n    if (!left || !right) {\n      return [];\n    }\n    return booleanToTypedValue(left.value !== right.value);\n  }\n}\n\n/**\n * 6.5.5. implies\n * Returns true if left is true and right is true,\n * true left is false and right true, false or empty\n * true left is empty\n */\nexport class ImpliesAtom extends BooleanInfixOperatorAtom {\n  constructor(left: Atom, right: Atom) {\n    super('implies', left, right);\n  }\n\n  eval(context: AtomContext, input: TypedValue[]): TypedValue[] {\n    const left = singleton(this.left.eval(context, input), 'boolean');\n    const right = singleton(this.right.eval(context, input), 'boolean');\n    if (right?.value === true || left?.value === false) {\n      return booleanToTypedValue(true);\n    } else if (!left || !right) {\n      return [];\n    }\n    return booleanToTypedValue(false);\n  }\n}\n\nexport class FunctionAtom implements Atom {\n  readonly name: string;\n  readonly args: Atom[];\n\n  constructor(name: string, args: Atom[]) {\n    this.name = name;\n    this.args = args;\n  }\n\n  eval(context: AtomContext, input: TypedValue[]): TypedValue[] {\n    const impl = functions[this.name];\n    if (!impl) {\n      throw new Error('Unrecognized function: ' + this.name);\n    }\n    return impl(context, input, ...this.args);\n  }\n\n  toString(): string {\n    return `${this.name}(${this.args.map((arg) => arg.toString()).join(', ')})`;\n  }\n}\n\nexport class IndexerAtom implements Atom {\n  readonly left: Atom;\n  readonly expr: Atom;\n\n  constructor(left: Atom, expr: Atom) {\n    this.left = left;\n    this.expr = expr;\n  }\n\n  eval(context: AtomContext, input: TypedValue[]): TypedValue[] {\n    const evalResult = this.expr.eval(context, input);\n    if (evalResult.length !== 1) {\n      return [];\n    }\n    const index = evalResult[0].value;\n    if (typeof index !== 'number') {\n      throw new Error(`Invalid indexer expression: should return integer}`);\n    }\n    const leftResult = this.left.eval(context, input);\n    if (!(index in leftResult)) {\n      return [];\n    }\n    return [leftResult[index]];\n  }\n\n  toString(): string {\n    return `${this.left.toString()}[${this.expr.toString()}]`;\n  }\n}\n", "export interface Marker {\n  index: number;\n  line: number;\n  column: number;\n}\n\nexport interface Token extends Marker {\n  id: string;\n  value: string;\n}\n\nconst STANDARD_UNITS = [\n  'year',\n  'years',\n  'month',\n  'months',\n  'week',\n  'weeks',\n  'day',\n  'days',\n  'hour',\n  'hours',\n  'minute',\n  'minutes',\n  'second',\n  'seconds',\n  'millisecond',\n  'milliseconds',\n];\n\nexport interface TokenizerOptions {\n  dateTimeLiterals?: boolean;\n  symbolRegex?: RegExp;\n}\n\nexport class Tokenizer {\n  private readonly str: string;\n  private readonly keywords: string[];\n  private readonly operators: string[];\n  private readonly dateTimeLiterals: boolean;\n  private readonly symbolRegex: RegExp;\n  private readonly result: Token[] = [];\n  private readonly pos: Marker = { index: 0, line: 1, column: 0 };\n  private readonly markStack: Marker[] = [];\n\n  constructor(str: string, keywords: string[], operators: string[], options?: TokenizerOptions) {\n    this.str = str;\n    this.keywords = keywords;\n    this.operators = operators;\n    this.dateTimeLiterals = !!options?.dateTimeLiterals;\n    this.symbolRegex = options?.symbolRegex ?? /[$\\w%]/;\n  }\n\n  tokenize(): Token[] {\n    while (this.pos.index < this.str.length) {\n      const token = this.consumeToken();\n      if (token) {\n        this.result.push(token);\n      }\n    }\n\n    return this.result;\n  }\n\n  private prevToken(): Token | undefined {\n    return this.result.slice(-1)[0];\n  }\n\n  private peekToken(): Token | undefined {\n    this.mark();\n    const token = this.consumeToken();\n    this.reset();\n    return token;\n  }\n\n  private consumeToken(): Token | undefined {\n    this.consumeWhitespace();\n\n    const c = this.curr();\n    if (!c) {\n      return undefined;\n    }\n\n    this.mark();\n\n    const next = this.peek();\n\n    if (c === '/' && next === '*') {\n      return this.consumeMultiLineComment();\n    }\n\n    if (c === '/' && next === '/') {\n      return this.consumeSingleLineComment();\n    }\n\n    if (c === \"'\" || c === '\"' || c === '`') {\n      return this.consumeString(c);\n    }\n\n    if (c === '@') {\n      return this.consumeDateTime();\n    }\n\n    if (/\\d/.exec(c)) {\n      return this.consumeNumber();\n    }\n\n    if (/\\w/.exec(c)) {\n      return this.consumeSymbol();\n    }\n\n    if ((c === '$' || c === '%') && /\\w/.exec(next)) {\n      return this.consumeSymbol();\n    }\n\n    if ((c === '$' || c === '%') && (next === \"'\" || next === '\"' || next === '`')) {\n      return this.consumeQuotedSymbol(next);\n    }\n\n    return this.consumeOperator();\n  }\n\n  private consumeWhitespace(): void {\n    this.consumeWhile(() => /\\s/.exec(this.curr()));\n  }\n\n  private consumeMultiLineComment(): Token {\n    const start = this.pos.index;\n    this.consumeWhile(() => this.curr() !== '*' || this.peek() !== '/');\n    this.advance();\n    this.advance();\n    return this.buildToken('Comment', this.str.substring(start, this.pos.index));\n  }\n\n  private consumeSingleLineComment(): Token {\n    return this.buildToken(\n      'Comment',\n      this.consumeWhile(() => this.curr() !== '\\n')\n    );\n  }\n\n  private consumeString(endChar: string): Token {\n    this.advance();\n    const str = this.consumeWhile(() => this.prev() === '\\\\' || this.curr() !== endChar);\n    const unescaped = str.replace(/\\\\u([0-9a-fA-F]{4})/g, (match, hex) => String.fromCodePoint(parseInt(hex, 16)));\n    const result = this.buildToken(endChar === '`' ? 'Symbol' : 'String', unescaped);\n    this.advance();\n    return result;\n  }\n\n  private consumeQuotedSymbol(endChar: string): Token {\n    this.mark();\n    const start = this.pos.index;\n    this.advance(); // Consume \"$\" or \"%\"\n    this.consumeString(endChar);\n    const value = this.str.substring(start, this.pos.index);\n    return this.buildToken('Symbol', value);\n  }\n\n  private consumeDateTime(): Token {\n    this.advance(); // Consume \"@\"\n\n    const start = this.pos.index;\n    this.consumeWhile(() => /[\\d-]/.exec(this.curr()));\n\n    let foundTime = false;\n    let foundTimeZone = false;\n\n    if (this.curr() === 'T') {\n      foundTime = true;\n      this.advance();\n      this.consumeWhile(() => /[\\d:]/.exec(this.curr()));\n\n      if (this.curr() === '.' && /\\d/.exec(this.peek())) {\n        this.advance();\n        this.consumeWhile(() => /\\d/.exec(this.curr()));\n      }\n\n      if (this.curr() === 'Z') {\n        foundTimeZone = true;\n        this.advance();\n      } else if (this.curr() === '+' || this.curr() === '-') {\n        foundTimeZone = true;\n        this.advance();\n        this.consumeWhile(() => /[\\d:]/.exec(this.curr()));\n      }\n    }\n\n    if (this.pos.index === start) {\n      throw new Error('Invalid DateTime literal');\n    }\n\n    let value = this.str.substring(start, this.pos.index);\n    if (value.endsWith('T')) {\n      // The date/time string ended with a \"T\", which is valid FHIRPath, but not valid ISO8601.\n      // Strip the \"T\" and treat as a date.\n      value = value.substring(0, value.length - 1);\n    } else if (!value.startsWith('T') && foundTime && !foundTimeZone) {\n      // FHIRPath spec says timezone is optional: https://build.fhir.org/ig/HL7/FHIRPath/#datetime\n      // The FHIRPath test suite expects the timezone to be \"Z\" if not specified.\n      // See: https://github.com/HL7/FHIRPath/blob/master/tests/r4/tests-fhir-r4.xml\n      value += 'Z';\n    }\n    return this.buildToken('DateTime', value);\n  }\n\n  private consumeNumber(): Token {\n    const start = this.pos.index;\n    let id = 'Number';\n    this.consumeWhile(() => /\\d/.exec(this.curr()));\n\n    if (this.curr() === '.' && /\\d/.exec(this.peek())) {\n      this.advance();\n      this.consumeWhile(() => /\\d/.exec(this.curr()));\n    }\n\n    if (this.curr() === '-' && this.dateTimeLiterals) {\n      // Rewind to one character before the start, and then treat as dateTime literal.\n      this.pos.index = start - 1;\n      return this.consumeDateTime();\n    }\n\n    if (this.curr() === ' ') {\n      if (isUnitToken(this.peekToken())) {\n        id = 'Quantity';\n        this.consumeToken();\n      }\n    }\n\n    return this.buildToken(id, this.str.substring(start, this.pos.index));\n  }\n\n  private consumeSymbol(): Token {\n    const value = this.consumeWhile(() => this.symbolRegex.exec(this.curr()));\n    if (this.prevToken()?.value !== '.' && this.keywords.includes(value)) {\n      return this.buildToken(value, value);\n    }\n    return this.buildToken('Symbol', value);\n  }\n\n  private consumeOperator(): Token {\n    const c = this.curr();\n    const next = this.peek();\n    const twoCharOp = c + next;\n\n    if (this.operators.includes(twoCharOp)) {\n      this.advance();\n      this.advance();\n      return this.buildToken(twoCharOp, twoCharOp);\n    }\n\n    this.advance();\n    return this.buildToken(c, c);\n  }\n\n  private consumeWhile(condition: () => unknown): string {\n    const start = this.pos.index;\n\n    while (this.pos.index < this.str.length && condition()) {\n      this.advance();\n    }\n\n    return this.str.substring(start, this.pos.index);\n  }\n\n  private curr(): string {\n    return this.str[this.pos.index];\n  }\n\n  private prev(): string {\n    return this.str[this.pos.index - 1] ?? '';\n  }\n\n  private peek(): string {\n    return this.str[this.pos.index + 1] ?? '';\n  }\n\n  private mark(): void {\n    this.markStack.push({ ...this.pos });\n  }\n\n  private reset(): void {\n    const mark = this.markStack.pop();\n    if (!mark) {\n      throw new Error('No mark to reset to');\n    }\n    this.pos.index = mark.index;\n    this.pos.line = mark.line;\n    this.pos.column = mark.column;\n  }\n\n  private advance(): void {\n    this.pos.index++;\n    if (this.curr() === '\\n') {\n      this.pos.line++;\n      this.pos.column = 0;\n    } else {\n      this.pos.column++;\n    }\n  }\n\n  private buildToken(id: string, value: string): Token {\n    const mark = this.markStack.pop();\n    if (!mark) {\n      throw new Error('No mark for token');\n    }\n    return {\n      id,\n      value,\n      ...mark,\n    };\n  }\n}\n\nfunction isUnitToken(token: Token | undefined): boolean {\n  if (token) {\n    if (token.id === 'String') {\n      return true;\n    }\n\n    if (token.id === 'Symbol' && STANDARD_UNITS.includes(token.value)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n", "import { Token, Tokenizer } from '../fhirlexer/tokenize';\n\nexport const FHIRPATH_KEYWORDS = ['true', 'false'];\nexport const FHIRPATH_OPERATORS = ['!=', '!~', '<=', '>=', '{}', '->'];\n\nexport function tokenize(str: string): Token[] {\n  return new Tokenizer(str, FHIRPATH_KEYWORDS, FHIRPATH_OPERATORS).tokenize();\n}\n", "import { Quantity } from '@medplum/fhirtypes';\nimport { LRUCache } from '../cache';\nimport { Atom, InfixParselet, Parser, ParserBuilder, PrefixParselet } from '../fhirlexer/parse';\nimport { PropertyType, TypedValue } from '../types';\nimport {\n  AndAtom,\n  ArithemticOperatorAtom,\n  AsAtom,\n  ConcatAtom,\n  ContainsAtom,\n  DotAtom,\n  EmptySetAtom,\n  EqualsAtom,\n  EquivalentAtom,\n  FhirPathAtom,\n  FunctionAtom,\n  ImpliesAtom,\n  InAtom,\n  IndexerAtom,\n  IsAtom,\n  LiteralAtom,\n  NotEqualsAtom,\n  NotEquivalentAtom,\n  OrAtom,\n  SymbolAtom,\n  UnaryOperatorAtom,\n  UnionAtom,\n  XorAtom,\n} from './atoms';\nimport { parseDateString } from './date';\nimport { tokenize } from './tokenize';\nimport { toTypedValue } from './utils';\n\n/**\n * Operator precedence\n * See: https://hl7.org/fhirpath/#operator-precedence\n */\nexport const OperatorPrecedence = {\n  FunctionCall: 0,\n  Dot: 1,\n  Indexer: 2,\n  UnaryAdd: 3,\n  UnarySubtract: 3,\n  Multiply: 4,\n  Divide: 4,\n  IntegerDivide: 4,\n  Modulo: 4,\n  Add: 5,\n  Subtract: 5,\n  Ampersand: 5,\n  Is: 6,\n  As: 6,\n  Union: 7,\n  GreaterThan: 8,\n  GreaterThanOrEquals: 8,\n  LessThan: 8,\n  LessThanOrEquals: 8,\n  Equals: 9,\n  Equivalent: 9,\n  NotEquals: 9,\n  NotEquivalent: 9,\n  In: 10,\n  Contains: 10,\n  And: 11,\n  Xor: 12,\n  Or: 12,\n  Implies: 13,\n  Arrow: 100,\n  Semicolon: 200,\n};\n\nconst PARENTHESES_PARSELET: PrefixParselet = {\n  parse(parser: Parser) {\n    const expr = parser.consumeAndParse();\n    if (!parser.match(')')) {\n      throw new Error('Parse error: expected `)` got `' + parser.peek()?.value + '`');\n    }\n    return expr;\n  },\n};\n\nconst INDEXER_PARSELET: InfixParselet = {\n  parse(parser: Parser, left: Atom) {\n    const expr = parser.consumeAndParse();\n    if (!parser.match(']')) {\n      throw new Error('Parse error: expected `]`');\n    }\n    return new IndexerAtom(left, expr);\n  },\n\n  precedence: OperatorPrecedence.Indexer,\n};\n\nconst FUNCTION_CALL_PARSELET: InfixParselet = {\n  parse(parser: Parser, left: Atom) {\n    if (!(left instanceof SymbolAtom)) {\n      throw new Error('Unexpected parentheses');\n    }\n\n    const args = [];\n    while (!parser.match(')')) {\n      args.push(parser.consumeAndParse());\n      parser.match(',');\n    }\n\n    return new FunctionAtom(left.name, args); //, functions[left.name]);\n  },\n  precedence: OperatorPrecedence.FunctionCall,\n};\n\nfunction parseQuantity(str: string): Quantity {\n  const parts = str.split(' ');\n  const value = parseFloat(parts[0]);\n  let unit = parts[1];\n  if (unit?.startsWith(\"'\") && unit.endsWith(\"'\")) {\n    unit = unit.substring(1, unit.length - 1);\n  } else {\n    unit = '{' + unit + '}';\n  }\n  return { value, unit };\n}\n\nexport function initFhirPathParserBuilder(): ParserBuilder {\n  return new ParserBuilder()\n    .registerPrefix('String', {\n      parse: (_, token) => new LiteralAtom({ type: PropertyType.string, value: token.value }),\n    })\n    .registerPrefix('DateTime', {\n      parse: (_, token) => new LiteralAtom({ type: PropertyType.dateTime, value: parseDateString(token.value) }),\n    })\n    .registerPrefix('Quantity', {\n      parse: (_, token) => new LiteralAtom({ type: PropertyType.Quantity, value: parseQuantity(token.value) }),\n    })\n    .registerPrefix('Number', {\n      parse: (_, token) =>\n        new LiteralAtom({\n          type: token.value.includes('.') ? PropertyType.decimal : PropertyType.integer,\n          value: parseFloat(token.value),\n        }),\n    })\n    .registerPrefix('true', { parse: () => new LiteralAtom({ type: PropertyType.boolean, value: true }) })\n    .registerPrefix('false', { parse: () => new LiteralAtom({ type: PropertyType.boolean, value: false }) })\n    .registerPrefix('Symbol', { parse: (_, token) => new SymbolAtom(token.value) })\n    .registerPrefix('{}', { parse: () => new EmptySetAtom() })\n    .registerPrefix('(', PARENTHESES_PARSELET)\n    .registerInfix('[', INDEXER_PARSELET)\n    .registerInfix('(', FUNCTION_CALL_PARSELET)\n    .prefix('+', OperatorPrecedence.UnaryAdd, (_, right) => new UnaryOperatorAtom('+', right, (x) => x))\n    .prefix(\n      '-',\n      OperatorPrecedence.UnarySubtract,\n      (_, right) => new ArithemticOperatorAtom('-', right, right, (_, y) => -y)\n    )\n    .infixLeft('.', OperatorPrecedence.Dot, (left, _, right) => new DotAtom(left, right))\n    .infixLeft(\n      '/',\n      OperatorPrecedence.Divide,\n      (left, _, right) => new ArithemticOperatorAtom('/', left, right, (x, y) => x / y)\n    )\n    .infixLeft(\n      '*',\n      OperatorPrecedence.Multiply,\n      (left, _, right) => new ArithemticOperatorAtom('*', left, right, (x, y) => x * y)\n    )\n    .infixLeft(\n      '+',\n      OperatorPrecedence.Add,\n      (left, _, right) => new ArithemticOperatorAtom('+', left, right, (x, y) => x + y)\n    )\n    .infixLeft(\n      '-',\n      OperatorPrecedence.Subtract,\n      (left, _, right) => new ArithemticOperatorAtom('-', left, right, (x, y) => x - y)\n    )\n    .infixLeft('|', OperatorPrecedence.Union, (left, _, right) => new UnionAtom(left, right))\n    .infixLeft('=', OperatorPrecedence.Equals, (left, _, right) => new EqualsAtom(left, right))\n    .infixLeft('!=', OperatorPrecedence.NotEquals, (left, _, right) => new NotEqualsAtom(left, right))\n    .infixLeft('~', OperatorPrecedence.Equivalent, (left, _, right) => new EquivalentAtom(left, right))\n    .infixLeft('!~', OperatorPrecedence.NotEquivalent, (left, _, right) => new NotEquivalentAtom(left, right))\n    .infixLeft(\n      '<',\n      OperatorPrecedence.LessThan,\n      (left, _, right) => new ArithemticOperatorAtom('<', left, right, (x, y) => x < y)\n    )\n    .infixLeft(\n      '<=',\n      OperatorPrecedence.LessThanOrEquals,\n      (left, _, right) => new ArithemticOperatorAtom('<=', left, right, (x, y) => x <= y)\n    )\n    .infixLeft(\n      '>',\n      OperatorPrecedence.GreaterThan,\n      (left, _, right) => new ArithemticOperatorAtom('>', left, right, (x, y) => x > y)\n    )\n    .infixLeft(\n      '>=',\n      OperatorPrecedence.GreaterThanOrEquals,\n      (left, _, right) => new ArithemticOperatorAtom('>=', left, right, (x, y) => x >= y)\n    )\n    .infixLeft('&', OperatorPrecedence.Ampersand, (left, _, right) => new ConcatAtom(left, right))\n    .infixLeft('and', OperatorPrecedence.And, (left, _, right) => new AndAtom(left, right))\n    .infixLeft('as', OperatorPrecedence.As, (left, _, right) => new AsAtom(left, right))\n    .infixLeft('contains', OperatorPrecedence.Contains, (left, _, right) => new ContainsAtom(left, right))\n    .infixLeft(\n      'div',\n      OperatorPrecedence.Divide,\n      (left, _, right) => new ArithemticOperatorAtom('div', left, right, (x, y) => (x / y) | 0)\n    )\n    .infixLeft('in', OperatorPrecedence.In, (left, _, right) => new InAtom(left, right))\n    .infixLeft('is', OperatorPrecedence.Is, (left, _, right) => new IsAtom(left, right))\n    .infixLeft(\n      'mod',\n      OperatorPrecedence.Modulo,\n      (left, _, right) => new ArithemticOperatorAtom('mod', left, right, (x, y) => x % y)\n    )\n    .infixLeft('or', OperatorPrecedence.Or, (left, _, right) => new OrAtom(left, right))\n    .infixLeft('xor', OperatorPrecedence.Xor, (left, _, right) => new XorAtom(left, right))\n    .infixLeft('implies', OperatorPrecedence.Implies, (left, _, right) => new ImpliesAtom(left, right));\n}\n\nconst fhirPathParserBuilder = initFhirPathParserBuilder();\n\n/**\n * Parses a FHIRPath expression into an AST.\n * The result can be used to evaluate the expression against a resource or other object.\n * This method is useful if you know that you will evaluate the same expression many times\n * against different resources.\n * @param input - The FHIRPath expression to parse.\n * @returns The AST representing the expression.\n */\nexport function parseFhirPath(input: string): FhirPathAtom {\n  return new FhirPathAtom(input, fhirPathParserBuilder.construct(tokenize(input)).consumeAndParse());\n}\n\n/**\n * Evaluates a FHIRPath expression against a resource or other object.\n * @param expression - The FHIRPath expression to evaluate.\n * @param input - The resource or object to evaluate the expression against.\n * @returns The result of the FHIRPath expression against the resource or object.\n */\nexport function evalFhirPath(expression: string | FhirPathAtom, input: unknown): unknown[] {\n  // eval requires a TypedValue array\n  // As a convenience, we can accept array or non-array, and TypedValue or unknown value\n  const array = Array.isArray(input) ? input : [input];\n  for (let i = 0; i < array.length; i++) {\n    const el = array[i];\n    if (!(typeof el === 'object' && 'type' in el && 'value' in el)) {\n      array[i] = toTypedValue(array[i]);\n    }\n  }\n  return evalFhirPathTyped(expression, array).map((e) => e.value);\n}\n\n/**\n * Evaluates a FHIRPath expression against a resource or other object.\n * @param expression - The FHIRPath expression to evaluate.\n * @param input - The resource or object to evaluate the expression against.\n * @param variables - A map of variables for eval input.\n * @param cache - Cache for parsed ASTs.\n * @returns The result of the FHIRPath expression against the resource or object.\n */\nexport function evalFhirPathTyped(\n  expression: string | FhirPathAtom,\n  input: TypedValue[],\n  variables: Record<string, TypedValue> = {},\n  cache: LRUCache<FhirPathAtom> | undefined = undefined\n): TypedValue[] {\n  let ast: FhirPathAtom;\n  if (typeof expression === 'string') {\n    const cachedAst = cache?.get(expression);\n    ast = cachedAst ?? parseFhirPath(expression);\n    if (cache && !cachedAst) {\n      cache.set(expression, ast);\n    }\n  } else {\n    ast = expression;\n  }\n  return ast.eval({ variables }, input).map((v) => ({\n    type: v.type,\n    value: v.value?.valueOf(),\n  }));\n}\n", "import { ElementDefinitionType, SearchParameter } from '@medplum/fhirtypes';\nimport { Atom } from '../fhirlexer/parse';\nimport {\n  AsAtom,\n  BooleanInfixOperatorAtom,\n  DotAtom,\n  FhirPathAtom,\n  FunctionAtom,\n  IndexerAtom,\n  IsAtom,\n  UnionAtom,\n} from '../fhirpath/atoms';\nimport { parseFhirPath } from '../fhirpath/parse';\nimport { PropertyType, getElementDefinition, globalSchema } from '../types';\nimport { InternalSchemaElement } from '../typeschema/types';\nimport { lazy } from '../utils';\n\nexport const SearchParameterType = {\n  BOOLEAN: 'BOOLEAN',\n  NUMBER: 'NUMBER',\n  QUANTITY: 'QUANTITY',\n  TEXT: 'TEXT',\n  REFERENCE: 'REFERENCE',\n  CANONICAL: 'CANONICAL',\n  DATE: 'DATE',\n  DATETIME: 'DATETIME',\n  PERIOD: 'PERIOD',\n  UUID: 'UUID',\n} as const;\nexport type SearchParameterType = (typeof SearchParameterType)[keyof typeof SearchParameterType];\n\nexport interface SearchParameterDetails {\n  readonly type: SearchParameterType;\n  readonly elementDefinitions?: InternalSchemaElement[];\n  readonly parsedExpression: FhirPathAtom;\n  readonly array?: boolean;\n}\n\ninterface SearchParameterDetailsBuilder {\n  elementDefinitions: InternalSchemaElement[];\n  propertyTypes: Set<string>;\n  array: boolean;\n}\n\n/**\n * Returns the type details of a SearchParameter.\n *\n * The SearchParameter resource has a \"type\" parameter, but that is missing some critical information.\n *\n * For example:\n *   1) The \"date\" type includes \"date\", \"datetime\", and \"period\".\n *   2) The \"token\" type includes enums and booleans.\n *   3) Arrays/multiple values are not reflected at all.\n * @param resourceType - The root resource type.\n * @param searchParam - The search parameter.\n * @returns The search parameter type details.\n */\nexport function getSearchParameterDetails(resourceType: string, searchParam: SearchParameter): SearchParameterDetails {\n  let result: SearchParameterDetails | undefined =\n    globalSchema.types[resourceType]?.searchParamsDetails?.[searchParam.code as string];\n  if (!result) {\n    result = buildSearchParameterDetails(resourceType, searchParam);\n  }\n  return result;\n}\n\nfunction setSearchParameterDetails(resourceType: string, code: string, details: SearchParameterDetails): void {\n  let typeSchema = globalSchema.types[resourceType];\n  if (!typeSchema) {\n    typeSchema = {};\n    globalSchema.types[resourceType] = typeSchema;\n  }\n  if (!typeSchema.searchParamsDetails) {\n    typeSchema.searchParamsDetails = {};\n  }\n  typeSchema.searchParamsDetails[code] = details;\n}\n\nfunction buildSearchParameterDetails(resourceType: string, searchParam: SearchParameter): SearchParameterDetails {\n  const code = searchParam.code as string;\n  const expressions = getExpressionsForResourceType(resourceType, searchParam.expression as string);\n\n  const builder: SearchParameterDetailsBuilder = {\n    elementDefinitions: [],\n    propertyTypes: new Set(),\n    array: false,\n  };\n\n  for (const expression of expressions) {\n    const atomArray = flattenAtom(expression);\n    const flattenedExpression = lazy(() => atomArray.join('.'));\n\n    if (atomArray.length === 1 && atomArray[0] instanceof BooleanInfixOperatorAtom) {\n      builder.propertyTypes.add('boolean');\n    } else if (searchParam.code.endsWith(':identifier')) {\n      // This is a derived \"identifier\" search parameter\n      // See `deriveIdentifierSearchParameter`\n      builder.propertyTypes.add('Identifier');\n    } else if (\n      // To support US Core Patient search parameters without needing profile-aware logic,\n      // assume expressions for `Extension.value[x].code` and `Extension.value[x].coding.code`\n      // are of type `code`. Otherwise, crawling the Extension.value[x] element definition without\n      // access to the type narrowing specified in the profiles would be inconclusive.\n      flattenedExpression().endsWith('extension.value.code') ||\n      flattenedExpression().endsWith('extension.value.coding.code')\n    ) {\n      builder.array = true;\n      builder.propertyTypes.add('code');\n    } else {\n      crawlSearchParameterDetails(builder, atomArray, resourceType, 1);\n    }\n\n    // To support US Core \"us-core-condition-asserted-date\" search parameter without\n    // needing profile-aware logic, ensure extensions with a dateTime value are not\n    // treated as arrays since Mepdlum search functionality does not yet support datetime arrays.\n    // This would be the result if the http://hl7.org/fhir/StructureDefinition/condition-assertedDate\n    // extension were parsed since it specifies a cardinality of 0..1.\n    if (flattenedExpression().endsWith('extension.valueDateTime')) {\n      builder.array = false;\n    }\n  }\n\n  const result: SearchParameterDetails = {\n    type: getSearchParameterType(searchParam, builder.propertyTypes),\n    elementDefinitions: builder.elementDefinitions,\n    parsedExpression: getParsedExpressionForResourceType(resourceType, searchParam.expression as string),\n    array: builder.array,\n  };\n  setSearchParameterDetails(resourceType, code, result);\n  return result;\n}\n\nfunction crawlSearchParameterDetails(\n  details: SearchParameterDetailsBuilder,\n  atoms: Atom[],\n  baseType: string,\n  index: number\n): void {\n  const currAtom = atoms[index];\n\n  if (currAtom instanceof AsAtom) {\n    details.propertyTypes.add(currAtom.right.toString());\n    return;\n  }\n\n  if (currAtom instanceof FunctionAtom) {\n    handleFunctionAtom(details, currAtom);\n    return;\n  }\n\n  const propertyName = currAtom.toString();\n  const elementDefinition = getElementDefinition(baseType, propertyName);\n  if (!elementDefinition) {\n    throw new Error(`Element definition not found for ${baseType} ${propertyName}`);\n  }\n\n  let hasArrayIndex = false;\n  let nextIndex = index + 1;\n  if (nextIndex < atoms.length && atoms[nextIndex] instanceof IndexerAtom) {\n    hasArrayIndex = true;\n    nextIndex++;\n  }\n\n  const nextAtom = atoms[nextIndex];\n\n  if (elementDefinition.isArray && !hasArrayIndex) {\n    details.array = true;\n  }\n\n  if (nextIndex === atoms.length - 1 && nextAtom instanceof AsAtom) {\n    // This is the 2nd to last atom in the expression\n    // And the last atom is an \"as\" expression\n    details.elementDefinitions.push(elementDefinition);\n    details.propertyTypes.add(nextAtom.right.toString());\n    return;\n  }\n\n  if (nextIndex >= atoms.length) {\n    // This is the final atom in the expression\n    // So we can collect the ElementDefinition and property types\n    details.elementDefinitions.push(elementDefinition);\n    for (const elementDefinitionType of elementDefinition.type as ElementDefinitionType[]) {\n      details.propertyTypes.add(elementDefinitionType.code as string);\n    }\n    return;\n  }\n\n  // This is in the middle of the expression, so we need to keep crawling.\n  // \"code\" is only missing when using \"contentReference\"\n  // \"contentReference\" is handled whe parsing StructureDefinition into InternalTypeSchema\n  for (const elementDefinitionType of elementDefinition.type as ElementDefinitionType[]) {\n    let propertyType = elementDefinitionType.code as string;\n    if (isBackboneElement(propertyType)) {\n      propertyType = elementDefinition.type[0].code;\n    }\n    crawlSearchParameterDetails(details, atoms, propertyType, nextIndex);\n  }\n}\n\nfunction handleFunctionAtom(builder: SearchParameterDetailsBuilder, functionAtom: FunctionAtom): void {\n  if (functionAtom.name === 'as') {\n    builder.propertyTypes.add(functionAtom.args[0].toString());\n    return;\n  }\n\n  if (functionAtom.name === 'ofType') {\n    builder.propertyTypes.add(functionAtom.args[0].toString());\n    return;\n  }\n\n  if (functionAtom.name === 'resolve') {\n    // Handle .resolve().resourceType\n    builder.propertyTypes.add('string');\n    return;\n  }\n\n  if (functionAtom.name === 'where' && functionAtom.args[0] instanceof IsAtom) {\n    // Common pattern: \"where(resolve() is Patient)\"\n    // Use the type information\n    builder.propertyTypes.add(functionAtom.args[0].right.toString());\n    return;\n  }\n\n  throw new Error(`Unhandled FHIRPath function: ${functionAtom.name}`);\n}\n\nfunction isBackboneElement(propertyType: string): boolean {\n  return propertyType === 'Element' || propertyType === 'BackboneElement';\n}\n\nfunction getSearchParameterType(searchParam: SearchParameter, propertyTypes: Set<string>): SearchParameterType {\n  switch (searchParam.type) {\n    case 'date':\n      if (propertyTypes.size === 1 && propertyTypes.has(PropertyType.date)) {\n        return SearchParameterType.DATE;\n      } else {\n        return SearchParameterType.DATETIME;\n      }\n    case 'number':\n      return SearchParameterType.NUMBER;\n    case 'quantity':\n      return SearchParameterType.QUANTITY;\n    case 'reference':\n      if (propertyTypes.has(PropertyType.canonical)) {\n        return SearchParameterType.CANONICAL;\n      } else {\n        return SearchParameterType.REFERENCE;\n      }\n    case 'token':\n      if (propertyTypes.size === 1 && propertyTypes.has(PropertyType.boolean)) {\n        return SearchParameterType.BOOLEAN;\n      } else {\n        return SearchParameterType.TEXT;\n      }\n    default:\n      return SearchParameterType.TEXT;\n  }\n}\n\nexport function getExpressionsForResourceType(resourceType: string, expression: string): Atom[] {\n  const result: Atom[] = [];\n  const fhirPathExpression = parseFhirPath(expression);\n  buildExpressionsForResourceType(resourceType, fhirPathExpression.child, result);\n  return result;\n}\n\nexport function getExpressionForResourceType(resourceType: string, expression: string): string | undefined {\n  const atoms = getExpressionsForResourceType(resourceType, expression);\n  if (atoms.length === 0) {\n    return undefined;\n  }\n  return atoms.map((atom) => atom.toString()).join(' | ');\n}\n\nexport function getParsedExpressionForResourceType(resourceType: string, expression: string): FhirPathAtom {\n  const atoms: Atom[] = [];\n  const fhirPathExpression = parseFhirPath(expression);\n  buildExpressionsForResourceType(resourceType, fhirPathExpression.child, atoms);\n\n  if (atoms.length === 0) {\n    return fhirPathExpression;\n  }\n\n  let result: Atom = atoms[0];\n  for (let i = 1; i < atoms.length; i++) {\n    result = new UnionAtom(result, atoms[i]);\n  }\n  return new FhirPathAtom('<original-not-available>', result);\n}\n\nfunction buildExpressionsForResourceType(resourceType: string, atom: Atom, result: Atom[]): void {\n  if (atom instanceof UnionAtom) {\n    buildExpressionsForResourceType(resourceType, atom.left, result);\n    buildExpressionsForResourceType(resourceType, atom.right, result);\n  } else {\n    const str = atom.toString();\n    if (str.includes(resourceType + '.')) {\n      result.push(atom);\n    }\n  }\n}\n\nfunction flattenAtom(atom: Atom): Atom[] {\n  if (atom instanceof AsAtom || atom instanceof IndexerAtom) {\n    return [flattenAtom(atom.left), atom].flat();\n  }\n  if (atom instanceof BooleanInfixOperatorAtom) {\n    return [atom];\n  }\n  if (atom instanceof DotAtom) {\n    return [flattenAtom(atom.left), flattenAtom(atom.right)].flat();\n  }\n  if (atom instanceof FunctionAtom) {\n    if (atom.name === 'where' && !(atom.args[0] instanceof IsAtom)) {\n      // Remove all \"where\" functions other than \"where(x as type)\"\n      return [];\n    }\n    if (atom.name === 'last') {\n      // Remove all \"last\" functions\n      return [];\n    }\n  }\n  return [atom];\n}\n", "import { Resource, ResourceType, SearchParameter } from '@medplum/fhirtypes';\nimport { evalFhirPathTyped } from '../fhirpath/parse';\nimport { isDateTimeString } from '../fhirpath/utils';\nimport { OperationOutcomeError, badRequest } from '../outcomes';\nimport { TypedValue, globalSchema, stringifyTypedValue } from '../types';\nimport { append, sortStringArray } from '../utils';\n\nexport const DEFAULT_SEARCH_COUNT = 20;\nexport const DEFAULT_MAX_SEARCH_COUNT = 1000;\n\nexport interface SearchRequest<T extends Resource = Resource> {\n  readonly resourceType: T['resourceType'];\n  filters?: Filter[];\n  sortRules?: SortRule[];\n  cursor?: string;\n  offset?: number;\n  count?: number;\n  fields?: string[];\n  name?: string;\n  total?: 'none' | 'estimate' | 'accurate';\n  include?: IncludeTarget[];\n  revInclude?: IncludeTarget[];\n  summary?: 'true' | 'text' | 'data';\n  format?: string;\n  pretty?: boolean;\n  types?: T['resourceType'][];\n}\n\nexport interface Filter {\n  code: string;\n  operator: Operator;\n  value: string;\n}\n\nexport interface SortRule {\n  code: string;\n  descending?: boolean;\n}\n\nexport interface IncludeTarget {\n  resourceType: string;\n  searchParam: string;\n  targetType?: string;\n  modifier?: 'iterate';\n}\n\n/**\n * Search operators.\n * These operators represent \"modifiers\" and \"prefixes\" in FHIR search.\n * See: https://www.hl7.org/fhir/search.html\n */\nexport const Operator = {\n  EQUALS: 'eq',\n  NOT_EQUALS: 'ne',\n\n  // Numbers\n  GREATER_THAN: 'gt',\n  LESS_THAN: 'lt',\n  GREATER_THAN_OR_EQUALS: 'ge',\n  LESS_THAN_OR_EQUALS: 'le',\n\n  // Dates\n  STARTS_AFTER: 'sa',\n  ENDS_BEFORE: 'eb',\n  APPROXIMATELY: 'ap',\n\n  // String\n  CONTAINS: 'contains',\n  STARTS_WITH: 'sw',\n  EXACT: 'exact',\n\n  // Token\n  TEXT: 'text',\n  NOT: 'not',\n  ABOVE: 'above',\n  BELOW: 'below',\n  IN: 'in',\n  NOT_IN: 'not-in',\n  OF_TYPE: 'of-type',\n\n  // All\n  MISSING: 'missing',\n  PRESENT: 'present',\n\n  // Reference\n  IDENTIFIER: 'identifier',\n\n  // _include and _revinclude\n  ITERATE: 'iterate',\n} as const;\nexport type Operator = (typeof Operator)[keyof typeof Operator];\n\n/**\n * Parameter names may specify a modifier as a suffix.\n * The modifiers are separated from the parameter name by a colon.\n * See: https://www.hl7.org/fhir/search.html#modifiers\n */\nconst MODIFIER_OPERATORS: Record<string, Operator> = {\n  contains: Operator.CONTAINS,\n  exact: Operator.EXACT,\n  above: Operator.ABOVE,\n  below: Operator.BELOW,\n  text: Operator.TEXT,\n  not: Operator.NOT,\n  in: Operator.IN,\n  'not-in': Operator.NOT_IN,\n  'of-type': Operator.OF_TYPE,\n  missing: Operator.MISSING,\n  identifier: Operator.IDENTIFIER,\n  iterate: Operator.ITERATE,\n};\n\n/**\n * For the ordered parameter types of number, date, and quantity,\n * a prefix to the parameter value may be used to control the nature\n * of the matching.\n * See: https://www.hl7.org/fhir/search.html#prefix\n */\nconst PREFIX_OPERATORS: Record<string, Operator> = {\n  eq: Operator.EQUALS,\n  ne: Operator.NOT_EQUALS,\n  lt: Operator.LESS_THAN,\n  le: Operator.LESS_THAN_OR_EQUALS,\n  gt: Operator.GREATER_THAN,\n  ge: Operator.GREATER_THAN_OR_EQUALS,\n  sa: Operator.STARTS_AFTER,\n  eb: Operator.ENDS_BEFORE,\n  ap: Operator.APPROXIMATELY,\n  sw: Operator.STARTS_WITH,\n};\n\n/**\n * Parses a search URL into a search request.\n * @param url - The original search URL or the FHIR resource type.\n * @param query - Optional collection of additional query string parameters.\n * @returns A parsed SearchRequest.\n */\nexport function parseSearchRequest<T extends Resource = Resource>(\n  url: T['resourceType'] | URL | string,\n  query?: Record<string, string[] | string | undefined>\n): SearchRequest<T> {\n  if (!url) {\n    throw new Error('Invalid search URL');\n  }\n\n  // Parse the input into path and search parameters\n  let pathname = '';\n  let searchParams: URLSearchParams | undefined = undefined;\n  if (typeof url === 'string') {\n    if (url.includes('?')) {\n      const [path, search] = url.split('?');\n      pathname = path;\n      searchParams = new URLSearchParams(search);\n    } else {\n      pathname = url;\n    }\n  } else if (typeof url === 'object') {\n    pathname = url.pathname;\n    searchParams = url.searchParams;\n  }\n\n  // Next, parse out the resource type from the URL\n  // By convention, the resource type is the last non-empty part of the path\n  let resourceType: ResourceType;\n  if (pathname.includes('/')) {\n    resourceType = pathname.split('/').filter(Boolean).pop() as ResourceType;\n  } else {\n    resourceType = pathname as ResourceType;\n  }\n\n  // Next, parse out the search parameters\n  // First, we convert the URLSearchParams to an array of key-value pairs\n  const queryArray: [string, string][] = [];\n  if (searchParams) {\n    queryArray.push(...searchParams.entries());\n  }\n\n  // Next, we merge in the query object\n  // This is an optional set of additional query parameters\n  // which should be added to the URL\n  if (query) {\n    for (const [key, value] of Object.entries(query)) {\n      if (Array.isArray(value)) {\n        for (const v of value) {\n          queryArray.push([key, v]);\n        }\n      } else {\n        queryArray.push([key, value ?? '']);\n      }\n    }\n  }\n\n  // Finally we can move on to the actual parsing\n  return parseSearchImpl(resourceType, queryArray);\n}\n\nfunction parseSearchImpl<T extends Resource = Resource>(\n  resourceType: T['resourceType'],\n  query: Iterable<[string, string]>\n): SearchRequest<T> {\n  const searchRequest: SearchRequest<T> = {\n    resourceType,\n  };\n\n  for (const [key, value] of query) {\n    parseKeyValue(searchRequest, key, value);\n  }\n\n  return searchRequest;\n}\n\nfunction parseKeyValue(searchRequest: SearchRequest, key: string, value: string): void {\n  let code: string;\n  let modifier: string;\n\n  const colonIndex = key.indexOf(':');\n  if (colonIndex >= 0) {\n    code = key.substring(0, colonIndex);\n    modifier = key.substring(colonIndex + 1);\n  } else {\n    code = key;\n    modifier = '';\n  }\n\n  // Ignore the '_' parameter\n  // This is added by React Native when `no-cache` strategy is used to bust the cache presumably\n  if (code === '_') {\n    return;\n  }\n\n  if (code === '_has' || key.includes('.')) {\n    searchRequest.filters = append(searchRequest.filters, { code: key, operator: Operator.EQUALS, value });\n    return;\n  }\n\n  switch (code) {\n    case '_sort':\n      parseSortRule(searchRequest, value);\n      break;\n\n    case '_cursor':\n      searchRequest.cursor = value;\n      break;\n\n    case '_count':\n      searchRequest.count = parseInt(value, 10);\n      break;\n\n    case '_offset':\n      searchRequest.offset = parseInt(value, 10);\n      break;\n\n    case '_total':\n      searchRequest.total = value as 'none' | 'estimate' | 'accurate';\n      break;\n\n    case '_summary':\n      if (value === 'count') {\n        searchRequest.total = 'accurate';\n        searchRequest.count = 0;\n      } else if (value === 'true' || value === 'data' || value === 'text') {\n        searchRequest.summary = value;\n      }\n      break;\n\n    case '_include': {\n      const target = parseIncludeTarget(value);\n      if (modifier === 'iterate') {\n        target.modifier = Operator.ITERATE;\n      }\n      searchRequest.include = append(searchRequest.include, target);\n      break;\n    }\n\n    case '_revinclude': {\n      const target = parseIncludeTarget(value);\n      if (modifier === 'iterate') {\n        target.modifier = Operator.ITERATE;\n      }\n      searchRequest.revInclude = append(searchRequest.revInclude, target);\n      break;\n    }\n\n    case '_fields':\n    case '_elements':\n      searchRequest.fields = value.split(',');\n      break;\n\n    case '_type':\n      searchRequest.types = value.split(',') as Resource['resourceType'][];\n      break;\n\n    case '_format':\n      searchRequest.format = value;\n      break;\n\n    case '_pretty':\n      searchRequest.pretty = value === 'true';\n      break;\n\n    default: {\n      const param = globalSchema.types[searchRequest.resourceType]?.searchParams?.[code];\n      if (param) {\n        searchRequest.filters = append(searchRequest.filters, parseParameter(param, modifier, value));\n      } else {\n        searchRequest.filters = append(searchRequest.filters, parseUnknownParameter(code, modifier, value));\n      }\n    }\n  }\n}\n\nfunction parseSortRule(searchRequest: SearchRequest, value: string): void {\n  for (const field of value.split(',')) {\n    let code: string;\n    let descending = false;\n    if (field.startsWith('-')) {\n      code = field.substring(1);\n      descending = true;\n    } else {\n      code = field;\n    }\n    if (!searchRequest.sortRules) {\n      searchRequest.sortRules = [];\n    }\n    searchRequest.sortRules.push({ code, descending });\n  }\n}\n\nconst presenceOperators: Operator[] = [Operator.MISSING, Operator.PRESENT];\nexport function parseParameter(searchParam: SearchParameter, modifier: string, value: string): Filter {\n  if (presenceOperators.includes(modifier as Operator)) {\n    return {\n      code: searchParam.code,\n      operator: modifier as Operator,\n      value,\n    };\n  }\n\n  switch (searchParam.type) {\n    // Ordered types that can have a prefix modifier on the value\n    case 'number':\n    case 'date':\n    case 'quantity': {\n      const { operator, value: searchValue } = parsePrefix(value);\n      if (!isValidSearchValue(searchParam, searchValue)) {\n        throw new OperationOutcomeError(\n          badRequest(`Invalid format for ${searchParam.type} search parameter: ${searchValue}`)\n        );\n      }\n      return { code: searchParam.code, operator, value: searchValue };\n    }\n\n    // Lookup types that support a variety of modifiers on the search parameter\n    case 'reference':\n    case 'string':\n    case 'token':\n    case 'uri':\n      if (!isValidSearchValue(searchParam, value)) {\n        throw new OperationOutcomeError(\n          badRequest(`Invalid format for ${searchParam.type} search parameter: ${value}`)\n        );\n      }\n      return { code: searchParam.code, operator: parseModifier(modifier), value };\n\n    default:\n      throw new Error('Unrecognized search parameter type: ' + searchParam.type);\n  }\n}\n\nfunction parseUnknownParameter(code: string, modifier: string, value: string): Filter {\n  let operator: Operator = Operator.EQUALS;\n  if (modifier) {\n    operator = modifier as Operator;\n  } else if (value.length >= 2) {\n    const prefix = value.substring(0, 2);\n    if (prefix in PREFIX_OPERATORS) {\n      if (value.length === 2 || value.at(2)?.match(/\\d/)) {\n        operator = prefix as Operator;\n        value = value.substring(prefix.length);\n      }\n    }\n  }\n  return { code, operator, value };\n}\n\nfunction parsePrefix(input: string): { operator: Operator; value: string } {\n  const prefix = input.substring(0, 2);\n  const prefixOperator = PREFIX_OPERATORS[prefix];\n  if (prefixOperator) {\n    return { operator: prefixOperator, value: input.substring(2) };\n  }\n  return { operator: Operator.EQUALS, value: input };\n}\n\nfunction parseModifier(modifier: string): Operator {\n  return MODIFIER_OPERATORS[modifier] ?? Operator.EQUALS;\n}\n\nfunction parseIncludeTarget(input: string): IncludeTarget {\n  const parts = input.split(':');\n\n  if (parts.includes('*')) {\n    throw new OperationOutcomeError(badRequest(`'*' is not supported as a value for search inclusion parameters`));\n  }\n\n  if (parts.length === 1) {\n    // Full wildcard, not currently supported\n    throw new OperationOutcomeError(\n      badRequest(`Invalid include value '${input}': must be of the form ResourceType:search-parameter`)\n    );\n  } else if (parts.length === 2) {\n    return {\n      resourceType: parts[0],\n      searchParam: parts[1],\n    };\n  } else if (parts.length === 3) {\n    return {\n      resourceType: parts[0],\n      searchParam: parts[1],\n      targetType: parts[2],\n    };\n  } else {\n    throw new OperationOutcomeError(badRequest(`Invalid include value '${input}'`));\n  }\n}\n\nfunction isValidSearchValue(searchParam: SearchParameter, searchValue: string): boolean {\n  switch (searchParam.type) {\n    case 'date':\n      return isDateTimeString(searchValue);\n    default:\n      return true;\n  }\n}\n\nconst subexpressionPattern = /{{([^{}]+)}}/g;\n\n/**\n * Parses an extended FHIR search criteria string (i.e. application/x-fhir-query).\n *\n * @example Evaluating a FHIRPath subexpression\n *\n * ```typescript\n * const query = 'Patient?name={{ %patient.name }}';\n * const variables = { patient: { name: 'John Doe' } };\n * const request = parseXFhirQuery(query, variables);\n * console.log(request.filters[0].value); // \"John Doe\"\n * ```\n *\n * @see https://hl7.org/fhir/fhir-xquery.html\n * @param query - The X-Fhir-Query string to parse\n * @param variables - Values to pass into embedded FHIRPath expressions\n * @returns The parsed search request\n */\nexport function parseXFhirQuery(query: string, variables: Record<string, TypedValue>): SearchRequest {\n  query = query.replaceAll(subexpressionPattern, (_, expr) => {\n    const replacement = evalFhirPathTyped(expr, [], variables);\n    if (replacement.length !== 1) {\n      return '';\n    }\n    return stringifyTypedValue(replacement[0]);\n  });\n  return parseSearchRequest(query);\n}\n\n/**\n * Formats a search definition object into a query string.\n * Note: The return value does not include the resource type.\n * @param definition - The search definition.\n * @returns Formatted URL.\n */\nexport function formatSearchQuery(definition: SearchRequest): string {\n  const params: string[] = [];\n\n  if (definition.fields) {\n    params.push('_fields=' + definition.fields.join(','));\n  }\n\n  if (definition.filters) {\n    definition.filters.forEach((filter) => params.push(formatFilter(filter)));\n  }\n\n  if (definition.sortRules && definition.sortRules.length > 0) {\n    params.push(formatSortRules(definition.sortRules));\n  }\n\n  if (definition.cursor !== undefined) {\n    params.push('_cursor=' + encodeURIComponent(definition.cursor));\n  }\n\n  if (definition.offset !== undefined && definition.offset !== 0) {\n    params.push('_offset=' + definition.offset);\n  }\n\n  if (definition.count !== undefined) {\n    params.push('_count=' + definition.count);\n  }\n\n  if (definition.total !== undefined) {\n    params.push('_total=' + definition.total);\n  }\n\n  if (definition.types && definition.types.length > 0) {\n    params.push('_type=' + definition.types.join(','));\n  }\n\n  if (definition.include) {\n    definition.include.forEach((target) => params.push(formatIncludeTarget('_include', target)));\n  }\n\n  if (definition.revInclude) {\n    definition.revInclude.forEach((target) => params.push(formatIncludeTarget('_revinclude', target)));\n  }\n\n  if (params.length === 0) {\n    return '';\n  }\n\n  sortStringArray(params);\n  return '?' + params.join('&');\n}\n\nfunction formatFilter(filter: Filter): string {\n  const modifier = filter.operator in MODIFIER_OPERATORS ? ':' + filter.operator : '';\n  const prefix = filter.operator !== Operator.EQUALS && filter.operator in PREFIX_OPERATORS ? filter.operator : '';\n  return `${filter.code}${modifier}=${prefix}${encodeURIComponent(filter.value)}`;\n}\n\nfunction formatSortRules(sortRules: SortRule[]): string {\n  return '_sort=' + sortRules.map((sr) => (sr.descending ? '-' + sr.code : sr.code)).join(',');\n}\n\nfunction formatIncludeTarget(kind: '_include' | '_revinclude', target: IncludeTarget): string {\n  return (\n    kind +\n    (target.modifier ? ':' + target.modifier : '') +\n    '=' +\n    target.resourceType +\n    ':' +\n    target.searchParam +\n    (target.targetType ? ':' + target.targetType : '')\n  );\n}\n\n/**\n * Splits a FHIR search value on commas.\n * Respects backslash escape.\n *\n * See: https://hl7.org/fhir/r4/search.html#escaping\n *\n * @param input - The FHIR search value to split.\n * @returns The individual search values.\n */\nexport function splitSearchOnComma(input: string): string[] {\n  const result: string[] = [];\n  let current = '';\n  let escaped = false;\n\n  for (const c of input) {\n    if (escaped) {\n      current += c;\n      escaped = false;\n    } else if (c === '\\\\') {\n      escaped = true;\n    } else if (c === ',') {\n      result.push(current);\n      current = '';\n    } else {\n      current += c;\n    }\n  }\n\n  // Push the last segment\n  result.push(current);\n  return result;\n}\n", "import { CodeableConcept, Coding, Identifier, Reference, Resource, SearchParameter } from '@medplum/fhirtypes';\nimport { evalFhirPath } from '../fhirpath/parse';\nimport { isPeriod } from '../fhirpath/utils';\nimport { PropertyType, globalSchema } from '../types';\nimport { isString } from '../utils';\nimport { SearchParameterType, getSearchParameterDetails } from './details';\nimport { Filter, Operator, SearchRequest, splitSearchOnComma } from './search';\n\n/**\n * Determines if the resource matches the search request.\n * @param resource - The resource that was created or updated.\n * @param searchRequest - The subscription criteria as a search request.\n * @returns True if the resource satisfies the search request.\n */\nexport function matchesSearchRequest(resource: Resource, searchRequest: SearchRequest): boolean {\n  if (searchRequest.resourceType !== resource.resourceType) {\n    return false;\n  }\n  if (searchRequest.filters) {\n    for (const filter of searchRequest.filters) {\n      if (!matchesSearchFilter(resource, searchRequest, filter)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * Determines if the resource matches the search filter.\n * @param resource - The resource that was created or updated.\n * @param searchRequest - The search request.\n * @param filter - One of the filters of a subscription criteria.\n * @returns True if the resource satisfies the search filter.\n */\nfunction matchesSearchFilter(resource: Resource, searchRequest: SearchRequest, filter: Filter): boolean {\n  const searchParam = globalSchema.types[searchRequest.resourceType]?.searchParams?.[filter.code];\n  if (!searchParam) {\n    return false;\n  }\n  if (filter.operator === Operator.MISSING || filter.operator === Operator.PRESENT) {\n    return matchesMissingOrPresent(resource, filter, searchParam);\n  }\n  switch (searchParam.type) {\n    case 'reference':\n      return matchesReferenceFilter(resource, filter, searchParam);\n    case 'string':\n    case 'uri':\n      return matchesStringFilter(resource, filter, searchParam);\n    case 'token':\n      return matchesTokenFilter(resource, filter, searchParam);\n    case 'date':\n      return matchesDateFilter(resource, filter, searchParam);\n    default:\n      // Unknown search parameter or search parameter type\n      // Default fail the check\n      return false;\n  }\n}\n\nfunction matchesMissingOrPresent(resource: Resource, filter: Filter, searchParam: SearchParameter): boolean {\n  const values = evalFhirPath(searchParam.expression as string, resource);\n  const exists = values.length > 0;\n  const desired =\n    (filter.operator === Operator.MISSING && filter.value === 'false') ||\n    (filter.operator === Operator.PRESENT && filter.value === 'true');\n  return desired === exists;\n}\n\nfunction matchesReferenceFilter(resource: Resource, filter: Filter, searchParam: SearchParameter): boolean {\n  const values = evalFhirPath(searchParam.expression as string, resource) as (Reference | string)[];\n  const negated = isNegated(filter.operator);\n\n  if (filter.value === '' && values.length === 0) {\n    // If the filter operator is \"equals\", then the filter matches.\n    // If the filter operator is \"not equals\", then the filter does not match.\n    return filter.operator === Operator.EQUALS;\n  }\n\n  // Normalize the values array into reference strings\n  const references = values.map((value) => (typeof value === 'string' ? value : value.reference));\n\n  for (const filterValue of splitSearchOnComma(filter.value)) {\n    let match = references.includes(filterValue);\n    if (!match && filter.code === '_compartment') {\n      // Backwards compability for compartment search parameter\n      // In previous versions, the resource type was not required in compartment values\n      // So, \"123\" would match \"Patient/123\"\n      // We need to maintain this behavior for backwards compatibility\n      match = references.some((reference) => reference?.endsWith('/' + filterValue));\n    }\n    if (match) {\n      return !negated;\n    }\n  }\n  // If \"not equals\" and no matches, then return true\n  // If \"equals\" and no matches, then return false\n  return negated;\n}\n\nfunction matchesTokenFilter(resource: Resource, filter: Filter, searchParam: SearchParameter): boolean {\n  const details = getSearchParameterDetails(resource.resourceType, searchParam);\n  if (details.type === SearchParameterType.BOOLEAN) {\n    return matchesBooleanFilter(resource, filter, searchParam);\n  } else {\n    return matchesStringFilter(resource, filter, searchParam, true);\n  }\n}\n\nfunction matchesBooleanFilter(resource: Resource, filter: Filter, searchParam: SearchParameter): boolean {\n  const values = evalFhirPath(searchParam.expression as string, resource);\n  const expected = filter.value === 'true';\n  const result = values.includes(expected);\n  return isNegated(filter.operator) ? !result : result;\n}\n\nfunction matchesStringFilter(\n  resource: Resource,\n  filter: Filter,\n  searchParam: SearchParameter,\n  asToken?: boolean\n): boolean {\n  const details = getSearchParameterDetails(resource.resourceType, searchParam);\n  const searchParamElementType = details.elementDefinitions?.[0]?.type?.[0]?.code;\n  const resourceValues = evalFhirPath(searchParam.expression as string, resource);\n  const filterValues = splitSearchOnComma(filter.value);\n  const negated = isNegated(filter.operator);\n  for (const resourceValue of resourceValues) {\n    for (const filterValue of filterValues) {\n      let match;\n      if (searchParamElementType === PropertyType.Identifier) {\n        match = matchesTokenIdentifierValue(resourceValue as Identifier, filter.operator, filterValue);\n      } else if (searchParamElementType === PropertyType.CodeableConcept) {\n        match = matchesTokenCodeableConceptValue(resourceValue as Coding, filter.operator, filterValue);\n      } else {\n        match = matchesStringValue(resourceValue, filter.operator, filterValue, asToken);\n      }\n      if (match) {\n        return !negated;\n      }\n    }\n  }\n  // If \"not equals\" and no matches, then return true\n  // If \"equals\" and no matches, then return false\n  return negated;\n}\n\nfunction matchesStringValue(\n  resourceValue: unknown,\n  operator: Operator,\n  filterValue: string,\n  asToken?: boolean\n): boolean {\n  if (asToken && filterValue.includes('|')) {\n    const [system, code] = filterValue.split('|');\n    return (\n      matchesStringValue(resourceValue, operator, system, false) &&\n      (!code || matchesStringValue(resourceValue, operator, code, false))\n    );\n  }\n  let str = '';\n  if (resourceValue) {\n    if (typeof resourceValue === 'string') {\n      str = resourceValue;\n    } else if (typeof resourceValue === 'object') {\n      str = JSON.stringify(resourceValue);\n    }\n  }\n  return str.toLowerCase().includes(filterValue.toLowerCase());\n}\n\nfunction matchesTokenIdentifierValue(resourceValue: Identifier, operator: Operator, filterValue: string): boolean {\n  if (filterValue.includes('|')) {\n    const [system, value] = filterValue.split('|').map((s) => s.toLowerCase());\n    if (!system && !value) {\n      return false;\n    } else if (!system) {\n      // [parameter]=|[code]: the value of [code] matches a Coding.code or Identifier.value, and the Coding/Identifier has no system property\n      return !resourceValue.system && resourceValue.value?.toLowerCase() === value;\n    }\n\n    // [parameter]=[system]|: any element where the value of [system] matches the system property of the Identifier or Coding\n    // [parameter]=[system]|[code]: the value of [code] matches a Coding.code or Identifier.value, and the value of [system] matches the system property of the Identifier or Coding\n    return resourceValue.system?.toLowerCase() === system && (!value || resourceValue.value?.toLowerCase() === value);\n  }\n\n  // [parameter]=[code]: the value of [code] matches a Coding.code or Identifier.value irrespective of the value of the system property\n  return resourceValue.value?.toLowerCase() === filterValue.toLowerCase();\n}\n\nfunction matchesTokenCodeableConceptValue(\n  resourceValue: CodeableConcept,\n  _operator: Operator,\n  filterValue: string\n): boolean {\n  if (filterValue.includes('|')) {\n    const [system, code] = filterValue.split('|').map((s) => s.toLowerCase());\n    if (!system && !code) {\n      return false;\n    } else if (!system) {\n      // [parameter]=|[code]: the value of [code] matches a Coding.code or Identifier.value, and the Coding/Identifier has no system property\n      return resourceValue.coding?.some((coding) => !coding.system && coding.code?.toLowerCase() === code) ?? false;\n    }\n\n    // [parameter]=[system]|: any element where the value of [system] matches the system property of the Identifier or Coding\n    // [parameter]=[system]|[code]: the value of [code] matches a Coding.code or Identifier.value, and the value of [system] matches the system property of the Identifier or Coding\n    return (\n      resourceValue.coding?.some(\n        (coding) => coding.system?.toLowerCase() === system && (!code || coding.code?.toLowerCase() === code)\n      ) ?? false\n    );\n  }\n\n  // [parameter]=[code]: the value of [code] matches a Coding.code or Identifier.value irrespective of the value of the system property\n  return (\n    resourceValue.text?.toLowerCase() === filterValue.toLowerCase() ||\n    (resourceValue.coding?.some((coding) => coding.code?.toLowerCase() === filterValue.toLowerCase()) ?? false)\n  );\n}\n\nfunction matchesDateFilter(resource: Resource, filter: Filter, searchParam: SearchParameter): boolean {\n  const resourceValues = evalFhirPath(searchParam.expression as string, resource);\n  const filterValues = splitSearchOnComma(filter.value);\n  const negated = isNegated(filter.operator);\n  for (const resourceValue of resourceValues) {\n    for (const filterValue of filterValues) {\n      const match = matchesDateValue(\n        buildDateTimeColumn(resourceValue),\n        filter.operator,\n        buildDateTimeColumn(filterValue) as string\n      );\n      if (match) {\n        return !negated;\n      }\n    }\n  }\n  // If \"not equals\" and no matches, then return true\n  // If \"equals\" and no matches, then return false\n  return negated;\n}\n\nfunction matchesDateValue(resourceValue: string | undefined, operator: Operator, filterValue: string): boolean {\n  if (!resourceValue) {\n    return false;\n  }\n  switch (operator) {\n    case Operator.STARTS_AFTER:\n    case Operator.GREATER_THAN:\n      return resourceValue > filterValue;\n    case Operator.GREATER_THAN_OR_EQUALS:\n      return resourceValue >= filterValue;\n    case Operator.ENDS_BEFORE:\n    case Operator.LESS_THAN:\n      return resourceValue < filterValue;\n    case Operator.LESS_THAN_OR_EQUALS:\n      return resourceValue <= filterValue;\n    case Operator.EQUALS:\n    case Operator.NOT_EQUALS:\n      return resourceValue === filterValue;\n    default:\n      return false;\n  }\n}\n\n/**\n * Builds the column value for a date/time parameter.\n * Tries to parse the date string.\n * Silently ignores failure.\n * @param value - The FHIRPath result.\n * @returns The date/time string if parsed; undefined otherwise.\n */\nfunction buildDateTimeColumn(value: unknown): string | undefined {\n  if (isString(value)) {\n    try {\n      const date = new Date(value);\n      return date.toISOString();\n    } catch (err) {\n      console.debug('Failed to parse date', value, err);\n    }\n  } else if (isPeriod(value)) {\n    // Can be a Period\n    if ('start' in value) {\n      return buildDateTimeColumn(value.start);\n    }\n    if ('end' in value) {\n      return buildDateTimeColumn(value.end);\n    }\n  }\n  return undefined;\n}\n\nfunction isNegated(operator: Operator): boolean {\n  return operator === Operator.NOT_EQUALS || operator === Operator.NOT;\n}\n", "import { AccessPolicy, AccessPolicyResource, Resource, ResourceType } from '@medplum/fhirtypes';\nimport { matchesSearchRequest } from './search/match';\nimport { parseSearchRequest } from './search/search';\n\nconst universalAccessPolicy: AccessPolicyResource = {\n  resourceType: '*',\n};\n\n/**\n * Protected resource types are in the \"medplum\" project.\n * Reading and writing is limited to the system account.\n */\nexport const protectedResourceTypes = ['DomainConfiguration', 'JsonWebKey', 'Login'];\n\n/**\n * Project admin resource types are special resources that are only\n * accessible to project administrators.\n */\nexport const projectAdminResourceTypes = [\n  'PasswordChangeRequest',\n  'UserSecurityRequest',\n  'Project',\n  'ProjectMembership',\n  'User',\n];\n\n/**\n * Interactions with a resource that can be controlled via an access policy.\n *\n * Codes taken from http://hl7.org/fhir/codesystem-restful-interaction.html\n */\nexport const AccessPolicyInteraction = {\n  READ: 'read',\n  VREAD: 'vread',\n  UPDATE: 'update',\n  DELETE: 'delete',\n  HISTORY: 'history',\n  CREATE: 'create',\n  SEARCH: 'search',\n} as const;\nexport type AccessPolicyInteraction = (typeof AccessPolicyInteraction)[keyof typeof AccessPolicyInteraction];\n\nexport const readInteractions: AccessPolicyInteraction[] = [\n  AccessPolicyInteraction.READ,\n  AccessPolicyInteraction.VREAD,\n  AccessPolicyInteraction.HISTORY,\n  AccessPolicyInteraction.SEARCH,\n];\n\n/**\n * Determines if the current user can read the specified resource type.\n * @param accessPolicy - The access policy.\n * @param resourceType - The resource type.\n * @returns True if the current user can read the specified resource type.\n * @deprecated Use accessPolicySupportsInteraction() instead.\n */\nexport function canReadResourceType(accessPolicy: AccessPolicy, resourceType: ResourceType): boolean {\n  return accessPolicySupportsInteraction(accessPolicy, AccessPolicyInteraction.SEARCH, resourceType);\n}\n\n/**\n * Determines if the current user can write the specified resource type.\n * This is a preliminary check before evaluating a write operation in depth.\n * If a user cannot write a resource type at all, then don't bother looking up previous versions.\n * @param accessPolicy - The access policy.\n * @param resourceType - The resource type.\n * @returns True if the current user can write the specified resource type.\n * @deprecated Use accessPolicySupportsInteraction() instead.\n */\nexport function canWriteResourceType(accessPolicy: AccessPolicy, resourceType: ResourceType): boolean {\n  if (protectedResourceTypes.includes(resourceType)) {\n    return false;\n  }\n  return accessPolicySupportsInteraction(accessPolicy, AccessPolicyInteraction.UPDATE, resourceType);\n}\n\n/**\n * Shallow check that an interaction is permitted by the AccessPolicy on a given resource type,\n * at least for some resources.  A more in-depth check for the specific resource(s) being accessed\n * is required in addition to this one.\n * @param accessPolicy - The AccessPolicy to check against.\n * @param interaction - The FHIR interaction being performed.\n * @param resourceType - The type of resource being interacted with.\n * @returns True when the interaction is provisionally permitted by the AccessPolicy.\n */\nexport function accessPolicySupportsInteraction(\n  accessPolicy: AccessPolicy,\n  interaction: AccessPolicyInteraction,\n  resourceType: ResourceType\n): boolean {\n  return Boolean(\n    accessPolicy.resource?.some((policy) => shallowMatchesResourcePolicy(policy, resourceType, interaction))\n  );\n}\n\n/**\n * Determines if the current user can write the specified resource.\n * This is a more in-depth check after building the candidate result of a write operation.\n * @param accessPolicy - The access policy.\n * @param resource - The resource.\n * @returns True if the current user can write the specified resource type.\n * @deprecated Use satisfiedAccessPolicy() instead.\n */\nexport function canWriteResource(accessPolicy: AccessPolicy, resource: Resource): boolean {\n  return Boolean(satisfiedAccessPolicy(resource, AccessPolicyInteraction.UPDATE, accessPolicy));\n}\n\n/**\n * Checks that there is an access policy permitting the given resource interaction, returning the matching policy object.\n * @param resource - The resource being acted upon.\n * @param interaction - The interaction being performed on the resource.\n * @param accessPolicy - The relevant access policy for the current user.\n * @returns The satisfied access policy, or undefined if the access policy does not permit the given interaction.\n */\nexport function satisfiedAccessPolicy(\n  resource: Resource,\n  interaction: AccessPolicyInteraction,\n  accessPolicy: AccessPolicy | undefined\n): AccessPolicyResource | undefined {\n  if (!accessPolicy) {\n    return universalAccessPolicy;\n  }\n  return accessPolicy.resource?.find((policy) => matchesAccessPolicyResourcePolicy(resource, interaction, policy));\n}\n\n/**\n * Returns true if the resource satisfies the specified access policy resource policy.\n * @param resource - The resource.\n * @param interaction - The interaction being performed on the resource.\n * @param resourcePolicy - One per-resource policy section from the access policy.\n * @returns True if the resource matches the access policy.\n */\nfunction matchesAccessPolicyResourcePolicy(\n  resource: Resource,\n  interaction: AccessPolicyInteraction,\n  resourcePolicy: AccessPolicyResource\n): boolean {\n  const resourceType = resource.resourceType;\n  if (!shallowMatchesResourcePolicy(resourcePolicy, resourceType, interaction)) {\n    return false;\n  }\n  if (\n    resourcePolicy.compartment &&\n    !resource.meta?.compartment?.some((c) => c.reference === resourcePolicy.compartment?.reference)\n  ) {\n    // Deprecated - to be removed in v5\n    return false;\n  }\n  if (resourcePolicy.criteria && !matchesSearchRequest(resource, parseSearchRequest(resourcePolicy.criteria))) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * Shallow check if the given interaction on a resource type matches the resource access policy.\n * @param policy - The AccessPolicy resource policy.\n * @param resourceType - The candidate resource type.\n * @param interaction - Interaction type to check against the policy.\n * @returns True when the resource type matches the resource policy.\n */\nfunction shallowMatchesResourcePolicy(\n  policy: AccessPolicyResource,\n  resourceType: ResourceType,\n  interaction: AccessPolicyInteraction\n): boolean {\n  if (\n    policy.resourceType !== resourceType &&\n    // Project admin resource types are not allowed to be wildcarded; they must be explicitly included\n    (policy.resourceType !== '*' || projectAdminResourceTypes.includes(resourceType))\n  ) {\n    return false;\n  }\n\n  // Only use `readonly` if `interaction` is not specified\n  if (!policy.interaction) {\n    return !policy.readonly || readInteractions.includes(interaction);\n  }\n  return policy.interaction.includes(interaction);\n}\n", "/**\n * Decodes a base64 string.\n * Handles both browser and Node environments.\n * Supports Unicode characters.\n * @param data - The base-64 encoded input string.\n * @returns The decoded string.\n */\nexport function decodeBase64(data: string): string {\n  if (typeof window !== 'undefined') {\n    const binaryString = window.atob(data);\n    const bytes = Uint8Array.from(binaryString, (c) => c.charCodeAt(0));\n    return new window.TextDecoder().decode(bytes);\n  }\n  if (typeof Buffer !== 'undefined') {\n    return Buffer.from(data, 'base64').toString('utf-8');\n  }\n  throw new Error('Unable to decode base64');\n}\n\n/**\n * Encodes a base64 string.\n * Handles both browser and Node environments.\n * Supports Unicode characters.\n * @param data - The unencoded input string.\n * @returns The base-64 encoded string.\n */\nexport function encodeBase64(data: string): string {\n  if (typeof window !== 'undefined') {\n    const utf8Bytes = new window.TextEncoder().encode(data);\n    // utf8Bytes is a Uint8Array, but String.fromCharCode expects a sequence of numbers.\n    const binaryString = String.fromCharCode.apply(null, utf8Bytes as unknown as number[]);\n    return window.btoa(binaryString);\n  }\n  if (typeof Buffer !== 'undefined') {\n    return Buffer.from(data, 'utf8').toString('base64');\n  }\n  throw new Error('Unable to encode base64');\n}\n\n/**\n * Encodes a string into Base64URL format.\n * This is the encoding required for JWT parts.\n * @param data - The unencoded input string.\n * @returns The Base64URL encoded string.\n */\nexport function encodeBase64Url(data: string): string {\n  return encodeBase64(data)\n    .replace(/\\+/g, '-') // Replace + with -\n    .replace(/\\//g, '_') // Replace / with _\n    .replace(/[=]{1,2}$/, ''); // Remove trailing =\n}\n\n/**\n * Decodes a string from Base64URL format.\n * @param data - The Base64URL encoded input string.\n * @returns The decoded string.\n */\nexport function decodeBase64Url(data: string): string {\n  data = data.padEnd(data.length + ((4 - (data.length % 4)) % 4), '=');\n  const base64 = data.replace(/-/g, '+').replace(/_/g, '/');\n  return decodeBase64(base64);\n}\n", "import { arrayBufferToHex } from './utils';\n\n/**\n * Returns a cryptographically secure random string.\n * @returns A cryptographically secure random string.\n */\nexport function getRandomString(): string {\n  const randomItems = new Uint32Array(28);\n  crypto.getRandomValues(randomItems);\n  return arrayBufferToHex(randomItems.buffer);\n}\n\n/**\n * Encrypts a string with SHA256 encryption.\n * @param str - The unencrypted input string.\n * @returns The encrypted value in an ArrayBuffer.\n */\nexport async function encryptSHA256(str: string): Promise<ArrayBuffer> {\n  return crypto.subtle.digest('SHA-256', new TextEncoder().encode(str));\n}\n\n/**\n * Cross platform random UUID generator\n * Note that this is not intended for production use, but rather for testing\n * This should be replaced when crypto.randomUUID is fully supported\n * See: https://stackoverflow.com/revisions/2117523/28\n * @returns A random UUID.\n */\nexport function generateId(): string {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n    const r = (Math.random() * 16) | 0;\n    const v = c === 'x' ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n", "import { Bundle, BundleEntry, BundleEntryRequest, Resource } from '@medplum/fhirtypes';\nimport { generateId } from './crypto';\nimport { isReference } from './types';\nimport { deepClone } from './utils';\n\n/**\n * More on Bundles can be found here\n * http://hl7.org/fhir/R4/bundle.html\n */\n\n/**\n * Takes a bundle and creates a Transaction Type bundle\n * @param bundle - The Bundle object that we'll receive from the search query\n * @returns transaction type bundle\n */\nexport function convertToTransactionBundle(bundle: Bundle): Bundle {\n  const idToUuid: Record<string, string> = {};\n  bundle = deepClone(bundle);\n  for (const entry of bundle.entry || []) {\n    const resource = entry.resource;\n    if (!resource) {\n      continue;\n    }\n    if (resource.meta !== undefined) {\n      delete resource.meta.author;\n      delete resource.meta.compartment;\n      delete resource.meta.lastUpdated;\n      delete resource.meta.project;\n      delete resource.meta.versionId;\n      if (Object.keys(resource.meta).length === 0) {\n        delete resource.meta;\n      }\n    }\n    const id = resource?.id;\n    if (id) {\n      idToUuid[id] = generateId();\n\n      entry.fullUrl = 'urn:uuid:' + idToUuid[id];\n      delete entry.resource?.id;\n    }\n  }\n  const input = bundle.entry;\n  const jsonString = JSON.stringify(\n    {\n      resourceType: 'Bundle',\n      type: 'transaction',\n      entry: input?.map((entry: BundleEntry) => ({\n        fullUrl: entry.fullUrl,\n        request: { method: 'POST', url: entry.resource?.resourceType },\n        resource: entry.resource,\n      })),\n    },\n    (key, value) => referenceReplacer(key, value, idToUuid),\n    2\n  );\n  return reorderBundle(JSON.parse(jsonString) as Bundle);\n}\n\nfunction referenceReplacer(key: string, value: string, idToUuid: Record<string, string>): string {\n  if (key === 'reference' && typeof value === 'string') {\n    let id;\n    if (value.includes('/')) {\n      id = value.split('/')[1];\n    } else if (value.startsWith('urn:uuid:')) {\n      id = value.slice(9);\n    } else if (value.startsWith('#')) {\n      id = value.slice(1);\n    }\n    if (id) {\n      const replacement = idToUuid[id];\n      if (replacement) {\n        return 'urn:uuid:' + replacement;\n      }\n    }\n  }\n  return value;\n}\n\n/**\n * Topologically sorts a `batch` or `transaction` bundle to improve reference resolution.\n * The bundle is sorted such that a resource is created _before_ references to that resource appear in the bundle.\n *\n * In the event of cycles, this function will first create a POST request for each resource in the cycle, and then will\n * append a PUT request to the bundle. This ensures that each resources in the cycle is visited twice, and all\n * references can be resolved\n * @param bundle - Input bundle with type `batch` or `transaction`\n * @returns Bundle of the same type, with Bundle.entry reordered\n */\nexport function reorderBundle(bundle: Bundle): Bundle {\n  const adjacencyList = buildAdjacencyList(bundle);\n  const { sorted: sortedFullUrls, cycles } = topologicalSortWithCycles(adjacencyList);\n\n  const entryMap: Record<string, BundleEntry> = {};\n\n  for (const entry of bundle.entry ?? []) {\n    if (entry.fullUrl) {\n      entryMap[entry.fullUrl] = entry;\n    }\n  }\n\n  const reorderedEntries = sortedFullUrls.map((fullUrl) => entryMap[fullUrl]);\n\n  // Handle cycles by appending additional entries with a method of 'PUT'\n  for (const cycle of cycles) {\n    for (const fullUrl of cycle) {\n      const originalEntry = entryMap[fullUrl];\n      const putEntry: BundleEntry = {\n        ...originalEntry,\n        request: {\n          ...(originalEntry.request as BundleEntryRequest),\n          method: 'PUT',\n        },\n      };\n      reorderedEntries.push(putEntry);\n    }\n  }\n\n  return { ...bundle, entry: reorderedEntries };\n}\n\ntype AdjacencyList = Record<string, string[]>;\n\nconst VertexState = {\n  NotVisited: 'NotVisited',\n  Visiting: 'Visiting',\n  Visited: 'Visited',\n} as const;\ntype VertexState = (typeof VertexState)[keyof typeof VertexState];\n\nfunction topologicalSortWithCycles(graph: AdjacencyList): { sorted: string[]; cycles: string[][] } {\n  const sorted: string[] = [];\n  const state: Record<string, VertexState> = {};\n  const cycles: string[][] = [];\n\n  // Initialize all vertices to NotVisited state\n  for (const vertex of Object.keys(graph)) {\n    state[vertex] = VertexState.NotVisited;\n  }\n\n  function visit(vertex: string, path: string[]): boolean {\n    // If this vertex is already visited, return true\n    if (state[vertex] === VertexState.Visited) {\n      return true;\n    }\n\n    // If this vertex is currently being visited, we have a cycle\n    if (state[vertex] === VertexState.Visiting) {\n      const cycleStartIndex = path.lastIndexOf(vertex);\n      if (cycleStartIndex !== -1) {\n        cycles.push(path.slice(cycleStartIndex));\n      }\n      return true; // return true for vertices that are part of cycles\n    }\n\n    // Mark the vertex as visiting and add it to the path\n    state[vertex] = VertexState.Visiting;\n    path.push(vertex);\n\n    // Visit all neighbors\n    let hasCycle = false;\n    for (const neighbor of graph[vertex]) {\n      if (!visit(neighbor, path)) {\n        hasCycle = true;\n      }\n    }\n\n    // Mark the vertex as visited, remove it from the path, and add it to the sorted list\n    state[vertex] = VertexState.Visited;\n    path.pop();\n    sorted.unshift(vertex);\n\n    return !hasCycle;\n  }\n\n  for (const vertex in graph) {\n    if (state[vertex] === VertexState.NotVisited) {\n      const path: string[] = [];\n      visit(vertex, path);\n    }\n  }\n\n  return { sorted, cycles };\n}\n\nfunction findReferences(resource: any, callback: (reference: string) => void): void {\n  for (const key in resource) {\n    if (resource[key] && typeof resource[key] === 'object') {\n      const value = resource[key];\n\n      if (isReference(value)) {\n        const reference = value.reference;\n        if (reference.startsWith('urn:uuid:')) {\n          callback(reference);\n        }\n      } else {\n        findReferences(value, callback);\n      }\n    }\n  }\n}\n\nfunction buildAdjacencyList(bundle: Bundle): AdjacencyList {\n  const adjacencyList: AdjacencyList = {};\n\n  // Initialize adjacency list with empty arrays for each entry's fullUrl\n  for (const entry of bundle.entry || []) {\n    if (entry.fullUrl) {\n      adjacencyList[entry.fullUrl] = [];\n    }\n  }\n\n  for (const entry of bundle.entry || []) {\n    const fullUrl = entry.fullUrl;\n\n    if (entry.resource) {\n      findReferences(entry.resource, (reference: string) => {\n        // Add an incoming reference to the adjacency list\n        if (adjacencyList[reference]) {\n          adjacencyList[reference].push(fullUrl as string);\n        }\n      });\n    }\n  }\n\n  return adjacencyList;\n}\n\n/**\n * Converts a resource with contained resources to a transaction bundle.\n * This function is useful when creating a resource that contains other resources.\n * Handles local references and topological sorting.\n * @param resource - The input resource which may or may not include contained resources.\n * @returns A bundle with the input resource and all contained resources.\n */\nexport function convertContainedResourcesToBundle(resource: Resource & { contained?: Resource[] }): Bundle {\n  // Create a clone so we don't modify the original resource\n  resource = deepClone(resource);\n\n  // Create the simple naive bundle\n  const simpleBundle = {\n    resourceType: 'Bundle',\n    type: 'transaction',\n    entry: [{ resource }],\n  } satisfies Bundle;\n\n  // Move all contained resources to the bundle\n  if (resource.contained) {\n    for (const contained of resource.contained) {\n      simpleBundle.entry.push({ resource: contained });\n    }\n    resource.contained = undefined;\n  }\n\n  // Make sure that all resources have an ID\n  // This is required for convertToTransactionBundle\n  for (const entry of simpleBundle.entry) {\n    if (entry.resource && !entry.resource.id) {\n      entry.resource.id = generateId();\n    }\n  }\n\n  // Convert to a transaction bundle\n  // This adds fullUrl and request properties to each entry\n  // and reorders the bundle to ensure that contained resources are created before they are referenced.\n  return convertToTransactionBundle(simpleBundle);\n}\n", "/**\n * Content type constants.\n */\nexport const ContentType = {\n  CSS: 'text/css',\n  DICOM: 'application/dicom',\n  FAVICON: 'image/vnd.microsoft.icon',\n  FHIR_JSON: 'application/fhir+json',\n  FORM_URL_ENCODED: 'application/x-www-form-urlencoded',\n  HL7_V2: 'x-application/hl7-v2+er7',\n  HTML: 'text/html',\n  JAVASCRIPT: 'text/javascript',\n  JSON: 'application/json',\n  JSON_PATCH: 'application/json-patch+json',\n  MULTIPART_FORM_DATA: 'multipart/form-data',\n  PNG: 'image/png',\n  SCIM_JSON: 'application/scim+json',\n  SVG: 'image/svg+xml',\n  TEXT: 'text/plain',\n  TYPESCRIPT: 'text/typescript',\n  PING: 'x-application/ping',\n  XML: 'text/xml',\n  // See: https://www.iana.org/assignments/media-types/application/cda+xml\n  CDA_XML: 'application/cda+xml',\n} as const;\n", "/*\n * Based on: https://developer.mozilla.org/en-US/docs/Web/API/EventTarget\n */\n\nexport interface Event {\n  readonly type: string;\n  readonly defaultPrevented?: boolean;\n}\n\nexport type EventListener = (e: Event) => void;\n\nexport class EventTarget {\n  private readonly listeners: Record<string, EventListener[]>;\n\n  constructor() {\n    this.listeners = {};\n  }\n\n  addEventListener(type: string, callback: EventListener): void {\n    if (!this.listeners[type]) {\n      this.listeners[type] = [];\n    }\n    this.listeners[type].push(callback);\n  }\n\n  removeEventListener(type: string, callback: EventListener): void {\n    const array = this.listeners[type];\n    if (!array) {\n      return;\n    }\n    for (let i = 0; i < array.length; i++) {\n      if (array[i] === callback) {\n        array.splice(i, 1);\n        return;\n      }\n    }\n  }\n\n  dispatchEvent(event: Event): boolean {\n    const array = this.listeners[event.type];\n    if (array) {\n      for (const listener of array) {\n        listener.call(this, event);\n      }\n    }\n    return !event.defaultPrevented;\n  }\n\n  removeAllListeners(): void {\n    // @ts-expect-error Normally listeners is read-only. In this case we are dumping all listeners\n    this.listeners = {};\n  }\n}\n\nexport class TypedEventTarget<TEvents extends Record<string, Event>> {\n  private readonly emitter = new EventTarget();\n\n  dispatchEvent<TEventType extends keyof TEvents & string>(event: TEvents[TEventType]): void {\n    this.emitter.dispatchEvent(event);\n  }\n\n  addEventListener<TEventType extends keyof TEvents & string>(\n    type: TEventType,\n    handler: (event: TEvents[TEventType]) => void\n  ): void {\n    this.emitter.addEventListener(type, handler as any);\n  }\n\n  removeEventListener<TEventType extends keyof TEvents & string>(\n    type: TEventType,\n    handler: (event: TEvents[TEventType]) => void\n  ): void {\n    this.emitter.removeEventListener(type, handler as any);\n  }\n\n  removeAllListeners(): void {\n    this.emitter.removeAllListeners();\n  }\n}\n", "import {\n  Bundle,\n  DiagnosticReport,\n  Encounter,\n  ImagingStudy,\n  OperationOutcome,\n  Patient,\n  Reference,\n  Resource,\n} from '@medplum/fhirtypes';\nimport { generateId } from '../crypto';\nimport { TypedEventTarget } from '../eventtarget';\nimport { OperationOutcomeError, validationError } from '../outcomes';\nimport { isReference } from '../types';\n\n// We currently try to satisfy both STU2 and STU3. Where STU3 removes a resource / key from STU2, we leave it in as a valid key but don't require it.\n\nexport const FHIRCAST_EVENT_NAMES = {\n  'Patient-open': 'Patient-open',\n  'Patient-close': 'Patient-close',\n  'ImagingStudy-open': 'ImagingStudy-open',\n  'ImagingStudy-close': 'ImagingStudy-close',\n  'Encounter-open': 'Encounter-open',\n  'Encounter-close': 'Encounter-close',\n  'DiagnosticReport-open': 'DiagnosticReport-open',\n  'DiagnosticReport-close': 'DiagnosticReport-close',\n  'DiagnosticReport-select': 'DiagnosticReport-select',\n  'DiagnosticReport-update': 'DiagnosticReport-update',\n  syncerror: 'syncerror',\n} as const;\n\nexport const FHIRCAST_RESOURCE_TYPES = [\n  'Patient',\n  'Encounter',\n  'ImagingStudy',\n  'DiagnosticReport',\n  'OperationOutcome',\n  'Bundle',\n] as const;\n\nexport const FHIRCAST_EVENT_VERSION_REQUIRED = ['DiagnosticReport-update'] as const;\nexport type FhircastEventVersionRequired = (typeof FHIRCAST_EVENT_VERSION_REQUIRED)[number];\nexport type FhircastEventVersionOptional = Exclude<FhircastEventName, FhircastEventVersionRequired>;\nexport function isContextVersionRequired(event: string): event is FhircastEventVersionRequired {\n  return (FHIRCAST_EVENT_VERSION_REQUIRED as readonly string[]).includes(event);\n}\nexport function assertContextVersionOptional(event: string): asserts event is FhircastEventVersionOptional {\n  if ((FHIRCAST_EVENT_VERSION_REQUIRED as readonly string[]).includes(event)) {\n    throw new OperationOutcomeError(validationError(`'context.version' is required for '${event}'.`));\n  }\n}\n\nexport type FhircastEventName = keyof typeof FHIRCAST_EVENT_NAMES;\nexport type FhircastResourceEventName = Exclude<FhircastEventName, 'syncerror'>;\nexport type FhircastResourceType = (typeof FHIRCAST_RESOURCE_TYPES)[number];\nexport type FhircastAnchorResourceType = 'Patient' | 'ImagingStudy' | 'Encounter' | 'DiagnosticReport';\n\nexport type FhircastEventContextDetails = {\n  resourceType: FhircastResourceType | '*';\n  optional?: boolean; // NOTE: optional here is only referring to the schema, the spec often mentions that these are required if available as references for a given anchor resource\n  manyAllowed?: boolean;\n  array?: boolean;\n  reference?: boolean;\n};\n\n// Key value pairs of { [FhircastEventName]: [required_resource1, required_resource2] }\nexport const FHIRCAST_EVENT_RESOURCES = {\n  'Patient-open': {\n    patient: { resourceType: 'Patient' },\n    /* STU2 only! `encounter` key removed in STU3 */\n    encounter: { resourceType: 'Encounter', optional: true },\n  },\n  'Patient-close': {\n    patient: { resourceType: 'Patient' },\n    /* STU2 only! `encounter` key removed in STU3 */\n    encounter: { resourceType: 'Encounter', optional: true },\n  },\n  'ImagingStudy-open': {\n    study: { resourceType: 'ImagingStudy' },\n    encounter: { resourceType: 'Encounter', optional: true },\n    patient: { resourceType: 'Patient', optional: true },\n  },\n  'ImagingStudy-close': {\n    study: { resourceType: 'ImagingStudy' },\n    encounter: { resourceType: 'Encounter', optional: true },\n    patient: { resourceType: 'Patient', optional: true },\n  },\n  'Encounter-open': {\n    encounter: { resourceType: 'Encounter' },\n    patient: { resourceType: 'Patient' },\n  },\n  'Encounter-close': {\n    encounter: { resourceType: 'Encounter' },\n    patient: { resourceType: 'Patient' },\n  },\n  'DiagnosticReport-open': {\n    report: { resourceType: 'DiagnosticReport' },\n    encounter: { resourceType: 'Encounter', optional: true },\n    study: { resourceType: 'ImagingStudy', optional: true, manyAllowed: true },\n    patient: { resourceType: 'Patient' },\n  },\n  'DiagnosticReport-close': {\n    report: { resourceType: 'DiagnosticReport' },\n    encounter: { resourceType: 'Encounter', optional: true },\n    study: { resourceType: 'ImagingStudy', optional: true, manyAllowed: true },\n    patient: { resourceType: 'Patient' },\n  },\n  'DiagnosticReport-select': {\n    // Most event contexts contain a full resource, but `DiagnosticReport-select` context elements are actually references\n    // See: https://build.fhir.org/ig/HL7/fhircast-docs/3-6-4-DiagnosticReport-select.html\n    report: { resourceType: 'DiagnosticReport', reference: true },\n    patient: { resourceType: 'Patient', optional: true, reference: true },\n    select: { resourceType: '*', reference: true, manyAllowed: true },\n  },\n  'DiagnosticReport-update': {\n    // `report` and `patient` are also references for `DiagnosticReport-update`:\n    // See: https://build.fhir.org/ig/HL7/fhircast-docs/3-6-3-DiagnosticReport-update.html\n    report: { resourceType: 'DiagnosticReport', reference: true },\n    patient: { resourceType: 'Patient', optional: true, reference: true },\n    updates: { resourceType: 'Bundle' },\n  },\n  syncerror: {\n    operationoutcome: { resourceType: 'OperationOutcome' },\n  },\n} as const satisfies Record<FhircastEventName, Record<string, FhircastEventContextDetails>>;\n\n/**\n * Checks if a `ResourceType` can be used in a `FHIRcast` context.\n *\n * @param resourceType - A `ResourceType` to test.\n * @returns `true` if this is a resource type associated with `FHIRcast` contexts, otherwise returns `false`.\n */\nexport function isFhircastResourceType(resourceType: FhircastResourceType): boolean {\n  return FHIRCAST_RESOURCE_TYPES.includes(resourceType);\n}\n\n/**\n * A `FHIRcast` subscription request.\n *\n * Can be passed to `MedplumClient.fhircastConnect` or `MedplumClient.fhircastUnsubscribe` to either open a `FHIRcast` connection, or unsubscribe from the subscription.\n */\nexport type SubscriptionRequest = {\n  channelType: 'websocket';\n  mode: 'subscribe' | 'unsubscribe';\n  events: FhircastEventName[];\n  topic: string;\n  endpoint: string;\n};\n\nexport type FhircastPatientContext = { key: 'patient'; resource: Patient };\nexport type FhircastEncounterContext = { key: 'encounter'; resource: Encounter };\nexport type FhircastStudyContext = { key: 'study'; resource: ImagingStudy };\nexport type FhircastReportContext = { key: 'report'; resource: DiagnosticReport };\nexport type FhircastReportReferenceContext = { key: 'report'; reference: Reference<DiagnosticReport> };\nexport type FhircastPatientReferenceContext = { key: 'patient'; reference: Reference<Patient> };\nexport type FhircastUpdatesContext = { key: 'updates'; resource: Bundle };\nexport type FhircastSelectContext = { key: 'select'; reference: Reference };\nexport type FhircastOperationOutcomeContext = { key: 'operationoutcome'; resource: OperationOutcome };\n\n// These are all the contexts that contain a `resource` key\nexport type FhircastResourceContext =\n  | FhircastPatientContext\n  | FhircastEncounterContext\n  | FhircastStudyContext\n  | FhircastReportContext\n  | FhircastUpdatesContext\n  | FhircastOperationOutcomeContext;\n\n// The reference contexts related to `*-select` and `*-update` events, which contain a `reference` key\nexport type FhircastReferenceContext =\n  | FhircastReportReferenceContext\n  | FhircastPatientReferenceContext\n  | FhircastSelectContext;\n\nexport type FhircastPatientOpenContext = FhircastPatientContext | FhircastEncounterContext;\nexport type FhircastPatientCloseContext = FhircastPatientOpenContext;\nexport type FhircastImagingStudyOpenContext = FhircastStudyContext | FhircastEncounterContext | FhircastPatientContext;\nexport type FhircastImagingStudyCloseContext = FhircastImagingStudyOpenContext;\nexport type FhircastEncounterOpenContext = FhircastEncounterContext | FhircastPatientContext;\nexport type FhircastEncounterCloseContext = FhircastEncounterOpenContext;\nexport type FhircastDiagnosticReportOpenContext =\n  | FhircastReportContext\n  | FhircastEncounterContext\n  | FhircastStudyContext\n  | FhircastPatientContext;\nexport type FhircastDiagnosticReportCloseContext = FhircastDiagnosticReportOpenContext;\nexport type FhircastDiagnosticReportUpdateContext =\n  | FhircastReportReferenceContext\n  | FhircastPatientReferenceContext\n  | FhircastUpdatesContext;\nexport type FhircastDiagnosticReportSelectContext =\n  | FhircastReportReferenceContext\n  | FhircastPatientReferenceContext\n  | FhircastSelectContext;\nexport type FhircastSyncErrorContext = FhircastOperationOutcomeContext;\n\n// This is the one key that only exists within a GetCurrentContext\n// Specifically related to the `DiagnosticReport-update` event in a `DiagnosticReport` context\n// See the FHIRcast docs regarding content sharing: https://build.fhir.org/ig/HL7/fhircast-docs/2-10-ContentSharing.html#updating-attributes-of-context-resources-and-addingremoving-context-resources\n// And the GetCurrentContext page that mentions the specifications of this key: https://build.fhir.org/ig/HL7/fhircast-docs/2-9-GetCurrentContext.html#context\nexport type FhircastHubContentContext = {\n  key: 'content';\n  resource: Bundle;\n};\n\n// Type utility to get keys for a specific event\nexport type FhircastEventKeys<EventName extends FhircastEventName> = keyof (typeof FHIRCAST_EVENT_RESOURCES)[EventName];\n\n// Type utility to extract the resource type from an event and key\nexport type FhircastContextResourceType<\n  EventName extends FhircastEventName,\n  K extends FhircastEventKeys<EventName>,\n> = (typeof FHIRCAST_EVENT_RESOURCES)[EventName][K] extends { resourceType: infer R } ? R : never;\n\nexport type FhircastEventContext<EventName extends FhircastEventName = FhircastResourceEventName> =\n  EventName extends 'Patient-open'\n    ? FhircastPatientOpenContext\n    : EventName extends 'Patient-close'\n      ? FhircastPatientCloseContext\n      : EventName extends 'ImagingStudy-open'\n        ? FhircastImagingStudyOpenContext\n        : EventName extends 'ImagingStudy-close'\n          ? FhircastImagingStudyCloseContext\n          : EventName extends 'Encounter-open'\n            ? FhircastEncounterOpenContext\n            : EventName extends 'Encounter-close'\n              ? FhircastEncounterCloseContext\n              : EventName extends 'DiagnosticReport-open'\n                ? FhircastDiagnosticReportOpenContext\n                : EventName extends 'DiagnosticReport-close'\n                  ? FhircastDiagnosticReportCloseContext\n                  : EventName extends 'DiagnosticReport-update'\n                    ? FhircastDiagnosticReportUpdateContext\n                    : EventName extends 'DiagnosticReport-select'\n                      ? FhircastDiagnosticReportSelectContext\n                      : EventName extends 'syncerror'\n                        ? FhircastSyncErrorContext\n                        : never;\n\nexport type AnchorResourceOpenEvent<T extends FhircastAnchorResourceType> = T extends FhircastAnchorResourceType\n  ? `${T}-open`\n  : never;\n\nexport type CurrentContext<T extends FhircastAnchorResourceType | '' = FhircastAnchorResourceType | ''> = T extends ''\n  ? { 'context.type': ''; context: never[] }\n  : T extends 'DiagnosticReport'\n    ? {\n        'context.type': 'DiagnosticReport';\n        'context.versionId': string;\n        context: (FhircastEventContext<'DiagnosticReport-open'> | FhircastHubContentContext)[];\n      }\n    : T extends 'Patient' | 'Encounter' | 'ImagingStudy'\n      ? {\n          'context.type': T;\n          'context.versionId': string;\n          context: FhircastEventContext<AnchorResourceOpenEvent<T>>[];\n        }\n      : never;\n\nexport type PendingSubscriptionRequest = Omit<SubscriptionRequest, 'endpoint'>;\n\nexport type FhircastEventPayload<EventName extends FhircastEventName = FhircastEventName> = {\n  'hub.topic': string;\n  'hub.event': EventName;\n  context: FhircastEventContext<EventName>[];\n  'context.versionId'?: string;\n  'context.priorVersionId'?: string;\n};\n\nexport type FhircastMessagePayload<EventName extends FhircastEventName = FhircastEventName> = {\n  timestamp: string;\n  id: string;\n  event: FhircastEventPayload<EventName>;\n};\n\nexport function isCompletedSubscriptionRequest(\n  subscriptionRequest: SubscriptionRequest | PendingSubscriptionRequest\n): subscriptionRequest is SubscriptionRequest {\n  return !!(subscriptionRequest as SubscriptionRequest).endpoint;\n}\n\n/**\n * Creates a serialized url-encoded payload for a `FHIRcast` subscription from a `SubscriptionRequest` object that can be directly used in an HTTP request to the Hub.\n *\n * @param subscriptionRequest - An object representing a subscription request.\n * @returns A serialized subscription in url-encoded form.\n */\nexport function serializeFhircastSubscriptionRequest(\n  subscriptionRequest: SubscriptionRequest | PendingSubscriptionRequest\n): string {\n  if (!validateFhircastSubscriptionRequest(subscriptionRequest)) {\n    throw new OperationOutcomeError(\n      validationError('subscriptionRequest must be an object conforming to SubscriptionRequest type.')\n    );\n  }\n\n  const { channelType, mode, topic, events } = subscriptionRequest;\n\n  const formattedSubRequest = {\n    'hub.channel.type': channelType,\n    'hub.mode': mode,\n    'hub.topic': topic,\n    'hub.events': events.join(','),\n  } as Record<string, string>;\n\n  if (isCompletedSubscriptionRequest(subscriptionRequest)) {\n    formattedSubRequest.endpoint = subscriptionRequest.endpoint;\n  }\n  return new URLSearchParams(formattedSubRequest).toString();\n}\n\n/**\n * Validates that a `SubscriptionRequest`.\n *\n * @param subscriptionRequest - The `SubscriptionRequest` to validate.\n * @returns A `boolean` indicating whether or not the `SubscriptionRequest` is valid.\n */\nexport function validateFhircastSubscriptionRequest(\n  subscriptionRequest: SubscriptionRequest | PendingSubscriptionRequest\n): boolean {\n  if (typeof subscriptionRequest !== 'object') {\n    return false;\n  }\n  const { channelType, mode, topic, events } = subscriptionRequest;\n  if (!(channelType && mode && topic && events)) {\n    return false;\n  }\n  if (typeof topic !== 'string') {\n    return false;\n  }\n  if (typeof events !== 'object' || !Array.isArray(events) || events.length < 1) {\n    return false;\n  }\n  if (channelType !== 'websocket') {\n    return false;\n  }\n  if (mode !== 'subscribe' && mode !== 'unsubscribe') {\n    return false;\n  }\n  for (const event of events) {\n    if (!FHIRCAST_EVENT_NAMES[event]) {\n      return false;\n    }\n  }\n  if (\n    isCompletedSubscriptionRequest(subscriptionRequest) &&\n    !(typeof subscriptionRequest.endpoint === 'string' && subscriptionRequest.endpoint.startsWith('ws'))\n  ) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * Throws if the context resource type is invalid. Intended as a helper for `validateFhircastContexts` only.\n *\n * @param event - The `FHIRcast` event name associated with the provided contexts.\n * @param resource - The `FHIRcast` event context resource to validate for given key.\n * @param i - The index of the current context in the context list.\n * @param keySchema - Schema for given key for FHIRcast event.\n */\nfunction validateSingleResourceContext(\n  event: FhircastEventName,\n  resource: Resource,\n  i: number,\n  keySchema: FhircastEventContextDetails\n): void {\n  if (typeof resource !== 'object') {\n    throw new OperationOutcomeError(\n      validationError(\n        `context[${i}] is invalid. Context must contain a single valid FHIR resource! Resource is not an object.`\n      )\n    );\n  }\n  if (!(resource.id && typeof resource.id === 'string')) {\n    throw new OperationOutcomeError(\n      validationError(`context[${i}] is invalid. Resource must contain a valid string ID.`)\n    );\n  }\n  if (!resource.resourceType) {\n    throw new OperationOutcomeError(\n      validationError(`context[${i}] is invalid. Resource must contain a resource type. No resource type found.`)\n    );\n  }\n  const expectedResourceType = keySchema.resourceType;\n  // Make sure that resource is a valid type for this event if expected is not wildcard\n  if (expectedResourceType !== '*') {\n    if (!isFhircastResourceType(resource.resourceType as FhircastResourceType)) {\n      throw new OperationOutcomeError(\n        validationError(\n          `context[${i}] is invalid. Resource must contain a valid FHIRcast resource type. Resource type is not a known resource type.`\n        )\n      );\n    }\n    if (expectedResourceType && resource.resourceType !== expectedResourceType) {\n      throw new OperationOutcomeError(\n        validationError(\n          `context[${i}] is invalid. context[${i}] for the '${event}' event should contain resource of type ${expectedResourceType}.`\n        )\n      );\n    }\n  }\n}\n\n/**\n * Throws if the context is invalid. Intended as a helper for `validateFhircastContexts` only.\n *\n * @param event - The `FHIRcast` event name associated with the provided contexts.\n * @param context - The `FHIRcast` event contexts to validate.\n * @param i - The index of the current context in the context list.\n * @param keySchema - Schema for given key for FHIRcast event.\n * @param keysSeen - Set of keys seen so far. Used to prevent duplicate keys.\n */\nfunction validateFhircastContext<EventName extends FhircastEventName = FhircastEventName>(\n  event: EventName,\n  context: FhircastEventContext<EventName>,\n  i: number,\n  keySchema: FhircastEventContextDetails,\n  keysSeen: Map<FhircastEventContext<EventName>['key'], number>\n): void {\n  keysSeen.set(context.key, (keysSeen.get(context.key) ?? 0) + 1);\n\n  if (keySchema.reference) {\n    if (!isReference((context as FhircastReferenceContext).reference)) {\n      // Validate single reference\n      throw new OperationOutcomeError(\n        validationError(`context[${i}] is invalid. Expected key '${context.key}' to be a reference.`)\n      );\n    }\n  } else {\n    validateSingleResourceContext(event, (context as FhircastResourceContext).resource, i, keySchema);\n  }\n}\n\n/**\n * Throws if any context in the given array of contexts is invalid.\n *\n * @param event - The `FHIRcast` event name associated with the provided contexts.\n * @param contexts - The `FHIRcast` event contexts to validate.\n */\nfunction validateFhircastContexts<EventName extends FhircastEventName>(\n  event: EventName,\n  contexts: FhircastEventContext<EventName>[]\n): void {\n  const keysSeen = new Map<FhircastEventContext['key'], number>();\n  const eventSchema = FHIRCAST_EVENT_RESOURCES[event] as Record<\n    FhircastEventContext['key'],\n    FhircastEventContextDetails\n  >;\n  for (let i = 0; i < contexts.length; i++) {\n    const key = contexts[i].key as FhircastEventContext['key'];\n    if (!eventSchema[key]) {\n      throw new OperationOutcomeError(\n        validationError(`Key '${key}' not found for event '${event}'. Make sure to add only valid keys.`)\n      );\n    }\n    validateFhircastContext(event, contexts[i], i, eventSchema[key], keysSeen);\n  }\n  // Iterate each key, if conditions for keys are not met as confirmed by `keysSeen` map, throw an error\n  for (const [key, details] of Object.entries(eventSchema) as [\n    FhircastEventContext['key'],\n    FhircastEventContextDetails,\n  ][]) {\n    // If not optional and not keysSeen.has(key), throw\n    if (!(details.optional || keysSeen.has(key))) {\n      throw new OperationOutcomeError(\n        validationError(`Missing required key '${key}' on context for '${event}' event.`)\n      );\n    }\n    // If not multiple allowed and keySeen.get(key) > 1, throw\n    if (!details.manyAllowed && (keysSeen.get(key) ?? 0) > 1) {\n      throw new OperationOutcomeError(\n        validationError(\n          `${keysSeen.get(\n            key\n          )} context entries with key '${key}' found for the '${event}' event when schema only allows for 1.`\n        )\n      );\n    }\n  }\n}\n\n/**\n * Creates a serializable JSON payload for the `FHIRcast` protocol\n *\n * @param topic - The topic that this message will be published on. Usually a UUID.\n * @param event - The event name, ie. \"Patient-open\" or \"Patient-close\".\n * @param context - The updated context, containing new versions of resources related to this event.\n * @param versionId - The current `versionId` of the anchor context. For example, in `DiagnosticReport-update`, it's the `versionId` of the `DiagnosticReport`.\n * @returns A serializable `FhircastMessagePayload`.\n */\nexport function createFhircastMessagePayload<EventName extends FhircastEventVersionOptional>(\n  topic: string,\n  event: EventName,\n  context: FhircastEventContext<EventName> | FhircastEventContext<EventName>[],\n  versionId?: never\n): FhircastMessagePayload<EventName>;\n\nexport function createFhircastMessagePayload<EventName extends FhircastEventVersionRequired>(\n  topic: string,\n  event: EventName,\n  context: FhircastEventContext<EventName> | FhircastEventContext<EventName>[],\n  versionId: string\n): FhircastMessagePayload<EventName>;\n\nexport function createFhircastMessagePayload<\n  EventName extends FhircastEventVersionOptional | FhircastEventVersionRequired,\n>(\n  topic: string,\n  event: EventName,\n  context: FhircastEventContext<EventName> | FhircastEventContext<EventName>[],\n  versionId?: string\n): FhircastMessagePayload<EventName> {\n  if (!(topic && typeof topic === 'string')) {\n    throw new OperationOutcomeError(validationError('Must provide a topic.'));\n  }\n  if (!FHIRCAST_EVENT_NAMES[event]) {\n    throw new OperationOutcomeError(\n      validationError(\n        `Must provide a valid FHIRcast event name. Supported events: ${Object.keys(FHIRCAST_EVENT_NAMES).join(', ')}`\n      )\n    );\n  }\n  if (typeof context !== 'object') {\n    throw new OperationOutcomeError(validationError('context must be a context object or array of context objects.'));\n  }\n  if ((FHIRCAST_EVENT_VERSION_REQUIRED as readonly string[]).includes(event) && !versionId) {\n    throw new OperationOutcomeError(validationError(`The '${event}' event must contain a 'context.versionId'.`));\n  }\n  const normalizedContexts = Array.isArray(context) ? context : [context];\n  // This will throw if any context in the array is invalid\n  validateFhircastContexts(event, normalizedContexts);\n  return {\n    timestamp: new Date().toISOString(),\n    id: generateId(),\n    event: {\n      'hub.topic': topic,\n      'hub.event': event,\n      context: normalizedContexts,\n      ...(versionId ? { 'context.versionId': versionId } : {}),\n    },\n  };\n}\n\nexport type FhircastConnectEvent = { type: 'connect' };\nexport type FhircastMessageEvent = { type: 'message'; payload: FhircastMessagePayload };\nexport type FhircastDisconnectEvent = { type: 'disconnect' };\n\nexport type FhircastSubscriptionEventMap = {\n  connect: FhircastConnectEvent;\n  message: FhircastMessageEvent;\n  disconnect: FhircastDisconnectEvent;\n};\n\n/**\n * A class representing a `FHIRcast` connection.\n *\n * `FhircastConnection` extends `EventTarget` and emits 3 lifecycle events:\n * 1. `connect` - An event to signal when a WebSocket connection has been opened. Fired as soon as a WebSocket emits `open`.\n * 2. `message` - Contains a `payload` field containing a `FHIRcast` message payload exactly as it comes in over WebSockets.\n * 3. `disconnect` - An event to signal when a WebSocket connection has been closed. Fired as soon as a WebSocket emits `close`.\n *\n * To close the connection, call `connection.disconnect()` and listen to the `disconnect` event to know when the connection has been disconnected.\n */\nexport class FhircastConnection extends TypedEventTarget<FhircastSubscriptionEventMap> {\n  readonly subRequest: SubscriptionRequest;\n  private readonly websocket: WebSocket;\n\n  /**\n   * Creates a new `FhircastConnection`.\n   * @param subRequest - The subscription request to initialize the connection from.\n   */\n  constructor(subRequest: SubscriptionRequest) {\n    super();\n    this.subRequest = subRequest;\n    if (!subRequest.endpoint) {\n      throw new OperationOutcomeError(validationError('Subscription request should contain an endpoint.'));\n    }\n    if (!validateFhircastSubscriptionRequest(subRequest)) {\n      throw new OperationOutcomeError(validationError('Subscription request failed validation.'));\n    }\n    const websocket = new WebSocket(subRequest.endpoint);\n    websocket.addEventListener('open', () => {\n      this.dispatchEvent({ type: 'connect' });\n\n      websocket.addEventListener('message', (event: MessageEvent) => {\n        const message = JSON.parse(event.data) as Record<string, string | object>;\n\n        // This is a check for `subscription request confirmations`, we just discard these for now\n        if (message['hub.topic']) {\n          return;\n        }\n\n        const fhircastMessage = message as unknown as FhircastMessagePayload;\n        // Don't bubble up heartbeats, they are just noise\n        if (fhircastMessage.event['hub.event'] === ('heartbeat' as unknown as FhircastEventName)) {\n          return;\n        }\n        this.dispatchEvent({ type: 'message', payload: fhircastMessage });\n\n        websocket.send(\n          JSON.stringify({\n            id: message?.id,\n            timestamp: new Date().toISOString(),\n          })\n        );\n      });\n\n      websocket.addEventListener('close', () => {\n        this.dispatchEvent({ type: 'disconnect' });\n      });\n    });\n    this.websocket = websocket;\n  }\n\n  disconnect(): void {\n    this.websocket.close();\n  }\n}\n", "import { decodeBase64Url } from './base64';\n\n/**\n * Recognized JWT Claims Set members, any other members may also be present.\n * @see {@link https://github.com/panva/jose/blob/main/src/types.d.ts#L532}\n */\nexport interface JWTPayload {\n  /**\n   * JWT Issuer\n   * @see {@link https://www.rfc-editor.org/rfc/rfc7519#section-4.1.1|RFC7519#section-4.1.1}\n   */\n  iss?: string;\n\n  /**\n   * JWT Subject\n   * @see {@link https://www.rfc-editor.org/rfc/rfc7519#section-4.1.2|RFC7519#section-4.1.2}\n   */\n  sub?: string;\n\n  /**\n   * JWT Audience\n   * @see {@link https://www.rfc-editor.org/rfc/rfc7519#section-4.1.3|RFC7519#section-4.1.3}\n   */\n  aud?: string | string[];\n\n  /**\n   * JWT ID\n   * @see {@link https://www.rfc-editor.org/rfc/rfc7519#section-4.1.7|RFC7519#section-4.1.7}\n   */\n  jti?: string;\n\n  /**\n   * JWT Not Before\n   * @see {@link https://www.rfc-editor.org/rfc/rfc7519#section-4.1.5|RFC7519#section-4.1.5}\n   */\n  nbf?: number;\n\n  /**\n   * JWT Expiration Time\n   * @see {@link https://www.rfc-editor.org/rfc/rfc7519#section-4.1.4|RFC7519#section-4.1.4}\n   */\n  exp?: number;\n\n  /**\n   * JWT Issued At\n   * @see {@link https://www.rfc-editor.org/rfc/rfc7519#section-4.1.6|RFC7519#section-4.1.6}\n   */\n  iat?: number;\n\n  /** Any other JWT Claim Set member. */\n  [propName: string]: unknown;\n}\n\n/**\n * Decodes a section of a JWT.\n * See: https://tools.ietf.org/html/rfc7519\n * @param payload - The JWT payload string.\n * @returns Collection of key value claims in the JWT payload.\n */\nfunction decodePayload(payload: string): JWTPayload {\n  return JSON.parse(decodeBase64Url(payload));\n}\n\n/**\n * Returns true if the token is a JWT.\n * @param token - The potential JWT token.\n * @returns True if the token is a JWT.\n */\nexport function isJwt(token: string): boolean {\n  return token.split('.').length === 3;\n}\n\n/**\n * Parses the JWT payload.\n * @param token - JWT token.\n * @returns Collection of key value claims in the JWT payload.\n */\nexport function parseJWTPayload(token: string): JWTPayload {\n  const [_header, payload, _signature] = token.split('.');\n  return decodePayload(payload);\n}\n\n/**\n * Returns true if the access token was issued by a Medplum server.\n * @param accessToken - An access token of unknown origin.\n * @returns True if the access token was issued by a Medplum server.\n */\nexport function isMedplumAccessToken(accessToken: string): boolean {\n  try {\n    const payload = parseJWTPayload(accessToken);\n    return typeof payload.login_id === 'string';\n  } catch (_err) {\n    return false;\n  }\n}\n\n/**\n * Returns the JWT expiration time in number of milliseconds elapsed since the epoch.\n * @param token - The JWT token.\n * @returns The JWT expiration time in number of milliseconds elapsed since the epoch if available, undefined if unknown.\n */\nexport function tryGetJwtExpiration(token: string): number | undefined {\n  try {\n    const payload = parseJWTPayload(token);\n    const exp = payload.exp;\n    if (typeof exp === 'number') {\n      return exp * 1000;\n    }\n    return undefined;\n  } catch (_err) {\n    return undefined;\n  }\n}\n", "import { MedplumClient } from './client';\nimport { ContentType } from './contenttype';\n\nexport class MedplumKeyValueClient {\n  readonly medplum: MedplumClient;\n\n  constructor(medplum: MedplumClient) {\n    this.medplum = medplum;\n  }\n\n  /**\n   * Gets the value for the given key from the keyvalue store.\n   * @param key - The key to get the value for.\n   * @returns The value for the given key.\n   */\n  async get(key: string): Promise<string | undefined> {\n    return this.medplum.get(`keyvalue/v1/${key}`);\n  }\n\n  /**\n   * Sets the value for the given key in the keyvalue store.\n   * @param key - The key to set the value for.\n   * @param value - The value to set.\n   */\n  async set(key: string, value: string): Promise<void> {\n    await this.medplum.put(`keyvalue/v1/${key}`, value, ContentType.TEXT);\n  }\n\n  /**\n   * Deletes the value for the given key from the keyvalue store.\n   * @param key - The key to delete the value for.\n   */\n  async delete(key: string): Promise<void> {\n    await this.medplum.delete(`keyvalue/v1/${key}`);\n  }\n}\n", "/**\n * The ReadablePromise class wraps a request promise suitable for React Suspense.\n * See: https://blog.logrocket.com/react-suspense-data-fetching/#wrappromise-js\n * See: https://github.com/ovieokeh/suspense-data-fetching/blob/master/lib/api/wrapPromise.js\n */\nexport class ReadablePromise<T> implements Promise<T> {\n  readonly [Symbol.toStringTag]: string = 'ReadablePromise';\n  private readonly suspender: Promise<T>;\n  private status: 'pending' | 'error' | 'success' = 'pending';\n  private response: T | undefined;\n  private error: Error | undefined;\n\n  constructor(requestPromise: Promise<T>) {\n    this.suspender = requestPromise.then(\n      (res: T) => {\n        this.status = 'success';\n        this.response = res;\n        return res;\n      },\n      (err: any) => {\n        this.status = 'error';\n        this.error = err;\n        throw err;\n      }\n    );\n  }\n\n  /**\n   * Returns true if the promise is pending.\n   * @returns True if the Promise is pending.\n   */\n  isPending(): boolean {\n    return this.status === 'pending';\n  }\n\n  /**\n   * Returns true if the promise resolved successfully.\n   * @returns True if the Promise resolved successfully.\n   */\n  isOk(): boolean {\n    return this.status === 'success';\n  }\n\n  /**\n   * Attempts to read the value of the promise.\n   * If the promise is pending, this method will throw a promise.\n   * If the promise rejected, this method will throw the rejection reason.\n   * If the promise resolved, this method will return the resolved value.\n   * @returns The resolved value of the Promise.\n   */\n  read(): T {\n    switch (this.status) {\n      case 'pending':\n        throw this.suspender;\n      case 'error':\n        throw this.error;\n      default:\n        return this.response as T;\n    }\n  }\n\n  /**\n   * Attaches callbacks for the resolution and/or rejection of the Promise.\n   * @param onfulfilled - The callback to execute when the Promise is resolved.\n   * @param onrejected - The callback to execute when the Promise is rejected.\n   * @returns A Promise for the completion of which ever callback is executed.\n   */\n  then<TResult1 = T, TResult2 = never>(\n    onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,\n    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null\n  ): Promise<TResult1 | TResult2> {\n    return this.suspender.then(onfulfilled, onrejected);\n  }\n\n  /**\n   * Attaches a callback for only the rejection of the Promise.\n   * @param onrejected - The callback to execute when the Promise is rejected.\n   * @returns A Promise for the completion of the callback.\n   */\n  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null): Promise<T | TResult> {\n    return this.suspender.catch(onrejected);\n  }\n\n  /**\n   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n   * resolved value cannot be modified from the callback.\n   * @param onfinally - The callback to execute when the Promise is settled (fulfilled or rejected).\n   * @returns A Promise for the completion of the callback.\n   */\n  finally(onfinally?: (() => void) | null): Promise<T> {\n    return this.suspender.finally(onfinally);\n  }\n}\n", "import { stringify } from './utils';\n\nexport interface IClientStorage {\n  getInitPromise?(): Promise<void>;\n  clear(): void;\n  getString(key: string): string | undefined;\n  setString(key: string, value: string | undefined): void;\n  getObject<T>(key: string): T | undefined;\n  setObject<T>(key: string, value: T): void;\n}\n\n/**\n * The ClientStorage class is a utility class for storing strings and objects.\n *\n * When using MedplumClient in the browser, it will be backed by browser localStorage.\n *\n * When Using MedplumClient in the server, it will be backed by the MemoryStorage class.  For example, the Medplum CLI uses `FileSystemStorage`.\n */\nexport class ClientStorage implements IClientStorage {\n  private readonly storage: Storage;\n\n  constructor(storage?: Storage) {\n    this.storage = storage ?? (typeof localStorage !== 'undefined' ? localStorage : new MemoryStorage());\n  }\n\n  clear(): void {\n    this.storage.clear();\n  }\n\n  getString(key: string): string | undefined {\n    return this.storage.getItem(key) ?? undefined;\n  }\n\n  setString(key: string, value: string | undefined): void {\n    if (value) {\n      this.storage.setItem(key, value);\n    } else {\n      this.storage.removeItem(key);\n    }\n  }\n\n  getObject<T>(key: string): T | undefined {\n    const str = this.getString(key);\n    return str ? (JSON.parse(str) as T) : undefined;\n  }\n\n  setObject<T>(key: string, value: T): void {\n    this.setString(key, value ? stringify(value) : undefined);\n  }\n}\n\n/**\n * The MemoryStorage class is a minimal in-memory implementation of the Storage interface.\n */\nexport class MemoryStorage implements Storage {\n  private readonly data: Map<string, string>;\n\n  constructor() {\n    this.data = new Map<string, string>();\n  }\n\n  /**\n   * Returns the number of key/value pairs.\n   * @returns The number of key/value pairs.\n   */\n  get length(): number {\n    return this.data.size;\n  }\n\n  /**\n   * Removes all key/value pairs, if there are any.\n   */\n  clear(): void {\n    this.data.clear();\n  }\n\n  /**\n   * Returns the current value associated with the given key, or null if the given key does not exist.\n   * @param key - The specified storage key.\n   * @returns The current value associated with the given key, or null if the given key does not exist.\n   */\n  getItem(key: string): string | null {\n    return this.data.get(key) ?? null;\n  }\n\n  /**\n   * Sets the value of the pair identified by key to value, creating a new key/value pair if none existed for key previously.\n   * @param key - The storage key.\n   * @param value - The new value.\n   */\n  setItem(key: string, value: string | null): void {\n    if (value) {\n      this.data.set(key, value);\n    } else {\n      this.data.delete(key);\n    }\n  }\n\n  /**\n   * Removes the key/value pair with the given key, if a key/value pair with the given key exists.\n   * @param key - The storage key.\n   */\n  removeItem(key: string): void {\n    this.data.delete(key);\n  }\n\n  /**\n   * Returns the name of the nth key, or null if n is greater than or equal to the number of key/value pairs.\n   * @param index - The numeric index.\n   * @returns The nth key.\n   */\n  key(index: number): string | null {\n    return Array.from(this.data.keys())[index];\n  }\n}\n\n/**\n * The MockAsyncClientStorage class is a mock implementation of the ClientStorage class.\n * This can be used for testing async initialization of the MedplumClient.\n */\nexport class MockAsyncClientStorage extends ClientStorage implements IClientStorage {\n  private initialized: boolean;\n  private readonly initPromise: Promise<void>;\n  private initResolve: () => void = () => undefined;\n\n  constructor() {\n    super();\n    this.initialized = false;\n    this.initPromise = new Promise((resolve) => {\n      this.initResolve = resolve;\n    });\n  }\n\n  setInitialized(): void {\n    if (!this.initialized) {\n      this.initResolve();\n      this.initialized = true;\n    }\n  }\n\n  getInitPromise(): Promise<void> {\n    return this.initPromise;\n  }\n\n  get isInitialized(): boolean {\n    return this.initialized;\n  }\n}\n", "import { TypedEventTarget } from '../eventtarget';\n\n/*!\n * Reconnecting WebSocket\n * by Pedro Ladaria <pedro.ladaria@gmail.com>\n * https://github.com/pladaria/reconnecting-websocket\n * License MIT\n *\n * Copy of \"partysocket\" from Partykit team, a fork of the original \"Reconnecting WebSocket\"\n * https://github.com/partykit/partykit/blob/main/packages/partysocket\n */\n\nexport interface IReconnectingWebSocket extends TypedEventTarget<WebSocketEventMap> {\n  readyState: number;\n  close(code?: number, reason?: string): void;\n  send(message: string): void;\n  reconnect(code?: number, reason?: string): void;\n}\n\nexport interface IReconnectingWebSocketCtor {\n  new (url: string, protocols?: ProtocolsProvider, options?: Options): IReconnectingWebSocket;\n}\n\nexport interface ErrorEvent extends globalThis.Event {\n  message: string;\n  error: Error;\n}\n\nexport interface CloseEvent extends globalThis.Event {\n  code: number;\n  reason: string;\n  wasClean: boolean;\n}\n\nexport type WebSocketEventMap = {\n  close: CloseEvent;\n  error: ErrorEvent;\n  message: MessageEvent;\n  open: Event;\n};\n\n/**\n * This map exists separately from `WebSocketEventMap`, which is the actual event map used for the `ReconnectingWebSocket` class itself,\n * due to slight difference in the type between the events as we use them, and the events as they exist as global interfaces. We need the global interfaces\n * to be generic enough to satisfy conformant implementations that don't exactly match the events we export and use in `ReconnectingWebSocket` itself.\n */\nexport type IWebSocketEventMap = {\n  close: globalThis.CloseEvent;\n  error: globalThis.ErrorEvent;\n  message: globalThis.MessageEvent;\n  open: Event;\n};\n\n/**\n * Generic interface that an implementation of `WebSocket` must satisfy to be used with `ReconnectingWebSocket`.\n * This is a slightly modified fork of the `WebSocket` global type used in Node.\n *\n * The main key difference is making all the `onclose`, `onerror`, etc. functions have `any[]` args, making `data` in `send()` of type `any`, and making `binaryType` of type string,\n * though the particular implementation should narrow each of these implementation-specific types.\n */\nexport interface IWebSocket {\n  binaryType: string;\n\n  readonly bufferedAmount: number;\n  readonly extensions: string;\n\n  onclose: ((...args: any[]) => any) | null;\n  onerror: ((...args: any[]) => any) | null;\n  onmessage: ((...args: any[]) => any) | null;\n  onopen: ((...args: any[]) => any) | null;\n\n  readonly protocol: string;\n  readonly readyState: number;\n  readonly url: string;\n\n  close(code?: number, reason?: string): void;\n  send(data: any): void;\n\n  readonly CLOSED: number;\n  readonly CLOSING: number;\n  readonly CONNECTING: number;\n  readonly OPEN: number;\n\n  addEventListener<K extends keyof WebSocketEventMap>(\n    type: K,\n    listener: (ev: WebSocketEventMap[K]) => any,\n    options?: boolean | AddEventListenerOptions\n  ): void;\n  addEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | AddEventListenerOptions\n  ): void;\n  removeEventListener<K extends keyof WebSocketEventMap>(\n    type: K,\n    listener: (ev: WebSocketEventMap[K]) => any,\n    options?: boolean | EventListenerOptions\n  ): void;\n  removeEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | EventListenerOptions\n  ): void;\n}\n\nconst Events = {\n  Event: (typeof globalThis.Event !== 'undefined' ? globalThis.Event : undefined) as\n    | typeof globalThis.Event\n    | undefined,\n  ErrorEvent: undefined as any,\n  CloseEvent: undefined as any,\n};\n\nlet eventsInitialized = false;\n\nfunction lazyInitEvents(): void {\n  if (typeof globalThis.Event === 'undefined') {\n    throw new Error('Unable to lazy init events for ReconnectingWebSocket. globalThis.Event is not defined yet');\n  }\n\n  Events.Event = globalThis.Event;\n\n  Events.ErrorEvent = class ErrorEvent extends Event implements ErrorEvent {\n    public message: string;\n    public error: Error;\n    constructor(error: Error, target: any) {\n      super('error', target);\n      this.message = error.message;\n      this.error = error;\n    }\n  } as unknown as typeof globalThis.ErrorEvent;\n\n  Events.CloseEvent = class CloseEvent extends Event implements CloseEvent {\n    public code: number;\n    public reason: string;\n    public wasClean = true;\n    // eslint-disable-next-line default-param-last\n    constructor(code = 1000, reason = '', target: any) {\n      super('close', target);\n      this.code = code;\n      this.reason = reason;\n    }\n  } as unknown as typeof globalThis.CloseEvent;\n}\n\nexport function assert(condition: unknown, msg?: string): asserts condition {\n  if (!condition) {\n    throw new Error(msg);\n  }\n}\n\nfunction cloneEvent(e: Event): Event {\n  return new (e as any).constructor(e.type, e);\n}\n\nexport type Options<WS extends IWebSocket = WebSocket> = {\n  WebSocket?: any;\n  binaryType?: WS['binaryType'];\n  maxReconnectionDelay?: number;\n  minReconnectionDelay?: number;\n  reconnectionDelayGrowFactor?: number;\n  minUptime?: number;\n  connectionTimeout?: number;\n  maxRetries?: number;\n  maxEnqueuedMessages?: number;\n  startClosed?: boolean;\n  debug?: boolean;\n  debugLogger?: (...args: any[]) => void;\n};\n\nconst DEFAULT = {\n  maxReconnectionDelay: 10000,\n  minReconnectionDelay: 1000 + Math.random() * 4000,\n  minUptime: 5000,\n  reconnectionDelayGrowFactor: 1.3,\n  connectionTimeout: 4000,\n  maxRetries: Infinity,\n  maxEnqueuedMessages: Infinity,\n  startClosed: false,\n  debug: false,\n};\n\nexport type ProtocolsProvider = null | string | string[];\n\nexport type Message = string | ArrayBuffer | Blob | ArrayBufferView;\n\nlet didWarnAboutMissingWebSocket = false;\n\nexport class ReconnectingWebSocket<WS extends IWebSocket = WebSocket>\n  extends TypedEventTarget<WebSocketEventMap>\n  implements IReconnectingWebSocket\n{\n  private _ws: IWebSocket | undefined;\n  private _retryCount = -1;\n  private _uptimeTimeout: ReturnType<typeof setTimeout> | undefined;\n  private _connectTimeout: ReturnType<typeof setTimeout> | undefined;\n  private _shouldReconnect = true;\n  private _connectLock = false;\n  private _binaryType: WS['binaryType'];\n  private _closeCalled = false;\n  private _messageQueue: Message[] = [];\n\n  private readonly _debugLogger = console.log.bind(console);\n\n  protected _url: string;\n  protected _protocols?: ProtocolsProvider;\n  protected _options: Options<WS>;\n\n  constructor(url: string, protocols?: ProtocolsProvider, options: Options<WS> = {}) {\n    // Initialize all events if they haven't been created yet\n    if (!eventsInitialized) {\n      lazyInitEvents();\n      eventsInitialized = true;\n    }\n\n    super();\n    this._url = url;\n    this._protocols = protocols;\n    this._options = options;\n    if (this._options.startClosed) {\n      this._shouldReconnect = false;\n    }\n    if (this._options.binaryType) {\n      this._binaryType = this._options.binaryType;\n    } else {\n      this._binaryType = 'blob';\n    }\n    if (this._options.debugLogger) {\n      this._debugLogger = this._options.debugLogger;\n    }\n    this._connect();\n  }\n\n  static get CONNECTING(): number {\n    return 0;\n  }\n  static get OPEN(): number {\n    return 1;\n  }\n  static get CLOSING(): number {\n    return 2;\n  }\n  static get CLOSED(): number {\n    return 3;\n  }\n\n  get CONNECTING(): number {\n    return ReconnectingWebSocket.CONNECTING;\n  }\n  get OPEN(): number {\n    return ReconnectingWebSocket.OPEN;\n  }\n  get CLOSING(): number {\n    return ReconnectingWebSocket.CLOSING;\n  }\n  get CLOSED(): number {\n    return ReconnectingWebSocket.CLOSED;\n  }\n\n  get binaryType(): WS['binaryType'] {\n    return this._ws ? this._ws.binaryType : this._binaryType;\n  }\n\n  set binaryType(value: WS['binaryType']) {\n    this._binaryType = value;\n    if (this._ws) {\n      this._ws.binaryType = value;\n    }\n  }\n\n  /**\n   * @returns The number or connection retries.\n   */\n  get retryCount(): number {\n    return Math.max(this._retryCount, 0);\n  }\n\n  /**\n   * @returns The number of bytes of data that have been queued using calls to send() but not yet\n   * transmitted to the network. This value resets to zero once all queued data has been sent.\n   * This value does not reset to zero when the connection is closed; if you keep calling send(),\n   * this will continue to climb. Read only\n   *\n   */\n  get bufferedAmount(): number {\n    const bytes = this._messageQueue.reduce((acc, message) => {\n      if (typeof message === 'string') {\n        acc += message.length; // not byte size\n      } else if (message instanceof Blob) {\n        acc += message.size;\n      } else {\n        acc += message.byteLength;\n      }\n      return acc;\n    }, 0);\n    return bytes + (this._ws?.bufferedAmount ?? 0);\n  }\n\n  /**\n   * @returns The extensions selected by the server. This is currently only the empty string or a list of\n   * extensions as negotiated by the connection\n   */\n  get extensions(): string {\n    return this._ws?.extensions ?? '';\n  }\n\n  /**\n   * @returns A string indicating the name of the sub-protocol the server selected;\n   * this will be one of the strings specified in the protocols parameter when creating the\n   * WebSocket object.\n   */\n  get protocol(): string {\n    return this._ws?.protocol ?? '';\n  }\n\n  /**\n   * @returns The current state of the connection; this is one of the Ready state constants.\n   */\n  get readyState(): number {\n    if (this._ws) {\n      return this._ws.readyState;\n    }\n    return this._options.startClosed ? ReconnectingWebSocket.CLOSED : ReconnectingWebSocket.CONNECTING;\n  }\n\n  /**\n   * @returns The URL as resolved by the constructor.\n   */\n  get url(): string {\n    return this._ws ? this._ws.url : '';\n  }\n\n  /**\n   * @returns Whether the websocket object is now in reconnectable state.\n   */\n  get shouldReconnect(): boolean {\n    return this._shouldReconnect;\n  }\n\n  /**\n   * An event listener to be called when the WebSocket connection's readyState changes to CLOSED\n   */\n  public onclose: ((event: CloseEvent) => void) | null = null;\n\n  /**\n   * An event listener to be called when an error occurs\n   */\n  public onerror: ((event: ErrorEvent) => void) | null = null;\n\n  /**\n   * An event listener to be called when a message is received from the server\n   */\n  public onmessage: ((event: MessageEvent) => void) | null = null;\n\n  /**\n   * An event listener to be called when the WebSocket connection's readyState changes to OPEN;\n   * this indicates that the connection is ready to send and receive data\n   */\n  public onopen: ((event: Event) => void) | null = null;\n\n  /**\n   * Closes the WebSocket connection or connection attempt, if any. If the connection is already\n   * CLOSED, this method does nothing\n   * @param code - The code to close with. Default is 1000.\n   * @param reason - An optional reason for closing the connection.\n   */\n  // eslint-disable-next-line default-param-last\n  public close(code = 1000, reason?: string): void {\n    this._closeCalled = true;\n    this._shouldReconnect = false;\n    this._clearTimeouts();\n    if (!this._ws) {\n      this._debug('close enqueued: no ws instance');\n      return;\n    }\n    if (this._ws.readyState === this.CLOSED) {\n      this._debug('close: already closed');\n      return;\n    }\n    this._ws.close(code, reason);\n  }\n\n  /**\n   * Closes the WebSocket connection or connection attempt and connects again.\n   * Resets retry counter;\n   * @param code - The code to disconnect with. Default is 1000.\n   * @param reason - An optional reason for disconnecting the connection.\n   */\n  public reconnect(code?: number, reason?: string): void {\n    this._shouldReconnect = true;\n    this._closeCalled = false;\n    this._retryCount = -1;\n    if (!this._ws || this._ws.readyState === this.CLOSED) {\n      this._connect();\n    } else {\n      this._disconnect(code, reason);\n      this._connect();\n    }\n  }\n\n  /**\n   * Enqueue specified data to be transmitted to the server over the WebSocket connection\n   * @param data - The data to enqueue.\n   */\n  public send(data: Message): void {\n    if (this._ws && this._ws.readyState === this.OPEN) {\n      this._debug('send', data);\n      this._ws.send(data);\n    } else {\n      const { maxEnqueuedMessages = DEFAULT.maxEnqueuedMessages } = this._options;\n      if (this._messageQueue.length < maxEnqueuedMessages) {\n        this._debug('enqueue', data);\n        this._messageQueue.push(data);\n      }\n    }\n  }\n\n  private _debug(...args: unknown[]): void {\n    if (this._options.debug) {\n      this._debugLogger('RWS>', ...args);\n    }\n  }\n\n  private _getNextDelay(): number {\n    const {\n      reconnectionDelayGrowFactor = DEFAULT.reconnectionDelayGrowFactor,\n      minReconnectionDelay = DEFAULT.minReconnectionDelay,\n      maxReconnectionDelay = DEFAULT.maxReconnectionDelay,\n    } = this._options;\n    let delay = 0;\n    if (this._retryCount > 0) {\n      delay = minReconnectionDelay * Math.pow(reconnectionDelayGrowFactor, this._retryCount - 1);\n      if (delay > maxReconnectionDelay) {\n        delay = maxReconnectionDelay;\n      }\n    }\n    this._debug('next delay', delay);\n    return delay;\n  }\n\n  private _wait(): Promise<void> {\n    return new Promise((resolve) => {\n      setTimeout(resolve, this._getNextDelay());\n    });\n  }\n\n  private _connect(): void {\n    if (this._connectLock || !this._shouldReconnect) {\n      return;\n    }\n    this._connectLock = true;\n\n    const { maxRetries = DEFAULT.maxRetries, connectionTimeout = DEFAULT.connectionTimeout } = this._options;\n\n    if (this._retryCount >= maxRetries) {\n      this._debug('max retries reached', this._retryCount, '>=', maxRetries);\n      return;\n    }\n\n    this._retryCount++;\n\n    this._debug('connect', this._retryCount);\n    this._removeListeners();\n\n    this._wait()\n      .then(() => {\n        // close could be called before creating the ws\n        if (this._closeCalled) {\n          this._connectLock = false;\n          return;\n        }\n        if (!this._options.WebSocket && typeof WebSocket === 'undefined' && !didWarnAboutMissingWebSocket) {\n          console.error('\u203C\uFE0F No WebSocket implementation available. You should define options.WebSocket.');\n          didWarnAboutMissingWebSocket = true;\n        }\n        const WS: typeof WebSocket = this._options.WebSocket || WebSocket;\n        this._debug('connect', { url: this._url, protocols: this._protocols });\n        this._ws = this._protocols ? new WS(this._url, this._protocols) : new WS(this._url);\n\n        this._ws.binaryType = this._binaryType;\n        this._connectLock = false;\n        this._addListeners();\n\n        this._connectTimeout = setTimeout(() => this._handleTimeout(), connectionTimeout);\n      })\n      // via https://github.com/pladaria/reconnecting-websocket/pull/166\n      .catch((err) => {\n        this._connectLock = false;\n        this._handleError(new Events.ErrorEvent(Error(err.message), this));\n      });\n  }\n\n  private _handleTimeout(): void {\n    this._debug('timeout event');\n    this._handleError(new Events.ErrorEvent(Error('TIMEOUT'), this));\n  }\n\n  // eslint-disable-next-line default-param-last\n  private _disconnect(code = 1000, reason?: string): void {\n    this._clearTimeouts();\n    if (!this._ws) {\n      return;\n    }\n    this._removeListeners();\n    try {\n      this._ws.close(code, reason);\n      this._handleClose(new Events.CloseEvent(code, reason, this));\n    } catch (_error) {\n      // ignore\n    }\n  }\n\n  private _acceptOpen(): void {\n    this._debug('accept open');\n    this._retryCount = 0;\n  }\n\n  private readonly _handleOpen = (event: Event): void => {\n    this._debug('open event');\n    const { minUptime = DEFAULT.minUptime } = this._options;\n\n    clearTimeout(this._connectTimeout);\n    this._uptimeTimeout = setTimeout(() => this._acceptOpen(), minUptime);\n\n    assert(this._ws, 'WebSocket is not defined');\n\n    this._ws.binaryType = this._binaryType;\n\n    // send enqueued messages (messages sent before websocket open event)\n    this._messageQueue.forEach((message) => this._ws?.send(message));\n    this._messageQueue = [];\n\n    if (this.onopen) {\n      this.onopen(event);\n    }\n    this.dispatchEvent(cloneEvent(event));\n  };\n\n  private readonly _handleMessage = (event: MessageEvent): void => {\n    this._debug('message event');\n\n    if (this.onmessage) {\n      this.onmessage(event);\n    }\n    this.dispatchEvent(cloneEvent(event));\n  };\n\n  private readonly _handleError = (event: ErrorEvent): void => {\n    this._debug('error event', event.message);\n    this._disconnect(undefined, event.message === 'TIMEOUT' ? 'timeout' : undefined);\n\n    if (this.onerror) {\n      this.onerror(event);\n    }\n    this._debug('exec error listeners');\n    this.dispatchEvent(cloneEvent(event));\n\n    this._connect();\n  };\n\n  private readonly _handleClose = (event: CloseEvent): void => {\n    this._debug('close event');\n    this._clearTimeouts();\n\n    if (this._shouldReconnect) {\n      this._connect();\n    }\n\n    if (this.onclose) {\n      this.onclose(event);\n    }\n    this.dispatchEvent(cloneEvent(event));\n  };\n\n  private _removeListeners(): void {\n    if (!this._ws) {\n      return;\n    }\n    this._debug('removeListeners');\n    this._ws.removeEventListener('open', this._handleOpen);\n    this._ws.removeEventListener('close', this._handleClose);\n    this._ws.removeEventListener('message', this._handleMessage);\n    this._ws.removeEventListener('error', this._handleError);\n  }\n\n  private _addListeners(): void {\n    if (!this._ws) {\n      return;\n    }\n    this._debug('addListeners');\n    this._ws.addEventListener('open', this._handleOpen);\n    this._ws.addEventListener('close', this._handleClose);\n    this._ws.addEventListener('message', this._handleMessage);\n    this._ws.addEventListener('error', this._handleError);\n  }\n\n  private _clearTimeouts(): void {\n    clearTimeout(this._connectTimeout);\n    clearTimeout(this._uptimeTimeout);\n  }\n}\n", "import { Bundle, Parameters, Project, Resource, Subscription, SubscriptionStatus } from '@medplum/fhirtypes';\nimport { MedplumClient } from '../client';\nimport { TypedEventTarget } from '../eventtarget';\nimport { evalFhirPathTyped } from '../fhirpath/parse';\nimport { toTypedValue } from '../fhirpath/utils';\nimport { Logger } from '../logger';\nimport { normalizeErrorString, OperationOutcomeError, serverError, validationError } from '../outcomes';\nimport { matchesSearchRequest } from '../search/match';\nimport { parseSearchRequest } from '../search/search';\nimport { deepEquals, getExtension, getReferenceString, ProfileResource, resolveId, WithId } from '../utils';\nimport {\n  IReconnectingWebSocket,\n  IReconnectingWebSocketCtor,\n  ReconnectingWebSocket,\n} from '../websockets/reconnecting-websocket';\n\nconst DEFAULT_PING_INTERVAL_MS = 5_000;\n\nexport type SubscriptionEventMap = {\n  connect: { type: 'connect'; payload: { subscriptionId: string } };\n  disconnect: { type: 'disconnect'; payload: { subscriptionId: string } };\n  error: { type: 'error'; payload: Error };\n  message: { type: 'message'; payload: Bundle };\n  open: { type: 'open' };\n  close: { type: 'close' };\n  heartbeat: { type: 'heartbeat'; payload: Bundle };\n};\n\n/**\n * An `EventTarget` that emits events when new subscription notifications come in over WebSockets.\n *\n * -----\n *\n * ### Events emitted:\n *\n * - `connect` - A new subscription is connected to the `SubscriptionManager` and `message` events for this subscription can be expected.\n * - `disconnect` - The specified subscription is no longer being monitored by the `SubscriptionManager`.\n * - `error` - An error has occurred.\n * - `message` - A message containing a notification `Bundle` has been received.\n * - `open` - The WebSocket has been opened.\n * - `close` - The WebSocket has been closed.\n * - `heartbeat` - A `heartbeat` message has been received.\n */\nexport class SubscriptionEmitter extends TypedEventTarget<SubscriptionEventMap> {\n  private readonly criteria: Set<string>;\n  constructor(...criteria: string[]) {\n    super();\n    this.criteria = new Set(criteria);\n  }\n  getCriteria(): Set<string> {\n    return this.criteria;\n  }\n  /**\n   * @internal\n   * @param criteria - The criteria to add to this `SubscriptionEmitter`.\n   */\n  _addCriteria(criteria: string): void {\n    this.criteria.add(criteria);\n  }\n  /**\n   * @internal\n   * @param criteria - The criteria to remove from this `SubscriptionEmitter`.\n   */\n  _removeCriteria(criteria: string): void {\n    this.criteria.delete(criteria);\n  }\n}\n\nclass CriteriaEntry {\n  readonly criteria: string;\n  readonly emitter: SubscriptionEmitter;\n  refCount: number;\n  readonly subscriptionProps?: Partial<Subscription>;\n  subscriptionId?: string;\n  token?: string;\n  connecting = false;\n\n  constructor(criteria: string, subscriptionProps?: Partial<Subscription>) {\n    this.criteria = criteria;\n    this.emitter = new SubscriptionEmitter(criteria);\n    this.refCount = 1;\n    this.subscriptionProps = subscriptionProps\n      ? {\n          ...subscriptionProps,\n        }\n      : undefined;\n  }\n\n  clearAttachedSubscription(): void {\n    this.subscriptionId = undefined;\n    this.token = undefined;\n  }\n}\n\ntype CriteriaMapEntry = { bareCriteria?: CriteriaEntry; criteriaWithProps: CriteriaEntry[] };\n\nexport interface SubManagerOptions {\n  ReconnectingWebSocket?: IReconnectingWebSocketCtor;\n  pingIntervalMs?: number;\n  debug?: boolean;\n  debugLogger?: (...args: any[]) => void;\n}\n\nexport class SubscriptionManager {\n  private readonly medplum: MedplumClient;\n  private readonly ws: IReconnectingWebSocket;\n  private masterSubEmitter?: SubscriptionEmitter;\n  private readonly criteriaEntries: Map<string, CriteriaMapEntry>; // Map<criteriaStr, CriteriaMapEntry>\n  private readonly criteriaEntriesBySubscriptionId: Map<string, CriteriaEntry>; // Map<subscriptionId, CriteriaEntry>\n  private wsClosed: boolean;\n  private pingTimer: ReturnType<typeof setInterval> | undefined = undefined;\n  private readonly pingIntervalMs: number;\n  private waitingForPong = false;\n  private currentProfile: ProfileResource | undefined;\n\n  constructor(medplum: MedplumClient, wsUrl: URL | string, options?: SubManagerOptions) {\n    if (!(medplum instanceof MedplumClient)) {\n      throw new OperationOutcomeError(validationError('First arg of constructor should be a `MedplumClient`'));\n    }\n    let url: string;\n    try {\n      url = new URL(wsUrl).toString();\n    } catch (_err) {\n      throw new OperationOutcomeError(validationError('Not a valid URL'));\n    }\n    const ws = options?.ReconnectingWebSocket\n      ? new options.ReconnectingWebSocket(url, undefined, { debug: options?.debug, debugLogger: options?.debugLogger })\n      : new ReconnectingWebSocket(url, undefined, { debug: options?.debug, debugLogger: options?.debugLogger });\n\n    this.medplum = medplum;\n    this.ws = ws;\n    this.masterSubEmitter = new SubscriptionEmitter();\n    this.criteriaEntries = new Map<string, CriteriaMapEntry>();\n    this.criteriaEntriesBySubscriptionId = new Map<string, CriteriaEntry>();\n    this.wsClosed = false;\n    this.pingIntervalMs = options?.pingIntervalMs ?? DEFAULT_PING_INTERVAL_MS;\n    this.currentProfile = medplum.getProfile();\n\n    this.setupListeners();\n  }\n\n  private setupListeners(): void {\n    const ws = this.ws;\n\n    ws.addEventListener('message', (event) => {\n      try {\n        const parsedData = JSON.parse(event.data) as { type: 'pong' } | Bundle;\n        if (parsedData.type === 'pong') {\n          this.waitingForPong = false;\n          return;\n        }\n        const bundle = parsedData;\n        // Get criteria for event\n        const status = bundle?.entry?.[0]?.resource as SubscriptionStatus;\n\n        // Handle heartbeat\n        if (status.type === 'heartbeat') {\n          this.masterSubEmitter?.dispatchEvent({ type: 'heartbeat', payload: bundle });\n          return;\n        }\n\n        // Handle handshake\n        if (status.type === 'handshake') {\n          const subscriptionId = resolveId(status.subscription) as string;\n          const connectEvent = {\n            type: 'connect',\n            payload: { subscriptionId },\n          } as const;\n          this.masterSubEmitter?.dispatchEvent(connectEvent);\n          const criteriaEntry = this.criteriaEntriesBySubscriptionId.get(subscriptionId);\n          if (!criteriaEntry) {\n            console.warn('Received handshake for criteria the SubscriptionManager is not listening for yet');\n            return;\n          }\n          criteriaEntry.connecting = false;\n          criteriaEntry.emitter.dispatchEvent({ ...connectEvent });\n          return;\n        }\n\n        this.masterSubEmitter?.dispatchEvent({ type: 'message', payload: bundle });\n        const criteriaEntry = this.criteriaEntriesBySubscriptionId.get(resolveId(status.subscription) as string);\n        if (!criteriaEntry) {\n          console.warn('Received notification for criteria the SubscriptionManager is not listening for');\n          return;\n        }\n        // Emit event for criteria\n        criteriaEntry.emitter.dispatchEvent({ type: 'message', payload: bundle });\n      } catch (err: unknown) {\n        console.error(err);\n        const errorEvent = { type: 'error', payload: err as Error } as SubscriptionEventMap['error'];\n        this.masterSubEmitter?.dispatchEvent(errorEvent);\n        for (const emitter of this.getAllCriteriaEmitters()) {\n          emitter.dispatchEvent({ ...errorEvent });\n        }\n      }\n    });\n\n    ws.addEventListener('error', () => {\n      const errorEvent = {\n        type: 'error',\n        payload: new OperationOutcomeError(serverError(new Error('WebSocket error'))),\n      } as SubscriptionEventMap['error'];\n      this.masterSubEmitter?.dispatchEvent(errorEvent);\n      for (const emitter of this.getAllCriteriaEmitters()) {\n        emitter.dispatchEvent({ ...errorEvent });\n      }\n    });\n\n    ws.addEventListener('close', () => {\n      const closeEvent = { type: 'close' } as SubscriptionEventMap['close'];\n      this.masterSubEmitter?.dispatchEvent(closeEvent);\n      for (const emitter of this.getAllCriteriaEmitters()) {\n        emitter.dispatchEvent({ ...closeEvent });\n      }\n\n      if (this.pingTimer) {\n        clearInterval(this.pingTimer);\n        this.pingTimer = undefined;\n        this.waitingForPong = false;\n      }\n\n      if (this.wsClosed) {\n        this.criteriaEntries.clear();\n        this.criteriaEntriesBySubscriptionId.clear();\n        this.masterSubEmitter?.removeAllListeners();\n      }\n    });\n\n    ws.addEventListener('open', () => {\n      const openEvent = { type: 'open' } as SubscriptionEventMap['open'];\n      this.masterSubEmitter?.dispatchEvent(openEvent);\n      for (const emitter of this.getAllCriteriaEmitters()) {\n        emitter.dispatchEvent({ ...openEvent });\n      }\n      // We do this after dispatching the events so listeners can check if this is the initial open or not\n      // We are reconnecting\n      // So we refresh all current subscriptions\n      this.refreshAllSubscriptions().catch(console.error);\n\n      if (!this.pingTimer) {\n        this.pingTimer = setInterval(() => {\n          if (this.waitingForPong) {\n            this.waitingForPong = false;\n            ws.reconnect();\n            return;\n          }\n          ws.send(JSON.stringify({ type: 'ping' }));\n          this.waitingForPong = true;\n        }, this.pingIntervalMs);\n      }\n    });\n\n    this.medplum.addEventListener('change', () => {\n      const nextProfile = this.medplum.getProfile();\n      if (this.currentProfile && nextProfile === undefined) {\n        this.ws.close();\n      } else if (nextProfile && this.currentProfile?.id !== nextProfile.id) {\n        this.ws.reconnect();\n      }\n      this.currentProfile = nextProfile;\n    });\n  }\n\n  private emitError(criteriaEntry: CriteriaEntry, error: Error): void {\n    const errorEvent = { type: 'error', payload: error } as SubscriptionEventMap['error'];\n    this.masterSubEmitter?.dispatchEvent(errorEvent);\n    criteriaEntry.emitter.dispatchEvent({ ...errorEvent });\n  }\n\n  private maybeEmitDisconnect(criteriaEntry: CriteriaEntry): void {\n    const { subscriptionId } = criteriaEntry;\n    if (subscriptionId) {\n      const disconnectEvent = {\n        type: 'disconnect',\n        payload: { subscriptionId },\n      } as SubscriptionEventMap['disconnect'];\n      // Emit disconnect on master\n      this.masterSubEmitter?.dispatchEvent(disconnectEvent);\n      // Emit disconnect on criteria emitter\n      criteriaEntry.emitter.dispatchEvent({ ...disconnectEvent });\n    } else {\n      console.warn('Called disconnect for `CriteriaEntry` before `subscriptionId` was present.');\n    }\n  }\n\n  private async getTokenForCriteria(criteriaEntry: CriteriaEntry): Promise<[string, string]> {\n    let subscriptionId = criteriaEntry?.subscriptionId;\n    if (!subscriptionId) {\n      // Make a new subscription\n      const subscription = await this.medplum.createResource<Subscription>({\n        ...criteriaEntry.subscriptionProps,\n        resourceType: 'Subscription',\n        status: 'active',\n        reason: `WebSocket subscription for ${getReferenceString(this.medplum.getProfile() as ProfileResource)}`,\n        channel: { type: 'websocket' },\n        criteria: criteriaEntry.criteria,\n      });\n      subscriptionId = subscription.id;\n    }\n\n    // Get binding token\n    const { parameter } = (await this.medplum.get(\n      `fhir/R4/Subscription/${subscriptionId}/$get-ws-binding-token`\n    )) as Parameters;\n    const token = parameter?.find((param) => param.name === 'token')?.valueString;\n    const url = parameter?.find((param) => param.name === 'websocket-url')?.valueUrl;\n\n    if (!token) {\n      throw new OperationOutcomeError(validationError('Failed to get token'));\n    }\n    if (!url) {\n      throw new OperationOutcomeError(validationError('Failed to get URL from $get-ws-binding-token'));\n    }\n\n    return [subscriptionId, token];\n  }\n\n  private maybeGetCriteriaEntry(\n    criteria: string,\n    subscriptionProps?: Partial<Subscription>\n  ): CriteriaEntry | undefined {\n    const entries = this.criteriaEntries.get(criteria);\n    if (!entries) {\n      return undefined;\n    }\n    if (!subscriptionProps) {\n      return entries.bareCriteria;\n    }\n    for (const entry of entries.criteriaWithProps) {\n      if (deepEquals(subscriptionProps, entry.subscriptionProps)) {\n        return entry;\n      }\n    }\n    return undefined;\n  }\n\n  private getAllCriteriaEmitters(): SubscriptionEmitter[] {\n    const emitters = [];\n    for (const mapEntry of this.criteriaEntries.values()) {\n      if (mapEntry.bareCriteria) {\n        emitters.push(mapEntry.bareCriteria.emitter);\n      }\n      for (const entry of mapEntry.criteriaWithProps) {\n        emitters.push(entry.emitter);\n      }\n    }\n    return emitters;\n  }\n\n  private addCriteriaEntry(criteriaEntry: CriteriaEntry): void {\n    const { criteria, subscriptionProps } = criteriaEntry;\n    let mapEntry: CriteriaMapEntry;\n    if (!this.criteriaEntries.has(criteria)) {\n      mapEntry = { criteriaWithProps: [] as CriteriaEntry[] };\n      this.criteriaEntries.set(criteria, mapEntry);\n    } else {\n      mapEntry = this.criteriaEntries.get(criteria) as CriteriaMapEntry;\n    }\n    // We can assume because this will be \"guarded\" by `maybeGetCriteriaEntry()`,\n    // that we don't need to check if a matching `CriteriaEntry` exists\n    // We just need to put the given one into the right spot\n    if (!subscriptionProps) {\n      mapEntry.bareCriteria = criteriaEntry;\n    } else {\n      mapEntry.criteriaWithProps.push(criteriaEntry);\n    }\n  }\n\n  private removeCriteriaEntry(criteriaEntry: CriteriaEntry): void {\n    const { criteria, subscriptionProps, subscriptionId, token } = criteriaEntry;\n    if (!this.criteriaEntries.has(criteria)) {\n      return;\n    }\n    const mapEntry = this.criteriaEntries.get(criteria) as CriteriaMapEntry;\n    if (!subscriptionProps) {\n      mapEntry.bareCriteria = undefined;\n    } else {\n      mapEntry.criteriaWithProps = mapEntry.criteriaWithProps.filter((otherEntry): boolean => {\n        const otherProps = otherEntry.subscriptionProps as Partial<Subscription>;\n        return !deepEquals(subscriptionProps, otherProps);\n      });\n    }\n    if (!mapEntry.bareCriteria && mapEntry.criteriaWithProps.length === 0) {\n      this.criteriaEntries.delete(criteria);\n      this.masterSubEmitter?._removeCriteria(criteria);\n    }\n    if (subscriptionId) {\n      this.criteriaEntriesBySubscriptionId.delete(subscriptionId);\n    }\n    if (token && this.ws.readyState === WebSocket.OPEN) {\n      this.ws.send(JSON.stringify({ type: 'unbind-from-token', payload: { token } }));\n    }\n  }\n\n  private async subscribeToCriteria(criteriaEntry: CriteriaEntry): Promise<void> {\n    // We check to see if the WebSocket is open first, since if it's not, we will automatically refresh this later when it opens\n    if (this.ws.readyState !== WebSocket.OPEN || criteriaEntry.connecting) {\n      return;\n    }\n    // Set connecting flag to true so other incoming subscription requests to this criteria don't try to subscribe also\n    criteriaEntry.connecting = true;\n    try {\n      const [subscriptionId, token] = await this.getTokenForCriteria(criteriaEntry);\n      criteriaEntry.subscriptionId = subscriptionId;\n      criteriaEntry.token = token;\n      this.criteriaEntriesBySubscriptionId.set(subscriptionId, criteriaEntry);\n      // Send binding message\n      this.ws.send(JSON.stringify({ type: 'bind-with-token', payload: { token } }));\n    } catch (err: unknown) {\n      console.error(normalizeErrorString(err));\n      this.emitError(criteriaEntry, err as Error);\n      this.removeCriteriaEntry(criteriaEntry);\n    }\n  }\n\n  private async refreshAllSubscriptions(): Promise<void> {\n    this.criteriaEntriesBySubscriptionId.clear();\n    for (const mapEntry of this.criteriaEntries.values()) {\n      for (const criteriaEntry of [\n        ...(mapEntry.bareCriteria ? [mapEntry.bareCriteria] : []),\n        ...mapEntry.criteriaWithProps,\n      ]) {\n        criteriaEntry.clearAttachedSubscription();\n        await this.subscribeToCriteria(criteriaEntry);\n      }\n    }\n  }\n\n  addCriteria(criteria: string, subscriptionProps?: Partial<Subscription>): SubscriptionEmitter {\n    if (this.masterSubEmitter) {\n      this.masterSubEmitter._addCriteria(criteria);\n    }\n\n    const criteriaEntry = this.maybeGetCriteriaEntry(criteria, subscriptionProps);\n    if (criteriaEntry) {\n      criteriaEntry.refCount += 1;\n      return criteriaEntry.emitter;\n    }\n\n    const newCriteriaEntry = new CriteriaEntry(criteria, subscriptionProps);\n    this.addCriteriaEntry(newCriteriaEntry);\n\n    this.subscribeToCriteria(newCriteriaEntry).catch(console.error);\n\n    return newCriteriaEntry.emitter;\n  }\n\n  removeCriteria(criteria: string, subscriptionProps?: Partial<Subscription>): void {\n    const criteriaEntry = this.maybeGetCriteriaEntry(criteria, subscriptionProps);\n    if (!criteriaEntry) {\n      console.warn('Criteria not known to `SubscriptionManager`. Possibly called remove too many times.');\n      return;\n    }\n\n    criteriaEntry.refCount -= 1;\n    if (criteriaEntry.refCount > 0) {\n      return;\n    }\n\n    // If actually removing (refcount === 0)\n    this.maybeEmitDisconnect(criteriaEntry);\n    this.removeCriteriaEntry(criteriaEntry);\n  }\n\n  getWebSocket(): IReconnectingWebSocket {\n    return this.ws;\n  }\n\n  closeWebSocket(): void {\n    if (this.wsClosed) {\n      return;\n    }\n    this.wsClosed = true;\n    this.ws.close();\n  }\n\n  reconnectWebSocket(): void {\n    this.ws.reconnect();\n    this.wsClosed = false;\n  }\n\n  getCriteriaCount(): number {\n    return this.getAllCriteriaEmitters().length;\n  }\n\n  getMasterEmitter(): SubscriptionEmitter {\n    if (!this.masterSubEmitter) {\n      this.masterSubEmitter = new SubscriptionEmitter(...Array.from(this.criteriaEntries.keys()));\n    }\n    return this.masterSubEmitter;\n  }\n}\n\nexport type BackgroundJobInteraction = 'create' | 'update' | 'delete';\n\nexport interface BackgroundJobContext {\n  project?: WithId<Project>;\n  interaction: BackgroundJobInteraction;\n}\n\nexport type ResourceMatchesSubscriptionCriteria = {\n  resource: Resource;\n  subscription: Subscription;\n  context: BackgroundJobContext;\n  logger?: Logger;\n  getPreviousResource: (currentResource: Resource) => Promise<Resource | undefined>;\n};\n\nexport async function resourceMatchesSubscriptionCriteria({\n  resource,\n  subscription,\n  context,\n  getPreviousResource,\n  logger,\n}: ResourceMatchesSubscriptionCriteria): Promise<boolean> {\n  if (subscription.meta?.account && resource.meta?.account?.reference !== subscription.meta.account.reference) {\n    logger?.debug('Ignore resource in different account compartment');\n    return false;\n  }\n\n  if (!matchesChannelType(subscription, logger)) {\n    logger?.debug(`Ignore subscription without recognized channel type`);\n    return false;\n  }\n\n  const subscriptionCriteria = subscription.criteria;\n  if (!subscriptionCriteria) {\n    logger?.debug(`Ignore rest hook missing criteria`);\n    return false;\n  }\n\n  const searchRequest = parseSearchRequest(subscriptionCriteria);\n  if (resource.resourceType !== searchRequest.resourceType) {\n    logger?.debug(\n      `Ignore rest hook for different resourceType (wanted \"${searchRequest.resourceType}\", received \"${resource.resourceType}\")`\n    );\n    return false;\n  }\n\n  const fhirPathCriteria = await isFhirCriteriaMet(subscription, resource, getPreviousResource);\n  if (!fhirPathCriteria) {\n    logger?.debug(`Ignore rest hook for criteria returning false`);\n    return false;\n  }\n\n  const supportedInteractionExtension = getExtension(\n    subscription,\n    'https://medplum.com/fhir/StructureDefinition/subscription-supported-interaction'\n  );\n  if (supportedInteractionExtension && supportedInteractionExtension.valueCode !== context.interaction) {\n    logger?.debug(\n      `Ignore rest hook for different interaction (wanted \"${supportedInteractionExtension.valueCode}\", received \"${context.interaction}\")`\n    );\n    return false;\n  }\n\n  return matchesSearchRequest(resource, searchRequest);\n}\n\n/**\n * Returns true if the subscription channel type is ok to execute.\n * @param subscription - The subscription resource.\n * @param logger - The logger.\n * @returns True if the subscription channel type is ok to execute.\n */\nfunction matchesChannelType(subscription: Subscription, logger?: Logger): boolean {\n  const channelType = subscription.channel?.type;\n\n  if (channelType === 'rest-hook') {\n    const url = subscription.channel?.endpoint;\n    if (!url) {\n      logger?.debug(`Ignore rest-hook missing URL`);\n      return false;\n    }\n\n    return true;\n  }\n\n  if (channelType === 'websocket') {\n    return true;\n  }\n\n  return false;\n}\n\nexport async function isFhirCriteriaMet(\n  subscription: Subscription,\n  currentResource: Resource,\n  getPreviousResource: (currentResource: Resource) => Promise<Resource | undefined>\n): Promise<boolean> {\n  const criteria = getExtension(\n    subscription,\n    'https://medplum.com/fhir/StructureDefinition/fhir-path-criteria-expression'\n  );\n  if (!criteria?.valueString) {\n    return true;\n  }\n  const previous = await getPreviousResource(currentResource);\n  const evalInput = {\n    '%current': toTypedValue(currentResource),\n    '%previous': toTypedValue(previous ?? {}),\n  };\n  const evalValue = evalFhirPathTyped(criteria.valueString, [toTypedValue(currentResource)], evalInput);\n  return evalValue?.[0]?.value === true;\n}\n", "// PKCE auth based on:\n// https://aws.amazon.com/blogs/security/how-to-add-authentication-single-page-web-application-with-amazon-cognito-oauth2-implementation/\n\nimport {\n  AccessPolicy,\n  Agent,\n  Attachment,\n  Binary,\n  Bot,\n  BulkDataExport,\n  Bundle,\n  BundleEntry,\n  BundleLink,\n  Communication,\n  Device,\n  DocumentReference,\n  Encounter,\n  ExtractResource,\n  Identifier,\n  Media,\n  OperationOutcome,\n  Patient,\n  Project,\n  ProjectMembership,\n  ProjectMembershipAccess,\n  ProjectSetting,\n  Reference,\n  Resource,\n  ResourceType,\n  SearchParameter,\n  StructureDefinition,\n  Subscription,\n  UserConfiguration,\n  ValueSet,\n} from '@medplum/fhirtypes';\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n/** @ts-ignore */\nimport type { CustomTableLayout, TDocumentDefinitions, TFontDictionary } from 'pdfmake/interfaces';\nimport { encodeBase64 } from './base64';\nimport { LRUCache } from './cache';\nimport { ContentType } from './contenttype';\nimport { encryptSHA256, getRandomString } from './crypto';\nimport { TypedEventTarget } from './eventtarget';\nimport {\n  CurrentContext,\n  FhircastConnection,\n  FhircastEventContext,\n  FhircastEventName,\n  FhircastEventVersionOptional,\n  FhircastEventVersionRequired,\n  PendingSubscriptionRequest,\n  SubscriptionRequest,\n  assertContextVersionOptional,\n  createFhircastMessagePayload,\n  isContextVersionRequired,\n  serializeFhircastSubscriptionRequest,\n  validateFhircastSubscriptionRequest,\n} from './fhircast';\nimport { isJwt, isMedplumAccessToken, parseJWTPayload, tryGetJwtExpiration } from './jwt';\nimport { MedplumKeyValueClient } from './keyvalue';\nimport {\n  OperationOutcomeError,\n  badRequest,\n  isOk,\n  isOperationOutcome,\n  normalizeOperationOutcome,\n  notFound,\n  unauthorized,\n  unauthorizedTokenAudience,\n  unauthorizedTokenExpired,\n  validationError,\n} from './outcomes';\nimport { ReadablePromise } from './readablepromise';\nimport { ClientStorage, IClientStorage } from './storage';\nimport { SubscriptionEmitter, SubscriptionManager } from './subscriptions';\nimport { indexSearchParameter } from './types';\nimport { indexStructureDefinitionBundle, isDataTypeLoaded, isProfileLoaded, loadDataType } from './typeschema/types';\nimport {\n  CodeChallengeMethod,\n  ProfileResource,\n  QueryTypes,\n  WithId,\n  arrayBufferToBase64,\n  concatUrls,\n  createReference,\n  ensureTrailingSlash,\n  getQueryString,\n  getReferenceString,\n  getWebSocketUrl,\n  isObject,\n  resolveId,\n  sleep,\n  sortStringArray,\n} from './utils';\n\nexport const MEDPLUM_VERSION: string = import.meta.env.MEDPLUM_VERSION ?? '';\nexport const MEDPLUM_CLI_CLIENT_ID = 'medplum-cli';\nexport const DEFAULT_ACCEPT = ContentType.FHIR_JSON + ', */*; q=0.1';\n\nconst DEFAULT_BASE_URL = 'https://api.medplum.com/';\nconst DEFAULT_RESOURCE_CACHE_SIZE = 1000;\nconst DEFAULT_BROWSER_CACHE_TIME = 60000; // 60 seconds\nconst DEFAULT_NODE_CACHE_TIME = 0;\nconst DEFAULT_REFRESH_GRACE_PERIOD = 300000; // 5 minutes\nconst BINARY_URL_PREFIX = 'Binary/';\n\nconst system: Device = {\n  resourceType: 'Device',\n  id: 'system',\n  deviceName: [{ type: 'model-name', name: 'System' }],\n};\n\n/**\n * The MedplumClientOptions interface defines configuration options for MedplumClient.\n *\n * All configuration settings are optional.\n */\nexport interface MedplumClientOptions {\n  /**\n   * Base server URL.\n   *\n   * Default value is https://api.medplum.com/\n   *\n   * Use this to point to a custom Medplum deployment.\n   */\n  baseUrl?: string;\n\n  /**\n   * OAuth2 authorize URL.\n   *\n   * Default value is baseUrl + \"/oauth2/authorize\".\n   *\n   * Can be specified as absolute URL or relative to baseUrl.\n   *\n   * Use this if you want to use a separate OAuth server.\n   */\n  authorizeUrl?: string;\n\n  /**\n   * FHIR URL path.\n   *\n   * Default value is \"fhir/R4/\".\n   *\n   * Can be specified as absolute URL or relative to baseUrl.\n   *\n   * Use this if you want to use a different path when connecting to a FHIR server.\n   */\n  fhirUrlPath?: string;\n\n  /**\n   * OAuth2 token URL.\n   *\n   * Default value is baseUrl + \"/oauth2/token\".\n   *\n   * Can be specified as absolute URL or relative to baseUrl.\n   *\n   * Use this if you want to use a separate OAuth server.\n   */\n  tokenUrl?: string;\n\n  /**\n   * OAuth2 logout URL.\n   *\n   * Default value is baseUrl + \"/oauth2/logout\".\n   *\n   * Can be specified as absolute URL or relative to baseUrl.\n   *\n   * Use this if you want to use a separate OAuth server.\n   */\n  logoutUrl?: string;\n\n  /**\n   * FHIRcast Hub URL.\n   *\n   * Default value is `fhircast/STU3`.\n   *\n   * Can be specified as absolute URL or relative to `baseUrl`.\n   *\n   * Use this if you want to use a different path when connecting to a FHIRcast hub.\n   */\n  fhircastHubUrl?: string;\n\n  /**\n   * The client ID.\n   *\n   * Client ID can be used for SMART-on-FHIR customization.\n   */\n  clientId?: string;\n\n  /**\n   * The client secret.\n   *\n   * Client secret can be used for FHIR Oauth Client Credential flows\n   */\n  clientSecret?: string;\n\n  /**\n   * The OAuth Access Token.\n   *\n   * Access Token used to connect to make request to FHIR servers\n   */\n  accessToken?: string;\n\n  /**\n   * Specifies through which part of the HTTP request the client credentials should be sent.\n   *\n   * Body is the default for backwards compatibility, but header may be more desirable for applications.\n   */\n  authCredentialsMethod?: 'body' | 'header';\n\n  /**\n   * Number of resources to store in the cache.\n   *\n   * Default value is 1000.\n   *\n   * Consider using this for performance of displaying Patient or Practitioner resources.\n   */\n  resourceCacheSize?: number;\n\n  /**\n   * The length of time in milliseconds to cache resources.\n   *\n   * Default value is 60000 (60 seconds).\n   *\n   * Cache time of zero disables all caching.\n   *\n   * For any individual request, the cache behavior can be overridden by setting the cache property on request options.\n   *\n   * See: https://developer.mozilla.org/en-US/docs/Web/API/Request/cache\n   */\n  cacheTime?: number;\n\n  /**\n   * The length of time in milliseconds to delay requests for auto batching.\n   *\n   * Auto batching attempts to group multiple requests together into a single batch request.\n   *\n   * Default value is 0, which disables auto batching.\n   */\n  autoBatchTime?: number;\n\n  /**\n   * The refresh grace period in milliseconds.\n   *\n   * This is the amount of time before the access token expires that the client will attempt to refresh the token.\n   *\n   * Default value is 300000 (5 minutes).\n   */\n  refreshGracePeriod?: number;\n\n  /**\n   * Fetch implementation.\n   *\n   * Default is window.fetch (if available).\n   *\n   * For Node.js applications, consider the 'node-fetch' package.\n   */\n  fetch?: FetchLike;\n\n  /**\n   * Storage implementation.\n   *\n   * Default is window.localStorage (if available), this is the common implementation for use in the browser, or an in-memory storage implementation.  If using Medplum on a server it may be useful to provide a custom storage implementation, for example using redis, a database or a file based storage.  Medplum CLI is an an example of `FileSystemStorage`, for reference.\n   */\n  storage?: IClientStorage;\n\n  /**\n   * Create PDF implementation.\n   *\n   * Default is none, and PDF generation is disabled.\n   *\n   * @example\n   * In browser environments, import the client-side pdfmake library.\n   *\n   * ```html\n   * <script src=\"pdfmake.min.js\"></script>\n   * <script>\n   * async function createPdf(docDefinition, tableLayouts, fonts) {\n   *   return new Promise((resolve) => {\n   *     pdfMake.createPdf(docDefinition, tableLayouts, fonts).getBlob(resolve);\n   *   });\n   * }\n   * </script>\n   * ```\n   *\n   * @example\n   * In Node.js applications:\n   *\n   * ```ts\n   * import type { CustomTableLayout, TDocumentDefinitions, TFontDictionary } from 'pdfmake/interfaces';\n   * function createPdf(\n   *   docDefinition: TDocumentDefinitions,\n   *   tableLayouts?: { [name: string]: CustomTableLayout },\n   *   fonts?: TFontDictionary\n   * ): Promise<Buffer> {\n   *   return new Promise((resolve, reject) => {\n   *     const printer = new PdfPrinter(fonts ?? {});\n   *     const pdfDoc = printer.createPdfKitDocument(docDefinition, { tableLayouts });\n   *     const chunks: Uint8Array[] = [];\n   *     pdfDoc.on('data', (chunk: Uint8Array) => chunks.push(chunk));\n   *     pdfDoc.on('end', () => resolve(Buffer.concat(chunks)));\n   *     pdfDoc.on('error', reject);\n   *     pdfDoc.end();\n   *   });\n   * }\n   * ```\n   */\n  createPdf?: CreatePdfFunction;\n\n  /**\n   * Callback for when the client is unauthenticated.\n   *\n   * Default is do nothing.\n   *\n   * For client side applications, consider redirecting to a sign in page.\n   */\n  onUnauthenticated?: () => void;\n\n  /**\n   * The default redirect behavior.\n   *\n   * The default behavior is to not follow redirects.\n   *\n   * Use \"follow\" to automatically follow redirects.\n   */\n  redirect?: RequestRedirect;\n\n  /**\n   * When the verbose flag is set, the client will log all requests and responses to the console.\n   */\n  verbose?: boolean;\n\n  /**\n   * Optional flag to enable or disable Medplum extended mode.\n   *\n   * Medplum extended mode includes a few non-standard FHIR properties such as meta.author and meta.project.\n   *\n   * Default is true.\n   */\n  extendedMode?: boolean;\n\n  /**\n   * Default headers to include in all requests.\n   * This can be used to set custom headers such as Cookies or Authorization headers.\n   */\n  defaultHeaders?: Record<string, string>;\n}\n\nexport interface MedplumRequestOptions extends RequestInit {\n  /**\n   * Optional flag to follow \"Location\" or \"Content-Location\" URL on successful HTTP 200 \"OK\" responses.\n   */\n  followRedirectOnOk?: boolean;\n\n  /**\n   * Optional flag to follow \"Location\" or \"Content-Location\" URL on successful HTTP 201 \"Created\" responses.\n   */\n  followRedirectOnCreated?: boolean;\n\n  /**\n   * Optional flag to poll the status URL on successful HTTP 202 \"Accepted\" responses.\n   */\n  pollStatusOnAccepted?: boolean;\n\n  /**\n   * Optional polling time interval in milliseconds.\n   * Default value is 1000 (1 second).\n   */\n  pollStatusPeriod?: number;\n\n  /**\n   * Optional max number of retries that should be made in the case of a failed request. Default is `2`.\n   */\n  maxRetries?: number;\n\n  /**\n   * Optional maximum time to wait between retries, in milliseconds; defaults to `2000` (2 s).\n   */\n  maxRetryTime?: number;\n\n  /**\n   * Optional flag to disable auto-batching for this specific request.\n   * Only applies when the client is configured with auto-batching enabled.\n   */\n  disableAutoBatch?: boolean;\n}\n\nexport type FetchLike = (url: string, options?: any) => Promise<any>;\n\n/**\n * ResourceArray is an array of resources with a bundle property.\n * The bundle property is a FHIR Bundle containing the search results.\n * This is useful for retrieving bundle metadata such as total, offset, and next link.\n */\nexport type ResourceArray<T extends Resource = Resource> = T[] & { bundle: Bundle<T> };\n\nexport interface CreatePdfFunction {\n  (\n    docDefinition: TDocumentDefinitions,\n    tableLayouts?: Record<string, CustomTableLayout>,\n    fonts?: TFontDictionary\n  ): Promise<any>;\n}\n\nexport interface BaseLoginRequest {\n  readonly projectId?: string;\n  readonly clientId?: string;\n  readonly resourceType?: string;\n  readonly scope?: string;\n  readonly nonce?: string;\n  readonly codeChallenge?: string;\n  readonly codeChallengeMethod?: CodeChallengeMethod;\n  readonly googleClientId?: string;\n  readonly launch?: string;\n  readonly redirectUri?: string;\n}\n\nexport interface EmailPasswordLoginRequest extends BaseLoginRequest {\n  readonly email: string;\n  readonly password: string;\n  /** @deprecated Use scope of \"offline\" or \"offline_access\" instead. */\n  readonly remember?: boolean;\n}\n\nexport interface NewUserRequest {\n  readonly firstName: string;\n  readonly lastName: string;\n  readonly email: string;\n  readonly password: string;\n  readonly recaptchaToken: string;\n  readonly recaptchaSiteKey?: string;\n  readonly remember?: boolean;\n  readonly projectId?: string;\n  readonly clientId?: string;\n}\n\nexport interface NewProjectRequest {\n  readonly login: string;\n  readonly projectName: string;\n}\n\nexport interface NewPatientRequest {\n  readonly login: string;\n  readonly projectId: string;\n}\n\nexport interface GoogleCredentialResponse {\n  readonly clientId: string;\n  readonly credential: string;\n}\n\nexport interface GoogleLoginRequest extends BaseLoginRequest {\n  readonly googleClientId: string;\n  readonly googleCredential: string;\n  readonly createUser?: boolean;\n}\n\nexport interface LoginAuthenticationResponse {\n  readonly login: string;\n  readonly mfaRequired?: boolean;\n  readonly code?: string;\n  readonly memberships?: ProjectMembership[];\n}\n\nexport interface LoginProfileResponse {\n  readonly login: string;\n  readonly scope: string;\n}\n\nexport interface LoginScopeResponse {\n  readonly login: string;\n  readonly code: string;\n}\n\nexport interface LoginState {\n  readonly project: Reference<Project>;\n  readonly profile: Reference<ProfileResource>;\n  readonly accessToken: string;\n  readonly refreshToken: string;\n}\n\nexport interface TokenResponse {\n  readonly token_type: string;\n  readonly id_token: string;\n  readonly access_token: string;\n  readonly refresh_token: string;\n  readonly expires_in: number;\n  readonly project: Reference<Project>;\n  readonly profile: Reference<ProfileResource>;\n}\n\nexport interface BotEvent<T = unknown> {\n  readonly bot: Reference<Bot>;\n  readonly contentType: string;\n  readonly input: T;\n  readonly secrets: Record<string, ProjectSetting>;\n  readonly traceId?: string;\n  /** Headers from the original request, when invoked by HTTP request */\n  readonly headers?: Record<string, string | string[] | undefined>;\n}\n\nexport interface InviteRequest {\n  resourceType: 'Patient' | 'Practitioner' | 'RelatedPerson';\n  firstName: string;\n  lastName: string;\n  email?: string;\n  externalId?: string;\n  scope?: 'project' | 'server';\n  password?: string;\n  sendEmail?: boolean;\n  membership?: Partial<ProjectMembership>;\n  upsert?: boolean;\n  /** @deprecated Use membership.accessPolicy instead. */\n  accessPolicy?: Reference<AccessPolicy>;\n  /** @deprecated Use membership.access instead. */\n  access?: ProjectMembershipAccess[];\n  /** @deprecated Use membership.admin instead. */\n  admin?: boolean;\n}\n\nexport type RateLimitInfo = {\n  name: string;\n  remainingUnits: number;\n  secondsUntilReset: number;\n};\n\n/**\n * JSONPatch patch operation.\n * Compatible with fast-json-patch and rfc6902 Operation.\n */\nexport interface PatchOperation {\n  readonly op: 'add' | 'remove' | 'replace' | 'copy' | 'move' | 'test';\n  readonly path: string;\n  readonly value?: any;\n}\n\n/**\n * Source for a FHIR Binary.\n */\nexport type BinarySource = string | File | Blob | Uint8Array;\n\n/**\n * Binary upload options.\n */\nexport interface CreateBinaryOptions {\n  /**\n   * The binary data to upload.\n   */\n  readonly data: BinarySource;\n\n  /**\n   * Content type for the binary.\n   */\n  readonly contentType: string;\n\n  /**\n   * Optional filename for the binary.\n   */\n  readonly filename?: string;\n\n  /**\n   * Optional security context for the binary.\n   */\n  readonly securityContext?: Reference;\n\n  /**\n   * Optional fetch options. **NOTE:** only `requestOptions.signal` is respected when `onProgress` is also provided.\n   */\n  readonly onProgress?: (e: ProgressEvent) => void;\n}\n\nexport interface CreateMediaOptions extends CreateBinaryOptions {\n  /**\n   * Optional additional fields for the Media resource.\n   */\n  readonly additionalFields?: Partial<Media>;\n}\n\nexport interface CreateDocumentReferenceOptions extends CreateBinaryOptions {\n  /**\n   * Optional additional fields for the DocumentReference resource.\n   */\n  readonly additionalFields?: Omit<Partial<DocumentReference>, 'content'>;\n}\n\n/**\n * PDF upload options.\n */\nexport interface CreatePdfOptions extends Omit<CreateBinaryOptions, 'data' | 'contentType'> {\n  /**\n   * The PDF document definition. See https://pdfmake.github.io/docs/0.1/document-definition-object/\n   */\n  readonly docDefinition: TDocumentDefinitions;\n\n  /**\n   * Optional pdfmake custom table layout.\n   */\n  readonly tableLayouts?: Record<string, CustomTableLayout>;\n\n  /**\n   * Optional pdfmake custom font dictionary.\n   */\n  readonly fonts?: TFontDictionary;\n}\n\n/**\n * Email address definition.\n * Compatible with nodemailer Mail.Address.\n */\nexport interface MailAddress {\n  readonly name: string;\n  readonly address: string;\n}\n\n/**\n * Email destination definition.\n */\nexport type MailDestination = string | MailAddress | string[] | MailAddress[];\n\n/**\n * Email attachment definition.\n * Compatible with nodemailer Mail.Options.\n */\nexport interface MailAttachment {\n  /** String, Buffer or a Stream contents for the attachment */\n  readonly content?: string;\n  /** path to a file or an URL (data uris are allowed as well) if you want to stream the file instead of including it (better for larger attachments) */\n  readonly path?: string;\n  /** filename to be reported as the name of the attached file, use of unicode is allowed. If you do not want to use a filename, set this value as false, otherwise a filename is generated automatically */\n  readonly filename?: string | false;\n  /** optional content type for the attachment, if not set will be derived from the filename property */\n  readonly contentType?: string;\n}\n\n/**\n * Email message definition.\n * Compatible with nodemailer Mail.Options.\n */\nexport interface MailOptions {\n  /** The e-mail address of the sender. All e-mail addresses can be plain `sender@server.com` or formatted `Sender Name <sender@server.com>` */\n  readonly from?: string | MailAddress;\n  /** An e-mail address that will appear on the Sender: field */\n  readonly sender?: string | MailAddress;\n  /** Comma separated list or an array of recipients e-mail addresses that will appear on the To: field */\n  readonly to?: MailDestination;\n  /** Comma separated list or an array of recipients e-mail addresses that will appear on the Cc: field */\n  readonly cc?: MailDestination;\n  /** Comma separated list or an array of recipients e-mail addresses that will appear on the Bcc: field */\n  readonly bcc?: MailDestination;\n  /** An e-mail address that will appear on the Reply-To: field */\n  readonly replyTo?: string | MailAddress;\n  /** The subject of the e-mail */\n  readonly subject?: string;\n  /** The plaintext version of the message */\n  readonly text?: string;\n  /** The HTML version of the message */\n  readonly html?: string;\n  /** An array of attachment objects */\n  readonly attachments?: MailAttachment[];\n}\n\ninterface SchemaGraphQLResponse {\n  readonly data: {\n    readonly StructureDefinitionList: StructureDefinition[];\n    readonly SearchParameterList: SearchParameter[];\n  };\n}\n\ninterface RequestCacheEntry {\n  readonly requestTime: number;\n  readonly value: ReadablePromise<any>;\n}\n\ninterface AutoBatchEntry<T = any> {\n  readonly method: 'GET';\n  readonly url: string;\n  readonly options: MedplumRequestOptions;\n  readonly resolve: (value: T) => void;\n  readonly reject: (reason: any) => void;\n}\n\ninterface RequestState {\n  statusUrl?: string;\n  pollCount?: number;\n}\n\n/**\n * OAuth 2.0 Grant Type Identifiers\n * Standard identifiers: https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-07#name-grant-types\n * JWT bearer extension: https://datatracker.ietf.org/doc/html/rfc7523\n * Token exchange extension: https://datatracker.ietf.org/doc/html/rfc8693\n */\nexport const OAuthGrantType = {\n  ClientCredentials: 'client_credentials',\n  AuthorizationCode: 'authorization_code',\n  RefreshToken: 'refresh_token',\n  JwtBearer: 'urn:ietf:params:oauth:grant-type:jwt-bearer',\n  TokenExchange: 'urn:ietf:params:oauth:grant-type:token-exchange',\n} as const;\nexport type OAuthGrantType = (typeof OAuthGrantType)[keyof typeof OAuthGrantType];\n\n/**\n * OAuth 2.0 Token Type Identifiers\n * See: https://datatracker.ietf.org/doc/html/rfc8693#name-token-type-identifiers\n */\nexport const OAuthTokenType = {\n  /** Indicates that the token is an OAuth 2.0 access token issued by the given authorization server. */\n  AccessToken: 'urn:ietf:params:oauth:token-type:access_token',\n  /** Indicates that the token is an OAuth 2.0 refresh token issued by the given authorization server. */\n  RefreshToken: 'urn:ietf:params:oauth:token-type:refresh_token',\n  /** Indicates that the token is an ID Token as defined in Section 2 of [OpenID.Core]. */\n  IdToken: 'urn:ietf:params:oauth:token-type:id_token',\n  /** Indicates that the token is a base64url-encoded SAML 1.1 [OASIS.saml-core-1.1] assertion. */\n  Saml1Token: 'urn:ietf:params:oauth:token-type:saml1',\n  /** Indicates that the token is a base64url-encoded SAML 2.0 [OASIS.saml-core-2.0-os] assertion. */\n  Saml2Token: 'urn:ietf:params:oauth:token-type:saml2',\n} as const;\nexport type OAuthTokenType = (typeof OAuthTokenType)[keyof typeof OAuthTokenType];\n\n/**\n * OAuth 2.0 Client Authentication Methods\n * See: https://openid.net/specs/openid-connect-core-1_0.html#ClientAuthentication\n */\nexport const OAuthTokenAuthMethod = {\n  ClientSecretBasic: 'client_secret_basic',\n  ClientSecretPost: 'client_secret_post',\n  ClientSecretJwt: 'client_secret_jwt',\n  PrivateKeyJwt: 'private_key_jwt',\n  None: 'none',\n} as const;\nexport type OAuthTokenAuthMethod = (typeof OAuthTokenAuthMethod)[keyof typeof OAuthTokenAuthMethod];\n\n/**\n * OAuth 2.0 Client Authentication Methods\n * See: https://datatracker.ietf.org/doc/html/rfc7523#section-2.2\n */\nexport const OAuthClientAssertionType = {\n  /** Using JWTs for Client Authentication */\n  JwtBearer: 'urn:ietf:params:oauth:client-assertion-type:jwt-bearer',\n} as const;\nexport type OAuthClientAssertionType = (typeof OAuthClientAssertionType)[keyof typeof OAuthClientAssertionType];\n\ninterface SessionDetails {\n  project: Project;\n  membership: ProjectMembership;\n  profile: WithId<ProfileResource>;\n  config: WithId<UserConfiguration>;\n  accessPolicy: AccessPolicy;\n}\n\n/**\n * ValueSet $expand operation parameters.\n * See: https://hl7.org/fhir/r4/valueset-operation-expand.html\n */\nexport interface ValueSetExpandParams {\n  url?: string;\n  filter?: string;\n  date?: string;\n  offset?: number;\n  count?: number;\n}\n\nexport interface RequestProfileSchemaOptions {\n  /** (optional) Whether to include nested profiles, e.g. from extensions. Defaults to false. */\n  expandProfile?: boolean;\n}\n\n/**\n * This map enumerates all the lifecycle events that `MedplumClient` emits and what the shape of the `Event` is.\n */\nexport type MedplumClientEventMap = {\n  change: { type: 'change' };\n  offline: { type: 'offline' };\n  profileRefreshing: { type: 'profileRefreshing' };\n  profileRefreshed: { type: 'profileRefreshed' };\n  storageInitialized: { type: 'storageInitialized' };\n  storageInitFailed: { type: 'storageInitFailed'; payload: { error: Error } };\n};\n\n/**\n * The MedplumClient class provides a client for the Medplum FHIR server.\n *\n * The client can be used in the browser, in a Node.js application, or in a Medplum Bot.\n *\n * The client provides helpful methods for common operations such as:\n *   1. Authenticating\n *   2. Creating resources\n *   3. Reading resources\n *   4. Updating resources\n *   5. Deleting resources\n *   6. Searching\n *   7. Making GraphQL queries\n *\n * The client can also be used to integrate with other FHIR servers. For an example, see the Epic Connection Demo Bot [here](https://github.com/medplum/medplum/tree/main/examples/medplum-demo-bots/src/epic).\n *\n * @example\n * Here is a quick example of how to use the client:\n *\n * ```typescript\n * import { MedplumClient } from '@medplum/core';\n * const medplum = new MedplumClient();\n * ```\n *\n * @example\n * Create a `Patient`:\n *\n * ```typescript\n * const patient = await medplum.createResource({\n *   resourceType: 'Patient',\n *   name: [{\n *     given: ['Alice'],\n *     family: 'Smith'\n *   }]\n * });\n * ```\n *\n * @example\n * Read a `Patient` by ID:\n *\n * ```typescript\n * const patient = await medplum.readResource('Patient', '123');\n * console.log(patient.name[0].given[0]);\n * ```\n *\n * @example\n * Search for a `Patient` by name:\n *\n * ```typescript\n * const bundle = await medplum.search('Patient', 'name=Alice');\n * console.log(bundle.total);\n * ```\n *\n *  <head>\n *    <meta name=\"algolia:pageRank\" content=\"100\" />\n *  </head>\n */\nexport class MedplumClient extends TypedEventTarget<MedplumClientEventMap> {\n  private readonly options: MedplumClientOptions;\n  private readonly fetch: FetchLike;\n  private readonly createPdfImpl?: CreatePdfFunction;\n  private readonly storage: IClientStorage;\n  private readonly requestCache: LRUCache<RequestCacheEntry> | undefined;\n  private readonly cacheTime: number;\n  private readonly baseUrl: string;\n  private readonly fhirBaseUrl: string;\n  private readonly authorizeUrl: string;\n  private readonly tokenUrl: string;\n  private readonly logoutUrl: string;\n  private readonly fhircastHubUrl: string;\n  private readonly defaultHeaders: Record<string, string>;\n  private readonly onUnauthenticated?: () => void;\n  private readonly autoBatchTime: number;\n  private readonly autoBatchQueue: AutoBatchEntry[] | undefined;\n  private readonly refreshGracePeriod: number;\n  private subscriptionManager?: SubscriptionManager;\n  private medplumServer?: boolean;\n  private clientId?: string;\n  private clientSecret?: string;\n  private credentialsInHeader: boolean;\n  private autoBatchTimerId?: any;\n  private accessToken?: string;\n  private accessTokenExpires?: number;\n  private refreshToken?: string;\n  private refreshPromise?: Promise<any>;\n  private profilePromise?: Promise<any>;\n  private sessionDetails?: SessionDetails;\n  private currentRateLimits?: string;\n  private basicAuth?: string;\n  private initPromise: Promise<void>;\n  private initComplete = true;\n  private keyValueClient?: MedplumKeyValueClient;\n\n  constructor(options?: MedplumClientOptions) {\n    super();\n\n    if (options?.baseUrl) {\n      if (!options.baseUrl.startsWith('http')) {\n        throw new Error('Base URL must start with http or https');\n      }\n    }\n\n    this.options = options ?? {};\n    this.fetch = options?.fetch ?? getDefaultFetch();\n    this.storage = options?.storage ?? new ClientStorage();\n    this.createPdfImpl = options?.createPdf;\n    this.baseUrl = ensureTrailingSlash(options?.baseUrl ?? DEFAULT_BASE_URL);\n    this.fhirBaseUrl = concatUrls(this.baseUrl, options?.fhirUrlPath ?? 'fhir/R4');\n    this.authorizeUrl = concatUrls(this.baseUrl, options?.authorizeUrl ?? 'oauth2/authorize');\n    this.tokenUrl = concatUrls(this.baseUrl, options?.tokenUrl ?? 'oauth2/token');\n    this.logoutUrl = concatUrls(this.baseUrl, options?.logoutUrl ?? 'oauth2/logout');\n    this.fhircastHubUrl = concatUrls(this.baseUrl, options?.fhircastHubUrl ?? 'fhircast/STU3');\n    this.clientId = options?.clientId ?? '';\n    this.clientSecret = options?.clientSecret ?? '';\n    this.credentialsInHeader = options?.authCredentialsMethod === 'header';\n    this.defaultHeaders = options?.defaultHeaders ?? {};\n    this.onUnauthenticated = options?.onUnauthenticated;\n    this.refreshGracePeriod = options?.refreshGracePeriod ?? DEFAULT_REFRESH_GRACE_PERIOD;\n\n    this.cacheTime =\n      options?.cacheTime ?? (typeof window === 'undefined' ? DEFAULT_NODE_CACHE_TIME : DEFAULT_BROWSER_CACHE_TIME);\n    if (this.cacheTime > 0) {\n      this.requestCache = new LRUCache(options?.resourceCacheSize ?? DEFAULT_RESOURCE_CACHE_SIZE);\n    } else {\n      this.requestCache = undefined;\n    }\n\n    if (options?.autoBatchTime) {\n      this.autoBatchTime = options.autoBatchTime;\n      this.autoBatchQueue = [];\n    } else {\n      this.autoBatchTime = 0;\n      this.autoBatchQueue = undefined;\n    }\n\n    if (options?.accessToken) {\n      this.setAccessToken(options.accessToken);\n    }\n\n    if (this.storage.getInitPromise === undefined) {\n      if (!options?.accessToken) {\n        this.attemptResumeActiveLogin().catch(console.error);\n      }\n      this.initPromise = Promise.resolve();\n      this.dispatchEvent({ type: 'storageInitialized' });\n    } else {\n      this.initComplete = false;\n      this.initPromise = this.storage.getInitPromise();\n      this.initPromise\n        .then(() => {\n          if (!options?.accessToken) {\n            this.attemptResumeActiveLogin().catch(console.error);\n          }\n          this.initComplete = true;\n          this.dispatchEvent({ type: 'storageInitialized' });\n        })\n        .catch((err: Error) => {\n          console.error(err);\n          this.initComplete = true;\n          this.dispatchEvent({ type: 'storageInitFailed', payload: { error: err } });\n        });\n    }\n\n    this.setupStorageListener();\n  }\n\n  /**\n   * @returns Whether the client has been fully initialized or not. Should always be true unless a custom asynchronous `ClientStorage` was passed into the constructor.\n   */\n  get isInitialized(): boolean {\n    return this.initComplete;\n  }\n\n  /**\n   * Gets a Promise that resolves when async initialization is complete. This is particularly useful for waiting for an async `ClientStorage` and/or authentication to finish.\n   * @returns A Promise that resolves when any async initialization of the client is finished.\n   */\n  getInitPromise(): Promise<void> {\n    return this.initPromise;\n  }\n\n  private async attemptResumeActiveLogin(): Promise<void> {\n    const activeLogin = this.getActiveLogin();\n    if (!activeLogin) {\n      return;\n    }\n    this.setAccessToken(activeLogin.accessToken, activeLogin.refreshToken);\n    await this.refreshProfile();\n  }\n\n  /**\n   * Returns the current base URL for all API requests.\n   * By default, this is set to `https://api.medplum.com/`.\n   * This can be overridden by setting the `baseUrl` option when creating the client.\n   * @category HTTP\n   * @returns The current base URL for all API requests.\n   */\n  getBaseUrl(): string {\n    return this.baseUrl;\n  }\n\n  /**\n   * Returns the current authorize URL.\n   * By default, this is set to `https://api.medplum.com/oauth2/authorize`.\n   * This can be overridden by setting the `authorizeUrl` option when creating the client.\n   * @category HTTP\n   * @returns The current authorize URL.\n   */\n  getAuthorizeUrl(): string {\n    return this.authorizeUrl;\n  }\n\n  /**\n   * Returns the current token URL.\n   * By default, this is set to `https://api.medplum.com/oauth2/token`.\n   * This can be overridden by setting the `tokenUrl` option when creating the client.\n   * @category HTTP\n   * @returns The current token URL.\n   */\n  getTokenUrl(): string {\n    return this.tokenUrl;\n  }\n\n  /**\n   * Returns the current logout URL.\n   * By default, this is set to `https://api.medplum.com/oauth2/logout`.\n   * This can be overridden by setting the `logoutUrl` option when creating the client.\n   * @category HTTP\n   * @returns The current logout URL.\n   */\n  getLogoutUrl(): string {\n    return this.logoutUrl;\n  }\n\n  /**\n   * Returns the current FHIRcast Hub URL.\n   * By default, this is set to `https://api.medplum.com/fhircast/STU3`.\n   * This can be overridden by setting the `logoutUrl` option when creating the client.\n   * @category HTTP\n   * @returns The current FHIRcast Hub URL.\n   */\n  getFhircastHubUrl(): string {\n    return this.fhircastHubUrl;\n  }\n\n  /**\n   * Returns default headers to include in all requests.\n   * This can be used to set custom headers such as Cookies or Authorization headers.\n   * @category HTTP\n   * @returns Default headers to include in all requests.\n   */\n  getDefaultHeaders(): Record<string, string> {\n    return this.defaultHeaders;\n  }\n\n  /**\n   * Clears all auth state including local storage and session storage.\n   * @category Authentication\n   */\n  clear(): void {\n    this.storage.clear();\n    if (typeof window !== 'undefined') {\n      sessionStorage.clear();\n    }\n    this.clearActiveLogin();\n  }\n\n  /**\n   * Clears the active login from local storage.\n   * Does not clear all local storage (such as other logins).\n   * @category Authentication\n   */\n  clearActiveLogin(): void {\n    this.storage.setString('activeLogin', undefined);\n    this.requestCache?.clear();\n    this.accessToken = undefined;\n    this.refreshToken = undefined;\n    this.refreshPromise = undefined;\n    this.accessTokenExpires = undefined;\n    this.sessionDetails = undefined;\n    this.medplumServer = undefined;\n    this.dispatchEvent({ type: 'change' });\n  }\n\n  /**\n   * Invalidates any cached values or cached requests for the given URL.\n   * @category Caching\n   * @param url - The URL to invalidate.\n   */\n  invalidateUrl(url: URL | string): void {\n    url = url.toString();\n    this.requestCache?.delete(url);\n  }\n\n  /**\n   * Invalidates all cached values and flushes the cache.\n   * @category Caching\n   */\n  invalidateAll(): void {\n    this.requestCache?.clear();\n  }\n\n  /**\n   * Invalidates all cached search results or cached requests for the given resourceType.\n   * @category Caching\n   * @param resourceType - The resource type to invalidate.\n   */\n  invalidateSearches(resourceType: ResourceType): void {\n    const url = concatUrls(this.fhirBaseUrl, resourceType);\n    if (this.requestCache) {\n      for (const key of this.requestCache.keys()) {\n        if (key.endsWith(url) || key.includes(url + '?')) {\n          this.requestCache.delete(key);\n        }\n      }\n    }\n  }\n\n  /**\n   * Makes an HTTP GET request to the specified URL.\n   *\n   * This is a lower level method for custom requests.\n   * For common operations, we recommend using higher level methods\n   * such as `readResource()`, `search()`, etc.\n   * @category HTTP\n   * @param url - The target URL.\n   * @param options - Optional fetch options.\n   * @returns Promise to the response content.\n   */\n  get<T = any>(url: URL | string, options: MedplumRequestOptions = {}): ReadablePromise<T> {\n    url = url.toString();\n    const cached = this.getCacheEntry(url, options);\n    if (cached) {\n      return cached.value;\n    }\n\n    let promise: Promise<T>;\n\n    if (url.startsWith(this.fhirBaseUrl) && this.autoBatchQueue && !options.disableAutoBatch) {\n      promise = new Promise<T>((resolve, reject) => {\n        (this.autoBatchQueue as AutoBatchEntry[]).push({\n          method: 'GET',\n          url: (url as string).replace(this.fhirBaseUrl, ''),\n          options,\n          resolve,\n          reject,\n        });\n        if (!this.autoBatchTimerId) {\n          this.autoBatchTimerId = setTimeout(() => this.executeAutoBatch(), this.autoBatchTime);\n        }\n      });\n    } else {\n      promise = this.request<T>('GET', url, options);\n    }\n\n    const readablePromise = new ReadablePromise(promise);\n    this.setCacheEntry(url, readablePromise);\n    return readablePromise;\n  }\n\n  /**\n   * Makes an HTTP POST request to the specified URL.\n   *\n   * This is a lower level method for custom requests.\n   * For common operations, we recommend using higher level methods\n   * such as `createResource()`.\n   * @category HTTP\n   * @param url - The target URL.\n   * @param body - The content body. Strings and `File` objects are passed directly. Other objects are converted to JSON.\n   * @param contentType - The content type to be included in the \"Content-Type\" header.\n   * @param options - Optional fetch options.\n   * @returns Promise to the response content.\n   */\n  post(url: URL | string, body?: any, contentType?: string, options: MedplumRequestOptions = {}): Promise<any> {\n    url = url.toString();\n    this.setRequestBody(options, body);\n    if (contentType) {\n      this.setRequestContentType(options, contentType);\n    }\n    this.invalidateUrl(url);\n    return this.request('POST', url, options);\n  }\n\n  /**\n   * Makes an HTTP PUT request to the specified URL.\n   *\n   * This is a lower level method for custom requests.\n   * For common operations, we recommend using higher level methods\n   * such as `updateResource()`.\n   * @category HTTP\n   * @param url - The target URL.\n   * @param body - The content body. Strings and `File` objects are passed directly. Other objects are converted to JSON.\n   * @param contentType - The content type to be included in the \"Content-Type\" header.\n   * @param options - Optional fetch options.\n   * @returns Promise to the response content.\n   */\n  put(url: URL | string, body: any, contentType?: string, options: MedplumRequestOptions = {}): Promise<any> {\n    url = url.toString();\n    this.setRequestBody(options, body);\n    if (contentType) {\n      this.setRequestContentType(options, contentType);\n    }\n    this.invalidateUrl(url);\n    return this.request('PUT', url, options);\n  }\n\n  /**\n   * Makes an HTTP PATCH request to the specified URL.\n   *\n   * This is a lower level method for custom requests.\n   * For common operations, we recommend using higher level methods\n   * such as `patchResource()`.\n   * @category HTTP\n   * @param url - The target URL.\n   * @param operations - Array of JSONPatch operations.\n   * @param options - Optional fetch options.\n   * @returns Promise to the response content.\n   */\n  patch(url: URL | string, operations: PatchOperation[], options: MedplumRequestOptions = {}): Promise<any> {\n    url = url.toString();\n    this.setRequestBody(options, operations);\n    this.setRequestContentType(options, ContentType.JSON_PATCH);\n    this.invalidateUrl(url);\n    return this.request('PATCH', url, options);\n  }\n\n  /**\n   * Makes an HTTP DELETE request to the specified URL.\n   *\n   *\n   * This is a lower level method for custom requests.\n   * For common operations, we recommend using higher level methods\n   * such as `deleteResource()`.\n   * @category HTTP\n   * @param url - The target URL.\n   * @param options - Optional fetch options.\n   * @returns Promise to the response content.\n   */\n  delete(url: URL | string, options?: MedplumRequestOptions): Promise<any> {\n    url = url.toString();\n    this.invalidateUrl(url);\n    return this.request('DELETE', url, options);\n  }\n\n  /**\n   * Initiates a new user flow.\n   *\n   * This method is part of the two different user registration flows:\n   * 1) New Practitioner and new Project\n   * 2) New Patient registration\n   * @category Authentication\n   * @param newUserRequest - Register request including email and password.\n   * @param options - Optional fetch options.\n   * @returns Promise to the authentication response.\n   */\n  async startNewUser(\n    newUserRequest: NewUserRequest,\n    options?: MedplumRequestOptions\n  ): Promise<LoginAuthenticationResponse> {\n    const { codeChallengeMethod, codeChallenge } = await this.startPkce();\n    return this.post(\n      'auth/newuser',\n      {\n        ...newUserRequest,\n        clientId: newUserRequest.clientId ?? this.clientId,\n        codeChallengeMethod,\n        codeChallenge,\n      },\n      undefined,\n      options\n    ) as Promise<LoginAuthenticationResponse>;\n  }\n\n  /**\n   * Initiates a new project flow.\n   *\n   * This requires a partial login from `startNewUser` or `startNewGoogleUser`.\n   * @param newProjectRequest - Register request including email and password.\n   * @param options - Optional fetch options.\n   * @returns Promise to the authentication response.\n   */\n  async startNewProject(\n    newProjectRequest: NewProjectRequest,\n    options?: MedplumRequestOptions\n  ): Promise<LoginAuthenticationResponse> {\n    return this.post('auth/newproject', newProjectRequest, undefined, options) as Promise<LoginAuthenticationResponse>;\n  }\n\n  /**\n   * Initiates a new patient flow.\n   *\n   * This requires a partial login from `startNewUser` or `startNewGoogleUser`.\n   * @param newPatientRequest - Register request including email and password.\n   * @param options - Optional fetch options.\n   * @returns Promise to the authentication response.\n   */\n  async startNewPatient(\n    newPatientRequest: NewPatientRequest,\n    options?: MedplumRequestOptions\n  ): Promise<LoginAuthenticationResponse> {\n    return this.post('auth/newpatient', newPatientRequest, undefined, options) as Promise<LoginAuthenticationResponse>;\n  }\n\n  /**\n   * Initiates a user login flow.\n   * @category Authentication\n   * @param loginRequest - Login request including email and password.\n   * @param options - Optional fetch options.\n   * @returns Promise to the authentication response.\n   */\n  async startLogin(\n    loginRequest: EmailPasswordLoginRequest,\n    options?: MedplumRequestOptions\n  ): Promise<LoginAuthenticationResponse> {\n    return this.post(\n      'auth/login',\n      {\n        ...(await this.ensureCodeChallenge(loginRequest)),\n        clientId: loginRequest.clientId ?? this.clientId,\n        scope: loginRequest.scope,\n      },\n      undefined,\n      options\n    ) as Promise<LoginAuthenticationResponse>;\n  }\n\n  /**\n   * Tries to sign in with Google authentication.\n   * The response parameter is the result of a Google authentication.\n   * See: https://developers.google.com/identity/gsi/web/guides/handle-credential-responses-js-functions\n   * @category Authentication\n   * @param loginRequest - Login request including Google credential response.\n   * @param options - Optional fetch options.\n   * @returns Promise to the authentication response.\n   */\n  async startGoogleLogin(\n    loginRequest: GoogleLoginRequest,\n    options?: MedplumRequestOptions\n  ): Promise<LoginAuthenticationResponse> {\n    return this.post(\n      'auth/google',\n      {\n        ...(await this.ensureCodeChallenge(loginRequest)),\n        clientId: loginRequest.clientId ?? this.clientId,\n        scope: loginRequest.scope,\n      },\n      undefined,\n      options\n    ) as Promise<LoginAuthenticationResponse>;\n  }\n\n  /**\n   * Returns the PKCE code challenge and method.\n   * If the login request already includes a code challenge, it is returned.\n   * Otherwise, a new PKCE code challenge is generated.\n   * @category Authentication\n   * @param loginRequest - The original login request.\n   * @returns The PKCE code challenge and method.\n   */\n  async ensureCodeChallenge<T extends BaseLoginRequest>(loginRequest: T): Promise<T> {\n    if (loginRequest.codeChallenge) {\n      return loginRequest;\n    }\n    return { ...loginRequest, ...(await this.startPkce()) };\n  }\n\n  /**\n   * Signs out the client.\n   * This revokes the current token and clears token from the local cache.\n   * @category Authentication\n   */\n  async signOut(): Promise<void> {\n    await this.post(this.logoutUrl, {});\n    this.clear();\n  }\n\n  /**\n   * Tries to sign in the user.\n   * Returns true if the user is signed in.\n   * This may result in navigating away to the sign in page.\n   * @category Authentication\n   * @param loginParams - Optional login parameters.\n   * @returns The user profile resource if available.\n   */\n  async signInWithRedirect(loginParams?: Partial<BaseLoginRequest>): Promise<ProfileResource | undefined> {\n    const urlParams = new URLSearchParams(window.location.search);\n    const code = urlParams.get('code');\n    if (!code) {\n      await this.requestAuthorization(loginParams);\n      return undefined;\n    }\n    return this.processCode(code);\n  }\n\n  /**\n   * Tries to sign out the user.\n   * See: https://docs.aws.amazon.com/cognito/latest/developerguide/logout-endpoint.html\n   * @category Authentication\n   */\n  signOutWithRedirect(): void {\n    window.location.assign(this.logoutUrl);\n  }\n\n  /**\n   * Initiates sign in with an external identity provider.\n   * @param authorizeUrl - The external authorization URL.\n   * @param clientId - The external client ID.\n   * @param redirectUri - The external identity provider redirect URI.\n   * @param baseLogin - The Medplum login request.\n   * @param pkceEnabled - Whether `PKCE` should be enabled for this external auth request. Defaults to `true`.\n   * @category Authentication\n   */\n  async signInWithExternalAuth(\n    authorizeUrl: string,\n    clientId: string,\n    redirectUri: string,\n    baseLogin: BaseLoginRequest,\n    pkceEnabled = true\n  ): Promise<void> {\n    let loginRequest = baseLogin;\n    if (pkceEnabled) {\n      loginRequest = await this.ensureCodeChallenge(baseLogin);\n    }\n    window.location.assign(\n      this.getExternalAuthRedirectUri(authorizeUrl, clientId, redirectUri, loginRequest, pkceEnabled)\n    );\n  }\n\n  /**\n   * Exchange an external access token for a Medplum access token.\n   * @param token - The access token that was generated by the external identity provider.\n   * @param clientId - The ID of the `ClientApplication` in your Medplum project that will be making the exchange request.\n   * @returns The user profile resource.\n   * @category Authentication\n   */\n  async exchangeExternalAccessToken(token: string, clientId?: string): Promise<ProfileResource> {\n    clientId = clientId ?? this.clientId;\n    if (!clientId) {\n      throw new Error('MedplumClient is missing clientId');\n    }\n\n    return this.fetchTokens({\n      grant_type: OAuthGrantType.TokenExchange,\n      subject_token_type: OAuthTokenType.AccessToken,\n      client_id: clientId,\n      subject_token: token,\n    });\n  }\n\n  /**\n   * Builds the external identity provider redirect URI.\n   * @param authorizeUrl - The external authorization URL.\n   * @param clientId - The external client ID.\n   * @param redirectUri - The external identity provider redirect URI.\n   * @param loginRequest - The Medplum login request.\n   * @param pkceEnabled - Whether `PKCE` should be enabled for this external auth request. Defaults to `true`.\n   * @returns The external identity provider redirect URI.\n   * @category Authentication\n   */\n  getExternalAuthRedirectUri(\n    authorizeUrl: string,\n    clientId: string,\n    redirectUri: string,\n    loginRequest: BaseLoginRequest,\n    pkceEnabled = true\n  ): string {\n    const url = new URL(authorizeUrl);\n    url.searchParams.set('response_type', 'code');\n    url.searchParams.set('client_id', clientId);\n    url.searchParams.set('redirect_uri', redirectUri);\n    url.searchParams.set('scope', loginRequest.scope ?? 'openid profile email');\n    url.searchParams.set('state', JSON.stringify(loginRequest));\n\n    if (pkceEnabled) {\n      const { codeChallenge, codeChallengeMethod } = loginRequest;\n      if (!codeChallengeMethod) {\n        throw new Error('`LoginRequest` for external auth must include a `codeChallengeMethod`.');\n      }\n      if (!codeChallenge) {\n        throw new Error('`LoginRequest` for external auth must include a `codeChallenge`.');\n      }\n      url.searchParams.set('code_challenge_method', codeChallengeMethod);\n      url.searchParams.set('code_challenge', codeChallenge);\n    }\n\n    return url.toString();\n  }\n\n  /**\n   * Builds a FHIR URL from a collection of URL path components.\n   * For example, `fhirUrl('Patient', '123')` returns `fhir/R4/Patient/123`.\n   * @category HTTP\n   * @param path - The path component of the URL.\n   * @returns The well-formed FHIR URL.\n   */\n  fhirUrl(...path: string[]): URL {\n    return new URL(concatUrls(this.fhirBaseUrl, path.join('/')));\n  }\n\n  /**\n   * Builds a FHIR search URL from a search query or structured query object.\n   * @category HTTP\n   * @category Search\n   * @param resourceType - The FHIR resource type.\n   * @param query - The FHIR search query or structured query object. Can be any valid input to the URLSearchParams() constructor.\n   * @returns The well-formed FHIR URL.\n   */\n  fhirSearchUrl(resourceType: ResourceType, query: QueryTypes): URL {\n    const url = this.fhirUrl(resourceType);\n    if (query) {\n      url.search = getQueryString(query);\n    }\n    return url;\n  }\n\n  /**\n   * Sends a FHIR search request.\n   *\n   * @example\n   * Example using a FHIR search string:\n   *\n   * ```typescript\n   * const bundle = await client.search('Patient', 'name=Alice');\n   * console.log(bundle);\n   * ```\n   *\n   * @example\n   * The return value is a FHIR bundle:\n   *\n   * ```json\n   * {\n   *    \"resourceType\": \"Bundle\",\n   *    \"type\": \"searchset\",\n   *    \"entry\": [\n   *       {\n   *          \"resource\": {\n   *             \"resourceType\": \"Patient\",\n   *             \"name\": [\n   *                {\n   *                   \"given\": [\n   *                      \"George\"\n   *                   ],\n   *                   \"family\": \"Washington\"\n   *                }\n   *             ],\n   *          }\n   *       }\n   *    ]\n   * }\n   * ```\n   *\n   * @example\n   * To query the count of a search, use the summary feature like so:\n   *\n   * ```typescript\n   * const patients = medplum.search('Patient', '_summary=count');\n   * ```\n   *\n   * See FHIR search for full details: https://www.hl7.org/fhir/search.html\n   * @category Search\n   * @param resourceType - The FHIR resource type.\n   * @param query - Optional FHIR search query or structured query object. Can be any valid input to the URLSearchParams() constructor.\n   * @param options - Optional fetch options.\n   * @returns Promise to the search result bundle.\n   */\n  search<RT extends ResourceType>(\n    resourceType: RT,\n    query?: QueryTypes,\n    options?: MedplumRequestOptions\n  ): ReadablePromise<Bundle<WithId<ExtractResource<RT>>>> {\n    const url = this.fhirSearchUrl(resourceType, query);\n    const cacheKey = 'search-' + url.toString();\n    const cached = this.getCacheEntry(cacheKey, options);\n    if (cached) {\n      return cached.value;\n    }\n    const promise = this.getBundle<WithId<ExtractResource<RT>>>(url, options);\n    this.setCacheEntry(cacheKey, promise);\n    return promise;\n  }\n\n  /**\n   * Sends a FHIR search request for a single resource.\n   *\n   * This is a convenience method for `search()` that returns the first resource rather than a `Bundle`.\n   *\n   * @example\n   * Example using a FHIR search string:\n   *\n   * ```typescript\n   * const patient = await client.searchOne('Patient', 'identifier=123');\n   * console.log(patient);\n   * ```\n   *\n   * The return value is the resource, if available; otherwise, undefined.\n   *\n   * See FHIR search for full details: https://www.hl7.org/fhir/search.html\n   * @category Search\n   * @param resourceType - The FHIR resource type.\n   * @param query - Optional FHIR search query or structured query object. Can be any valid input to the URLSearchParams() constructor.\n   * @param options - Optional fetch options.\n   * @returns Promise to the first search result.\n   */\n  searchOne<RT extends ResourceType>(\n    resourceType: RT,\n    query?: QueryTypes,\n    options?: MedplumRequestOptions\n  ): ReadablePromise<WithId<ExtractResource<RT>> | undefined> {\n    const url = this.fhirSearchUrl(resourceType, query);\n    url.searchParams.set('_count', '1');\n    url.searchParams.sort();\n    const cacheKey = 'searchOne-' + url.toString();\n    const cached = this.getCacheEntry(cacheKey, options);\n    if (cached) {\n      return cached.value;\n    }\n    const promise = new ReadablePromise(\n      this.search<RT>(resourceType, url.searchParams, options).then((b) => b.entry?.[0]?.resource)\n    );\n    this.setCacheEntry(cacheKey, promise);\n    return promise;\n  }\n\n  /**\n   * Sends a FHIR search request for an array of resources.\n   *\n   * This is a convenience method for `search()` that returns the resources as an array rather than a `Bundle`.\n   *\n   * @example\n   * Example using a FHIR search string:\n   *\n   * ```typescript\n   * const patients = await client.searchResources('Patient', 'name=Alice');\n   * console.log(patients);\n   * ```\n   *\n   * The return value is an array of resources.\n   *\n   * See FHIR search for full details: https://www.hl7.org/fhir/search.html\n   * @category Search\n   * @param resourceType - The FHIR resource type.\n   * @param query - Optional FHIR search query or structured query object. Can be any valid input to the URLSearchParams() constructor.\n   * @param options - Optional fetch options.\n   * @returns Promise to the array of search results.\n   */\n  searchResources<RT extends ResourceType>(\n    resourceType: RT,\n    query?: QueryTypes,\n    options?: MedplumRequestOptions\n  ): ReadablePromise<ResourceArray<WithId<ExtractResource<RT>>>> {\n    const url = this.fhirSearchUrl(resourceType, query);\n    const cacheKey = 'searchResources-' + url.toString();\n    const cached = this.getCacheEntry(cacheKey, options);\n    if (cached) {\n      return cached.value;\n    }\n    const promise = new ReadablePromise(this.search<RT>(resourceType, query, options).then(bundleToResourceArray));\n    this.setCacheEntry(cacheKey, promise);\n    return promise;\n  }\n\n  /**\n   * Creates an\n   * [async generator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncGenerator)\n   * over a series of FHIR search requests for paginated search results. Each iteration of the generator yields\n   * the array of resources on each page. Searches using _offset based pagination are limited to 10,000 records.\n   * For larger result sets, _cursor based pagination should be used instead.\n   * See: https://www.medplum.com/docs/search/paginated-search#cursor-based-pagination\n   *\n   * @example\n   *\n   * ```typescript\n   * for await (const page of medplum.searchResourcePages('Patient', { _count: 10 })) {\n   *  for (const patient of page) {\n   *    console.log(`Processing Patient resource with ID: ${patient.id}`);\n   *  }\n   * }\n   * ```\n   *\n   * @category Search\n   * @param resourceType - The FHIR resource type.\n   * @param query - Optional FHIR search query or structured query object. Can be any valid input to the URLSearchParams() constructor.\n   * @param options - Optional fetch options.\n   * @yields An async generator, where each result is an array of resources for each page.\n   */\n  async *searchResourcePages<RT extends ResourceType>(\n    resourceType: RT,\n    query?: QueryTypes,\n    options?: MedplumRequestOptions\n  ): AsyncGenerator<ResourceArray<WithId<ExtractResource<RT>>>> {\n    let url: URL | undefined = this.fhirSearchUrl(resourceType, query);\n\n    while (url) {\n      const searchParams: URLSearchParams = new URL(url).searchParams;\n      if (!searchParams.has('_count')) {\n        searchParams.set('_count', '1000'); // Force maximum page size to reduce server load\n      }\n\n      const bundle = await this.search(resourceType, searchParams, options);\n      const nextLink: BundleLink | undefined = bundle.link?.find((link) => link.relation === 'next');\n      if (!bundle.entry?.length && !nextLink) {\n        break;\n      }\n\n      yield bundleToResourceArray(bundle);\n      url = nextLink?.url ? new URL(nextLink.url) : undefined;\n    }\n  }\n\n  /**\n   * Searches a ValueSet resource using the \"expand\" operation.\n   * See: https://www.hl7.org/fhir/operation-valueset-expand.html\n   * @category Search\n   * @param params - The ValueSet expand parameters.\n   * @param options - Optional fetch options.\n   * @returns Promise to expanded ValueSet.\n   */\n  valueSetExpand(params: ValueSetExpandParams, options?: MedplumRequestOptions): ReadablePromise<ValueSet> {\n    const url = this.fhirUrl('ValueSet', '$expand');\n    url.search = new URLSearchParams(params as Record<string, string>).toString();\n    return this.get(url.toString(), options);\n  }\n\n  /**\n   * Returns a cached resource if it is available.\n   * @category Caching\n   * @param resourceType - The FHIR resource type.\n   * @param id - The FHIR resource ID.\n   * @returns The resource if it is available in the cache; undefined otherwise.\n   */\n  getCached<RT extends ResourceType>(resourceType: RT, id: string): WithId<ExtractResource<RT>> | undefined {\n    const cached = this.requestCache?.get(this.fhirUrl(resourceType, id).toString())?.value;\n    return cached?.isOk() ? (cached.read() as WithId<ExtractResource<RT>>) : undefined;\n  }\n\n  /**\n   * Returns a cached resource if it is available.\n   * @category Caching\n   * @param reference - The FHIR reference.\n   * @returns The resource if it is available in the cache; undefined otherwise.\n   */\n  getCachedReference<T extends Resource>(reference: Reference<T>): T | undefined {\n    const refString = reference.reference as string;\n    if (!refString) {\n      return undefined;\n    }\n    if (refString === 'system') {\n      return system as T;\n    }\n    const [resourceType, id] = refString.split('/');\n    if (!resourceType || !id) {\n      return undefined;\n    }\n    return this.getCached(resourceType as ResourceType, id) as T | undefined;\n  }\n\n  /**\n   * Reads a resource by resource type and ID.\n   *\n   * @example\n   * Example:\n   *\n   * ```typescript\n   * const patient = await medplum.readResource('Patient', '123');\n   * console.log(patient);\n   * ```\n   *\n   * See the FHIR \"read\" operation for full details: https://www.hl7.org/fhir/http.html#read\n   * @category Read\n   * @param resourceType - The FHIR resource type.\n   * @param id - The resource ID.\n   * @param options - Optional fetch options.\n   * @returns The resource if available.\n   */\n  readResource<RT extends ResourceType>(\n    resourceType: RT,\n    id: string,\n    options?: MedplumRequestOptions\n  ): ReadablePromise<WithId<ExtractResource<RT>>> {\n    if (!id) {\n      throw new Error('The \"id\" parameter cannot be null, undefined, or an empty string.');\n    }\n    return this.get<WithId<ExtractResource<RT>>>(this.fhirUrl(resourceType, id), options);\n  }\n\n  /**\n   * Reads a resource by `Reference`.\n   *\n   * This is a convenience method for `readResource()` that accepts a `Reference` object.\n   *\n   * @example\n   * Example:\n   *\n   * ```typescript\n   * const serviceRequest = await medplum.readResource('ServiceRequest', '123');\n   * const patient = await medplum.readReference(serviceRequest.subject);\n   * console.log(patient);\n   * ```\n   *\n   * See the FHIR \"read\" operation for full details: https://www.hl7.org/fhir/http.html#read\n   * @category Read\n   * @param reference - The FHIR reference object.\n   * @param options - Optional fetch options.\n   * @returns The resource if available.\n   */\n  readReference<T extends Resource>(\n    reference: Reference<T>,\n    options?: MedplumRequestOptions\n  ): ReadablePromise<WithId<T>> {\n    const refString = reference.reference;\n    if (!refString) {\n      return new ReadablePromise(Promise.reject(new Error('Missing reference')));\n    }\n    if (refString === 'system') {\n      return new ReadablePromise(Promise.resolve(system as unknown as WithId<T>));\n    }\n    const [resourceType, id] = refString.split('/');\n    if (!resourceType || !id) {\n      return new ReadablePromise(Promise.reject(new Error('Invalid reference')));\n    }\n    return this.readResource(resourceType as ResourceType, id, options) as ReadablePromise<WithId<T>>;\n  }\n\n  /**\n   * Requests the schema for a resource type.\n   * If the schema is already cached, the promise is resolved immediately.\n   * @category Schema\n   * @param resourceType - The FHIR resource type.\n   * @returns Promise to a schema with the requested resource type.\n   */\n  requestSchema(resourceType: string): Promise<void> {\n    if (isDataTypeLoaded(resourceType)) {\n      return Promise.resolve();\n    }\n\n    const cacheKey = resourceType + '-requestSchema';\n    const cached = this.getCacheEntry(cacheKey, undefined);\n    if (cached) {\n      return cached.value;\n    }\n\n    const promise = new ReadablePromise<void>(\n      (async () => {\n        const query = `{\n      StructureDefinitionList(_filter: \"name eq ${resourceType}\") {\n        resourceType,\n        name,\n        kind,\n        description,\n        type,\n        url,\n        snapshot {\n          element {\n            id,\n            path,\n            definition,\n            min,\n            max,\n            base {\n              path,\n              min,\n              max\n            },\n            contentReference,\n            type {\n              code,\n              profile,\n              targetProfile\n            },\n            binding {\n              strength,\n              valueSet\n            }\n          }\n        }\n      }\n      SearchParameterList(base: \"${resourceType}\", _count: 100) {\n        base,\n        code,\n        type,\n        expression,\n        target\n      }\n    }`.replace(/\\s+/g, ' ');\n\n        const response = (await this.graphql(query)) as SchemaGraphQLResponse;\n\n        indexStructureDefinitionBundle(response.data.StructureDefinitionList);\n\n        for (const searchParameter of response.data.SearchParameterList) {\n          indexSearchParameter(searchParameter);\n        }\n      })()\n    );\n    this.setCacheEntry(cacheKey, promise);\n    return promise;\n  }\n\n  /**\n   * Requests the schema for a profile.\n   * If the schema is already cached, the promise is resolved immediately.\n   * @category Schema\n   * @param profileUrl - The FHIR URL of the profile\n   * @param options - (optional) Additional options\n   * @returns Promise for schema request.\n   */\n  requestProfileSchema(profileUrl: string, options?: RequestProfileSchemaOptions): Promise<void> {\n    if (!options?.expandProfile && isProfileLoaded(profileUrl)) {\n      return Promise.resolve();\n    }\n\n    const cacheKey = profileUrl + '-requestSchema' + (options?.expandProfile ? '-nested' : '');\n    const cached = this.getCacheEntry(cacheKey, undefined);\n    if (cached) {\n      return cached.value;\n    }\n\n    const promise = new ReadablePromise<void>(\n      (async () => {\n        if (options?.expandProfile) {\n          const url = this.fhirUrl('StructureDefinition', '$expand-profile');\n          url.search = new URLSearchParams({ url: profileUrl }).toString();\n          const sdBundle = (await this.post(url.toString(), {})) as Bundle<StructureDefinition>;\n          indexStructureDefinitionBundle(sdBundle);\n        } else {\n          // Just sort by lastUpdated. Ideally, it would also be based on a logical sort of version\n          // See https://hl7.org/fhir/references.html#canonical-matching for more discussion\n          const sd = await this.searchOne('StructureDefinition', {\n            url: profileUrl,\n            _sort: '-_lastUpdated',\n          });\n\n          if (!sd) {\n            console.warn(`No StructureDefinition found for ${profileUrl}!`);\n            return;\n          }\n\n          loadDataType(sd);\n        }\n      })()\n    );\n    this.setCacheEntry(cacheKey, promise);\n    return promise;\n  }\n\n  /**\n   * Reads resource history by resource type and ID.\n   *\n   * The return value is a bundle of all versions of the resource.\n   *\n   * @example\n   * Example:\n   *\n   * ```typescript\n   * const history = await medplum.readHistory('Patient', '123');\n   * console.log(history);\n   * ```\n   *\n   * See the FHIR \"history\" operation for full details: https://www.hl7.org/fhir/http.html#history\n   * @category Read\n   * @param resourceType - The FHIR resource type.\n   * @param id - The resource ID.\n   * @param options - Optional fetch options.\n   * @returns Promise to the resource history.\n   */\n  readHistory<RT extends ResourceType>(\n    resourceType: RT,\n    id: string,\n    options?: MedplumRequestOptions\n  ): ReadablePromise<Bundle<WithId<ExtractResource<RT>>>> {\n    return this.get(this.fhirUrl(resourceType, id, '_history'), options);\n  }\n\n  /**\n   * Reads a specific version of a resource by resource type, ID, and version ID.\n   *\n   * @example\n   * Example:\n   *\n   * ```typescript\n   * const version = await medplum.readVersion('Patient', '123', '456');\n   * console.log(version);\n   * ```\n   *\n   * See the FHIR \"vread\" operation for full details: https://www.hl7.org/fhir/http.html#vread\n   * @category Read\n   * @param resourceType - The FHIR resource type.\n   * @param id - The resource ID.\n   * @param vid - The version ID.\n   * @param options - Optional fetch options.\n   * @returns The resource if available.\n   */\n  readVersion<RT extends ResourceType>(\n    resourceType: RT,\n    id: string,\n    vid: string,\n    options?: MedplumRequestOptions\n  ): ReadablePromise<WithId<ExtractResource<RT>>> {\n    return this.get(this.fhirUrl(resourceType, id, '_history', vid), options);\n  }\n\n  /**\n   * Executes the Patient \"everything\" operation for a patient.\n   *\n   * @example\n   * Example:\n   *\n   * ```typescript\n   * const bundle = await medplum.readPatientEverything('123');\n   * console.log(bundle);\n   * ```\n   *\n   * See the FHIR \"patient-everything\" operation for full details: https://hl7.org/fhir/operation-patient-everything.html\n   * @category Read\n   * @param id - The Patient Id\n   * @param options - Optional fetch options.\n   * @returns A Bundle of all Resources related to the Patient\n   */\n  readPatientEverything(id: string, options?: MedplumRequestOptions): ReadablePromise<Bundle> {\n    return this.getBundle(this.fhirUrl('Patient', id, '$everything'), options);\n  }\n\n  /**\n   * Executes the Patient \"summary\" operation for a patient.\n   *\n   * @example\n   * Example:\n   *\n   * ```typescript\n   * const bundle = await medplum.readPatientSummary('123');\n   * console.log(bundle);\n   * ```\n   *\n   * See International Patient Summary Implementation Guide: https://build.fhir.org/ig/HL7/fhir-ips/index.html\n   *\n   * See Patient summary operation: https://build.fhir.org/ig/HL7/fhir-ips/OperationDefinition-summary.html\n   *\n   * @param id - The Patient ID.\n   * @param options - Optional fetch options.\n   * @returns A patient summary bundle, organized into the patient summary sections.\n   */\n  readPatientSummary(id: string, options?: MedplumRequestOptions): ReadablePromise<Bundle> {\n    return this.getBundle(this.fhirUrl('Patient', id, '$summary'), options);\n  }\n\n  /**\n   * Creates a new FHIR resource.\n   *\n   * The return value is the newly created resource, including the ID and meta.\n   *\n   * @example\n   * Example:\n   *\n   * ```typescript\n   * const result = await medplum.createResource({\n   *   resourceType: 'Patient',\n   *   name: [{\n   *    family: 'Smith',\n   *    given: ['John']\n   *   }]\n   * });\n   * console.log(result.id);\n   * ```\n   *\n   * See the FHIR \"create\" operation for full details: https://www.hl7.org/fhir/http.html#create\n   * @category Create\n   * @param resource - The FHIR resource to create.\n   * @param options - Optional fetch options.\n   * @returns The result of the create operation.\n   */\n  createResource<T extends Resource>(resource: T, options?: MedplumRequestOptions): Promise<WithId<T>> {\n    if (!resource.resourceType) {\n      throw new Error('Missing resourceType');\n    }\n    this.invalidateSearches(resource.resourceType);\n    return this.post(this.fhirUrl(resource.resourceType), resource, undefined, options);\n  }\n\n  /**\n   * Conditionally create a new FHIR resource only if some equivalent resource does not already exist on the server.\n   *\n   * The return value is the existing resource or the newly created resource, including the ID and meta.\n   *\n   * @example\n   * Example:\n   *\n   * ```typescript\n   * const result = await medplum.createResourceIfNoneExist(\n   *   {\n   *     resourceType: 'Patient',\n   *     identifier: [{\n   *      system: 'http://example.com/mrn',\n   *      value: '123'\n   *     }]\n   *     name: [{\n   *      family: 'Smith',\n   *      given: ['John']\n   *     }]\n   *   },\n   *   'identifier=123'\n   * );\n   * console.log(result.id);\n   * ```\n   *\n   * This method is syntactic sugar for:\n   *\n   * ```typescript\n   * return searchOne(resourceType, query) ?? createResource(resource);\n   * ```\n   *\n   * The query parameter only contains the search parameters (what would be in the URL following the \"?\").\n   *\n   * See the FHIR \"conditional create\" operation for full details: https://www.hl7.org/fhir/http.html#ccreate\n   * @category Create\n   * @param resource - The FHIR resource to create.\n   * @param query - The search query for an equivalent resource (should not include resource type or \"?\").\n   * @param options - Optional fetch options.\n   * @returns The result of the create operation.\n   */\n  async createResourceIfNoneExist<T extends Resource>(\n    resource: T,\n    query: string,\n    options?: MedplumRequestOptions\n  ): Promise<WithId<T>> {\n    const url = this.fhirUrl(resource.resourceType);\n    if (!options) {\n      options = { headers: { 'If-None-Exist': query } };\n    } else if (!options.headers) {\n      options.headers = { 'If-None-Exist': query };\n    } else if (Array.isArray(options.headers)) {\n      options.headers.push(['If-None-Exist', query]);\n    } else if (options.headers instanceof Headers) {\n      options.headers.set('If-None-Exist', query);\n    } else {\n      options.headers['If-None-Exist'] = query;\n    }\n\n    const result = await this.post(url, resource, undefined, options);\n    this.cacheResource(result);\n    this.invalidateUrl(this.fhirUrl(resource.resourceType, resource.id as string, '_history'));\n    this.invalidateSearches(resource.resourceType);\n    return result;\n  }\n\n  /**\n   * Upsert a resource: update it in place if it exists, otherwise create it.  This is done in a single, transactional\n   * request to guarantee data consistency.\n   * @param resource - The resource to update or create.\n   * @param query - A FHIR search query to uniquely identify the resource if it already exists.\n   * @param options  - Optional fetch options.\n   * @returns The updated/created resource.\n   */\n  async upsertResource<T extends Resource>(\n    resource: T,\n    query: QueryTypes,\n    options?: MedplumRequestOptions\n  ): Promise<WithId<T>> {\n    // Build conditional update URL, e.g. `PUT /ResourceType?search-param=value`\n    const url = this.fhirSearchUrl(resource.resourceType, query);\n\n    let result = await this.put(url, resource, undefined, options);\n    if (!result) {\n      // On 304 not modified, result will be undefined\n      // Return the user input instead\n      result = resource;\n    }\n    this.cacheResource(result);\n    this.invalidateUrl(this.fhirUrl(resource.resourceType, resource.id as string, '_history'));\n    this.invalidateSearches(resource.resourceType);\n    return result;\n  }\n\n  /**\n   * Creates a FHIR `Attachment` with the provided data content.\n   *\n   * This is a convenience method for creating a `Binary` resource and then creating an `Attachment` element.\n   *\n   * The `data` parameter can be a string or a `File` object.\n   *\n   * A `File` object often comes from a `<input type=\"file\">` element.\n   *\n   * @example\n   * Example:\n   *\n   * ```typescript\n   * const result = await medplum.createAttachment(myFile, 'test.jpg', 'image/jpeg');\n   * console.log(result);\n   * ```\n   *\n   * See the FHIR \"create\" operation for full details: https://www.hl7.org/fhir/http.html#create\n   * @category Create\n   * @param createBinaryOptions -The binary options. See `CreateBinaryOptions` for full details.\n   * @param requestOptions - Optional fetch options. **NOTE:** only `options.signal` is respected when `onProgress` is also provided.\n   * @returns The result of the create operation.\n   */\n  createAttachment(\n    createBinaryOptions: CreateBinaryOptions,\n    requestOptions?: MedplumRequestOptions\n  ): Promise<Attachment>;\n\n  /**\n   * @category Create\n   * @param data - The binary data to upload.\n   * @param filename - Optional filename for the binary.\n   * @param contentType - Content type for the binary.\n   * @param onProgress - Optional callback for progress events. **NOTE:** only `options.signal` is respected when `onProgress` is also provided.\n   * @param options - Optional fetch options. **NOTE:** only `options.signal` is respected when `onProgress` is also provided.\n   * @returns The result of the create operation.\n   * @deprecated Use `createAttachment` with `CreateBinaryOptions` instead. To be removed in a future version.\n   */\n  createAttachment(\n    data: BinarySource,\n    filename: string | undefined,\n    contentType: string,\n    onProgress?: (e: ProgressEvent) => void,\n    options?: MedplumRequestOptions\n  ): Promise<Attachment>;\n\n  async createAttachment(\n    arg1: BinarySource | CreateBinaryOptions,\n    arg2: string | undefined | MedplumRequestOptions,\n    arg3?: string,\n    arg4?: (e: ProgressEvent) => void,\n    arg5?: MedplumRequestOptions\n  ): Promise<Attachment> {\n    let createBinaryOptions = normalizeCreateBinaryOptions(arg1, arg2, arg3, arg4);\n\n    if (createBinaryOptions.contentType === ContentType.XML) {\n      const fileData = createBinaryOptions.data;\n      let fileStr: string;\n\n      if (fileData instanceof Blob) {\n        fileStr = await new Promise<string>((resolve, reject) => {\n          const reader = new FileReader();\n          reader.onload = () => {\n            if (!reader.result) {\n              reject(new Error('Failed to load file'));\n              return;\n            }\n            resolve(reader.result as string);\n          };\n          reader.readAsText(fileData, 'utf-8');\n        });\n      } else if (ArrayBuffer.isView(fileData)) {\n        fileStr = new TextDecoder().decode(fileData);\n      } else {\n        fileStr = fileData;\n      }\n\n      // Both of the above strings are required to be within a valid C-CDA document\n      // The root element in a CDA document should be a \"ClinicalDocument\"\n      // \"urn:hl7-org:v3\" is a required namespace to be referenced by all valid C-CDA documents as well\n      if (fileStr.includes('<ClinicalDocument') && fileStr.includes('urn:hl7-org:v3')) {\n        createBinaryOptions = { ...createBinaryOptions, contentType: ContentType.CDA_XML };\n      }\n    }\n\n    const requestOptions = arg5 ?? (typeof arg2 === 'object' ? arg2 : {});\n    const binary = await this.createBinary(createBinaryOptions, requestOptions);\n    return {\n      contentType: createBinaryOptions.contentType,\n      url: binary.url,\n      title: createBinaryOptions.filename,\n    };\n  }\n\n  /**\n   * Creates a FHIR `Binary` resource with the provided data content.\n   *\n   * The return value is the newly created resource, including the ID and meta.\n   *\n   * The `data` parameter can be a string or a `File` object.\n   *\n   * A `File` object often comes from a `<input type=\"file\">` element.\n   *\n   * @example\n   * Example:\n   *\n   * ```typescript\n   * const result = await medplum.createBinary(myFile, 'test.jpg', 'image/jpeg');\n   * console.log(result.id);\n   * ```\n   *\n   * See the FHIR \"create\" operation for full details: https://www.hl7.org/fhir/http.html#create\n   *\n   * @category Create\n   * @param createBinaryOptions -The binary options. See `CreateBinaryOptions` for full details.\n   * @param requestOptions - Optional fetch options. **NOTE:** only `options.signal` is respected when `onProgress` is also provided.\n   * @returns The result of the create operation.\n   */\n  createBinary(\n    createBinaryOptions: CreateBinaryOptions,\n    requestOptions?: MedplumRequestOptions\n  ): Promise<WithId<Binary>>;\n\n  /**\n   * @category Create\n   * @param data - The binary data to upload.\n   * @param filename - Optional filename for the binary.\n   * @param contentType - Content type for the binary.\n   * @param onProgress - Optional callback for progress events. **NOTE:** only `options.signal` is respected when `onProgress` is also provided.\n   * @param options - Optional fetch options. **NOTE:** only `options.signal` is respected when `onProgress` is also provided.\n   * @returns The result of the create operation.\n   * @deprecated Use `createBinary` with `CreateBinaryOptions` instead. To be removed in a future version.\n   */\n  createBinary(\n    data: BinarySource,\n    filename: string | undefined,\n    contentType: string,\n    onProgress?: (e: ProgressEvent) => void,\n    options?: MedplumRequestOptions\n  ): Promise<WithId<Binary>>;\n\n  createBinary(\n    arg1: BinarySource | CreateBinaryOptions,\n    arg2: string | undefined | MedplumRequestOptions,\n    arg3?: string,\n    arg4?: (e: ProgressEvent) => void,\n    arg5?: MedplumRequestOptions\n  ): Promise<WithId<Binary>> {\n    const createBinaryOptions = normalizeCreateBinaryOptions(arg1, arg2, arg3, arg4);\n    const requestOptions = arg5 ?? (typeof arg2 === 'object' ? arg2 : {});\n\n    const { data, contentType, filename, securityContext, onProgress } = createBinaryOptions;\n\n    const url = this.fhirUrl('Binary');\n    if (filename) {\n      url.searchParams.set('_filename', filename);\n    }\n\n    if (securityContext?.reference) {\n      this.setRequestHeader(requestOptions, 'X-Security-Context', securityContext.reference);\n    }\n\n    if (onProgress) {\n      return this.uploadwithProgress(url, data, contentType, onProgress, requestOptions);\n    }\n    return this.post(url, data, contentType, requestOptions);\n  }\n\n  uploadwithProgress(\n    url: URL,\n    data: BinarySource,\n    contentType: string,\n    onProgress: (e: ProgressEvent) => void,\n    options?: MedplumRequestOptions\n  ): Promise<any> {\n    return new Promise((resolve, reject) => {\n      const xhr = new XMLHttpRequest();\n\n      // Ensure the 'abort' event listener is removed from the signal to prevent memory leaks,\n      // especially in scenarios where there is a long-lived signal across multiple requests.\n      const handleSignalAbort = (): void => xhr.abort();\n      options?.signal?.addEventListener('abort', handleSignalAbort);\n      const sendResult = (result: any): void => {\n        options?.signal?.removeEventListener('abort', handleSignalAbort);\n\n        if (result instanceof Error) {\n          reject(result);\n        } else {\n          resolve(result);\n        }\n      };\n\n      xhr.responseType = 'json';\n      xhr.onabort = () => sendResult(new DOMException('Request aborted', 'AbortError'));\n      xhr.onerror = () => sendResult(new Error('Request error'));\n\n      if (onProgress) {\n        xhr.upload.onprogress = (e) => onProgress(e);\n        xhr.upload.onload = (e) => onProgress(e);\n      }\n\n      xhr.onload = () => {\n        if (xhr.status >= 200 && xhr.status < 300) {\n          sendResult(xhr.response);\n        } else {\n          sendResult(new OperationOutcomeError(normalizeOperationOutcome(xhr.response || xhr.statusText)));\n        }\n      };\n\n      xhr.open('POST', url);\n      xhr.withCredentials = true;\n      xhr.setRequestHeader('Authorization', 'Bearer ' + this.accessToken);\n      xhr.setRequestHeader('Cache-Control', 'no-cache, no-store, max-age=0');\n      xhr.setRequestHeader('Content-Type', contentType);\n\n      if (this.options.extendedMode !== false) {\n        xhr.setRequestHeader('X-Medplum', 'extended');\n      }\n\n      if (options?.headers) {\n        const headers = options.headers as Record<string, string>;\n        for (const [key, value] of Object.entries(headers)) {\n          xhr.setRequestHeader(key, value);\n        }\n      }\n\n      xhr.send(data);\n    });\n  }\n\n  /**\n   * Creates a PDF as a FHIR `Binary` resource based on pdfmake document definition.\n   *\n   * The return value is the newly created resource, including the ID and meta.\n   *\n   * The `docDefinition` parameter is a pdfmake document definition.\n   *\n   * @example\n   * Example:\n   *\n   * ```typescript\n   * const result = await medplum.createPdf({\n   *   content: ['Hello world']\n   * });\n   * console.log(result.id);\n   * ```\n   *\n   * See the pdfmake document definition for full details: https://pdfmake.github.io/docs/0.1/document-definition-object/\n   * @category Media\n   * @param createPdfOptions - The PDF creation options. See `CreatePdfOptions` for full details.\n   * @param requestOptions - Optional fetch options.\n   * @returns The result of the create operation.\n   */\n  createPdf(createPdfOptions: CreatePdfOptions, requestOptions?: MedplumRequestOptions): Promise<WithId<Binary>>;\n\n  /**\n   * @category Media\n   * @param docDefinition - The PDF document definition.\n   * @param filename - Optional filename for the PDF binary resource.\n   * @param tableLayouts - Optional pdfmake custom table layout.\n   * @param fonts - Optional pdfmake custom font dictionary.\n   * @returns The result of the create operation.\n   * @deprecated Use `createPdf` with `CreatePdfOptions` instead. To be removed in a future version.\n   */\n  createPdf(\n    docDefinition: TDocumentDefinitions,\n    filename: string | undefined,\n    tableLayouts?: Record<string, CustomTableLayout>,\n    fonts?: TFontDictionary\n  ): Promise<WithId<Binary>>;\n\n  async createPdf(\n    arg1: TDocumentDefinitions | CreatePdfOptions,\n    arg2?: string | MedplumRequestOptions,\n    arg3?: Record<string, CustomTableLayout>,\n    arg4?: TFontDictionary\n  ): Promise<WithId<Binary>> {\n    if (!this.createPdfImpl) {\n      throw new Error('PDF creation not enabled');\n    }\n    const createPdfOptions = normalizeCreatePdfOptions(arg1, arg2, arg3, arg4);\n    const requestOptions = typeof arg2 === 'object' ? arg2 : {};\n    const { docDefinition, tableLayouts, fonts, ...rest } = createPdfOptions;\n    const blob = await this.createPdfImpl(docDefinition, tableLayouts, fonts);\n    const createBinaryOptions = { ...rest, data: blob, contentType: 'application/pdf' };\n    return this.createBinary(createBinaryOptions, requestOptions);\n  }\n\n  /**\n   * Creates a FHIR `Communication` resource with the provided data content.\n   *\n   * This is a convenience method to handle common cases where a `Communication` resource is created with a `payload`.\n   * @category Create\n   * @param resource - The FHIR resource to comment on.\n   * @param text - The text of the comment.\n   * @param options - Optional fetch options.\n   * @returns The result of the create operation.\n   */\n  createComment(resource: Resource, text: string, options?: MedplumRequestOptions): Promise<WithId<Communication>> {\n    const profile = this.getProfile();\n    let encounter: Reference<Encounter> | undefined = undefined;\n    let subject: Reference<Patient> | undefined = undefined;\n\n    if (resource.resourceType === 'Encounter') {\n      encounter = createReference(resource);\n      subject = resource.subject as Reference<Patient> | undefined;\n    }\n\n    if (resource.resourceType === 'ServiceRequest') {\n      encounter = resource.encounter;\n      subject = resource.subject as Reference<Patient> | undefined;\n    }\n\n    if (resource.resourceType === 'Patient') {\n      subject = createReference(resource);\n    }\n\n    return this.createResource(\n      {\n        resourceType: 'Communication',\n        status: 'completed',\n        basedOn: [createReference(resource)],\n        encounter,\n        subject,\n        sender: profile ? createReference(profile) : undefined,\n        sent: new Date().toISOString(),\n        payload: [{ contentString: text }],\n      },\n      options\n    );\n  }\n\n  /**\n   * Updates a FHIR resource.\n   *\n   * The return value is the updated resource, including the ID and meta.\n   *\n   * @example\n   * Example:\n   *\n   * ```typescript\n   * const result = await medplum.updateResource({\n   *   resourceType: 'Patient',\n   *   id: '123',\n   *   name: [{\n   *    family: 'Smith',\n   *    given: ['John']\n   *   }]\n   * });\n   * console.log(result.meta.versionId);\n   * ```\n   *\n   * See the FHIR \"update\" operation for full details: https://www.hl7.org/fhir/http.html#update\n   * @category Write\n   * @param resource - The FHIR resource to update.\n   * @param options - Optional fetch options.\n   * @returns The result of the update operation.\n   */\n  async updateResource<T extends Resource>(resource: T, options?: MedplumRequestOptions): Promise<WithId<T>> {\n    if (!resource.resourceType) {\n      throw new Error('Missing resourceType');\n    }\n    if (!resource.id) {\n      throw new Error('Missing id');\n    }\n    let result = await this.put(this.fhirUrl(resource.resourceType, resource.id), resource, undefined, options);\n    if (!result) {\n      // On 304 not modified, result will be undefined\n      // Return the user input instead\n      result = resource;\n    }\n    this.cacheResource(result);\n    this.invalidateUrl(this.fhirUrl(resource.resourceType, resource.id, '_history'));\n    this.invalidateSearches(resource.resourceType);\n    return result;\n  }\n\n  /**\n   * Updates a FHIR resource using JSONPatch operations.\n   *\n   * The return value is the updated resource, including the ID and meta.\n   *\n   * @example\n   * Example:\n   *\n   * ```typescript\n   * const result = await medplum.patchResource('Patient', '123', [\n   *   {op: 'replace', path: '/name/0/family', value: 'Smith'},\n   * ]);\n   * console.log(result.meta.versionId);\n   * ```\n   *\n   * See the FHIR \"update\" operation for full details: https://www.hl7.org/fhir/http.html#patch\n   *\n   * See the JSONPatch specification for full details: https://tools.ietf.org/html/rfc6902\n   * @category Write\n   * @param resourceType - The FHIR resource type.\n   * @param id - The resource ID.\n   * @param operations - The JSONPatch operations.\n   * @param options - Optional fetch options.\n   * @returns The result of the patch operations.\n   */\n  async patchResource<RT extends ResourceType>(\n    resourceType: RT,\n    id: string,\n    operations: PatchOperation[],\n    options?: MedplumRequestOptions\n  ): Promise<WithId<ExtractResource<RT>>> {\n    const result = await this.patch(this.fhirUrl(resourceType, id), operations, options);\n    this.cacheResource(result);\n    this.invalidateUrl(this.fhirUrl(resourceType, id, '_history'));\n    this.invalidateSearches(resourceType);\n    return result;\n  }\n\n  /**\n   * Deletes a FHIR resource by resource type and ID.\n   *\n   * @example\n   * Example:\n   *\n   * ```typescript\n   * await medplum.deleteResource('Patient', '123');\n   * ```\n   *\n   * See the FHIR \"delete\" operation for full details: https://www.hl7.org/fhir/http.html#delete\n   * @category Delete\n   * @param resourceType - The FHIR resource type.\n   * @param id - The resource ID.\n   * @param options - Optional fetch options.\n   * @returns The result of the delete operation.\n   */\n  deleteResource(resourceType: ResourceType, id: string, options?: MedplumRequestOptions): Promise<any> {\n    this.deleteCacheEntry(this.fhirUrl(resourceType, id).toString());\n    this.invalidateSearches(resourceType);\n    return this.delete(this.fhirUrl(resourceType, id), options);\n  }\n\n  /**\n   * Executes the validate operation with the provided resource.\n   *\n   * @example\n   * Example:\n   *\n   * ```typescript\n   * const result = await medplum.validateResource({\n   *   resourceType: 'Patient',\n   *   name: [{ given: ['Alice'], family: 'Smith' }],\n   * });\n   * ```\n   *\n   * See the FHIR \"$validate\" operation for full details: https://www.hl7.org/fhir/resource-operation-validate.html\n   * @param resource - The FHIR resource.\n   * @param options - Optional fetch options.\n   * @returns The validate operation outcome.\n   */\n  validateResource<T extends Resource>(resource: T, options?: MedplumRequestOptions): Promise<OperationOutcome> {\n    return this.post(this.fhirUrl(resource.resourceType, '$validate'), resource, undefined, options);\n  }\n\n  /**\n   * Executes a bot by ID or Identifier.\n   * @param idOrIdentifier - The Bot ID or Identifier.\n   * @param body - The content body. Strings and `File` objects are passed directly. Other objects are converted to JSON.\n   * @param contentType - The content type to be included in the \"Content-Type\" header.\n   * @param options - Optional fetch options.\n   * @returns The Bot return value.\n   */\n  executeBot(\n    idOrIdentifier: string | Identifier,\n    body: any,\n    contentType?: string,\n    options?: MedplumRequestOptions\n  ): Promise<any> {\n    let url: URL;\n    if (typeof idOrIdentifier === 'string') {\n      const id = idOrIdentifier;\n      url = this.fhirUrl('Bot', id, '$execute');\n    } else {\n      const identifier = idOrIdentifier;\n      url = this.fhirUrl('Bot', '$execute');\n      url.searchParams.set('identifier', identifier.system + '|' + identifier.value);\n    }\n    return this.post(url, body, contentType, options);\n  }\n\n  /**\n   * Executes a batch or transaction of FHIR operations.\n   *\n   * @example\n   * Example:\n   *\n   * ```typescript\n   * await medplum.executeBatch({\n   *   \"resourceType\": \"Bundle\",\n   *   \"type\": \"transaction\",\n   *   \"entry\": [\n   *     {\n   *       \"fullUrl\": \"urn:uuid:61ebe359-bfdc-4613-8bf2-c5e300945f0a\",\n   *       \"resource\": {\n   *         \"resourceType\": \"Patient\",\n   *         \"name\": [{ \"use\": \"official\", \"given\": [\"Alice\"], \"family\": \"Smith\" }],\n   *         \"gender\": \"female\",\n   *         \"birthDate\": \"1974-12-25\"\n   *       },\n   *       \"request\": {\n   *         \"method\": \"POST\",\n   *         \"url\": \"Patient\"\n   *       }\n   *     },\n   *     {\n   *       \"fullUrl\": \"urn:uuid:88f151c0-a954-468a-88bd-5ae15c08e059\",\n   *       \"resource\": {\n   *         \"resourceType\": \"Patient\",\n   *         \"identifier\": [{ \"system\": \"http:/example.org/fhir/ids\", \"value\": \"234234\" }],\n   *         \"name\": [{ \"use\": \"official\", \"given\": [\"Bob\"], \"family\": \"Jones\" }],\n   *         \"gender\": \"male\",\n   *         \"birthDate\": \"1974-12-25\"\n   *       },\n   *       \"request\": {\n   *         \"method\": \"POST\",\n   *         \"url\": \"Patient\",\n   *         \"ifNoneExist\": \"identifier=http:/example.org/fhir/ids|234234\"\n   *       }\n   *     }\n   *   ]\n   * });\n   * ```\n   *\n   * See The FHIR \"batch/transaction\" section for full details: https://hl7.org/fhir/http.html#transaction\n   * @category Batch\n   * @param bundle - The FHIR batch/transaction bundle.\n   * @param options - Optional fetch options.\n   * @returns The FHIR batch/transaction response bundle.\n   */\n  executeBatch(bundle: Bundle, options?: MedplumRequestOptions): Promise<Bundle> {\n    return this.post(this.fhirBaseUrl, bundle, undefined, options);\n  }\n\n  /**\n   * Sends an email using the Medplum Email API.\n   *\n   * Builds the email using nodemailer MailComposer.\n   *\n   * Examples:\n   *\n   * @example\n   * Send a simple text email:\n   *\n   * ```typescript\n   * await medplum.sendEmail({\n   *   to: 'alice@example.com',\n   *   cc: 'bob@example.com',\n   *   subject: 'Hello',\n   *   text: 'Hello Alice',\n   * });\n   * ```\n   *\n   * @example\n   * Send an email with a `Binary` attachment:\n   *\n   * ```typescript\n   * await medplum.sendEmail({\n   *   to: 'alice@example.com',\n   *   subject: 'Email with attachment',\n   *   text: 'See the attached report',\n   *   attachments: [{\n   *     filename: 'report.pdf',\n   *     path: \"Binary/\" + binary.id\n   *   }]\n   * });\n   * ```\n   *\n   * See options here: https://nodemailer.com/extras/mailcomposer/\n   * @category Media\n   * @param email - The MailComposer options.\n   * @param options - Optional fetch options.\n   * @returns Promise to the operation outcome.\n   */\n  sendEmail(email: MailOptions, options?: MedplumRequestOptions): Promise<OperationOutcome> {\n    return this.post('email/v1/send', email, ContentType.JSON, options);\n  }\n\n  /**\n   * Executes a GraphQL query.\n   *\n   * @example\n   * Example:\n   *\n   * ```typescript\n   * const result = await medplum.graphql(`{\n   *   Patient(id: \"123\") {\n   *     resourceType\n   *     id\n   *     name {\n   *       given\n   *       family\n   *     }\n   *   }\n   * }`);\n   * ```\n   *\n   * @example\n   * Advanced queries such as named operations and variable substitution are supported:\n   *\n   * ```typescript\n   * const result = await medplum.graphql(\n   *   `query GetPatientById($patientId: ID!) {\n   *     Patient(id: $patientId) {\n   *       resourceType\n   *       id\n   *       name {\n   *         given\n   *         family\n   *       }\n   *     }\n   *   }`,\n   *   'GetPatientById',\n   *   { patientId: '123' }\n   * );\n   * ```\n   *\n   * See the GraphQL documentation for more details: https://graphql.org/learn/\n   *\n   * See the FHIR GraphQL documentation for FHIR specific details: https://www.hl7.org/fhir/graphql.html\n   * @category Read\n   * @param query - The GraphQL query.\n   * @param operationName - Optional GraphQL operation name.\n   * @param variables - Optional GraphQL variables.\n   * @param options - Optional fetch options.\n   * @returns The GraphQL result.\n   */\n  graphql(\n    query: string,\n    operationName?: string | null,\n    variables?: any,\n    options?: MedplumRequestOptions\n  ): Promise<any> {\n    return this.post(this.fhirUrl('$graphql'), { query, operationName, variables }, ContentType.JSON, options);\n  }\n\n  /**\n   * Executes the $graph operation on this resource to fetch a Bundle of resources linked to the target resource\n   * according to a graph definition\n   * @category Read\n   * @param resourceType - The FHIR resource type.\n   * @param id - The resource ID.\n   * @param graphName - `name` parameter of the GraphDefinition\n   * @param options - Optional fetch options.\n   * @returns A Bundle\n   */\n  readResourceGraph(\n    resourceType: ResourceType,\n    id: string,\n    graphName: string,\n    options?: MedplumRequestOptions\n  ): ReadablePromise<Bundle> {\n    return this.get<Bundle>(`${this.fhirUrl(resourceType, id)}/$graph?graph=${graphName}`, options);\n  }\n\n  /**\n   * Pushes a message to an agent.\n   *\n   * @param agent - The agent to push to.\n   * @param destination - The destination device.\n   * @param body - The message body.\n   * @param contentType - Optional message content type.\n   * @param waitForResponse - Optional wait for response flag.\n   * @param options - Optional fetch options.\n   * @returns Promise to the result. If waiting for response, the result is the response body. Otherwise, it is an operation outcome.\n   */\n  pushToAgent(\n    agent: Agent | Reference<Agent>,\n    destination: Device | Reference<Device> | string,\n    body: any,\n    contentType?: string,\n    waitForResponse?: boolean,\n    options?: MedplumRequestOptions\n  ): Promise<any> {\n    return this.post(\n      this.fhirUrl('Agent', resolveId(agent) as string, '$push'),\n      {\n        destination: typeof destination === 'string' ? destination : getReferenceString(destination),\n        body,\n        contentType,\n        waitForResponse,\n      },\n      ContentType.FHIR_JSON,\n      options\n    );\n  }\n\n  /**\n   * @category Authentication\n   * @returns The Login State\n   */\n  getActiveLogin(): LoginState | undefined {\n    return this.storage.getObject('activeLogin');\n  }\n\n  /**\n   * Sets the active login.\n   * @param login - The new active login state.\n   * @category Authentication\n   */\n  async setActiveLogin(login: LoginState): Promise<void> {\n    if (!this.sessionDetails?.profile || getReferenceString(this.sessionDetails.profile) !== login.profile?.reference) {\n      this.clearActiveLogin();\n    }\n    this.setAccessToken(login.accessToken, login.refreshToken);\n    this.storage.setObject('activeLogin', login);\n    this.addLogin(login);\n    this.refreshPromise = undefined;\n    await this.refreshProfile();\n  }\n\n  /**\n   * Returns the current access token.\n   * @returns The current access token.\n   * @category Authentication\n   */\n  getAccessToken(): string | undefined {\n    return this.accessToken;\n  }\n\n  /**\n   * Returns whether the client has a valid access token or not.\n   * @param gracePeriod - Optional grace period in milliseconds. If not specified, uses the client configured grace period (default 5 minutes).\n   * @returns Boolean indicating whether or not the client is authenticated.\n   *\n   * **NOTE: Does not check whether the auth token has been revoked server-side.**\n   */\n  isAuthenticated(gracePeriod?: number): boolean {\n    return (\n      this.accessTokenExpires !== undefined &&\n      Date.now() < this.accessTokenExpires - (gracePeriod ?? this.refreshGracePeriod)\n    );\n  }\n\n  /**\n   * Sets the current access token.\n   * @param accessToken - The new access token.\n   * @param refreshToken - Optional refresh token.\n   * @category Authentication\n   */\n  setAccessToken(accessToken: string, refreshToken?: string): void {\n    this.accessToken = accessToken;\n    this.refreshToken = refreshToken;\n    this.accessTokenExpires = tryGetJwtExpiration(accessToken);\n    this.medplumServer = isMedplumAccessToken(accessToken);\n  }\n\n  /**\n   * Returns the list of available logins.\n   * @returns The list of available logins.\n   * @category Authentication\n   */\n  getLogins(): LoginState[] {\n    return this.storage.getObject<LoginState[]>('logins') ?? [];\n  }\n\n  private addLogin(newLogin: LoginState): void {\n    const logins = this.getLogins().filter((login) => login.profile?.reference !== newLogin.profile?.reference);\n    logins.push(newLogin);\n    this.storage.setObject('logins', logins);\n  }\n\n  private async refreshProfile(): Promise<WithId<ProfileResource> | undefined> {\n    if (!this.medplumServer) {\n      return Promise.resolve(undefined);\n    }\n\n    this.profilePromise = new Promise((resolve, reject) => {\n      this.get('auth/me', { cache: 'no-cache' })\n        .then((result: SessionDetails) => {\n          this.profilePromise = undefined;\n          const profileChanged = this.sessionDetails?.profile?.id !== result.profile.id;\n          this.sessionDetails = result;\n          if (profileChanged) {\n            this.dispatchEvent({ type: 'change' });\n          }\n          resolve(result.profile);\n          this.dispatchEvent({ type: 'profileRefreshed' });\n        })\n        .catch(reject);\n    });\n\n    this.dispatchEvent({ type: 'profileRefreshing' });\n    return this.profilePromise;\n  }\n\n  /**\n   * Returns true if the client is waiting for initial authentication.\n   * @returns True if the client is waiting for initial authentication.\n   * @category Authentication\n   */\n  isLoading(): boolean {\n    return !this.isInitialized || (Boolean(this.profilePromise) && !this.sessionDetails?.profile);\n  }\n\n  /**\n   * Returns true if the current user is authenticated as a super admin.\n   * @returns True if the current user is authenticated as a super admin.\n   * @category Authentication\n   */\n  isSuperAdmin(): boolean {\n    return !!this.sessionDetails?.project.superAdmin;\n  }\n\n  /**\n   * Returns true if the current user is authenticated as a project admin.\n   * @returns True if the current user is authenticated as a project admin.\n   * @category Authentication\n   */\n  isProjectAdmin(): boolean {\n    return !!this.sessionDetails?.membership.admin;\n  }\n\n  /**\n   * Returns the current project if available.\n   * @returns The current project if available.\n   * @category User Profile\n   */\n  getProject(): Project | undefined {\n    return this.sessionDetails?.project;\n  }\n\n  /**\n   * Returns the current project membership if available.\n   * @returns The current project membership if available.\n   * @category User Profile\n   */\n  getProjectMembership(): ProjectMembership | undefined {\n    return this.sessionDetails?.membership;\n  }\n\n  /**\n   * Returns the current user profile resource if available.\n   * This method does not wait for loading promises.\n   * @returns The current user profile resource if available.\n   * @category User Profile\n   */\n  getProfile(): ProfileResource | undefined {\n    return this.sessionDetails?.profile;\n  }\n\n  /**\n   * Returns the current user profile resource, retrieving form the server if necessary.\n   * This method waits for loading promises.\n   * @returns The current user profile resource.\n   * @category User Profile\n   */\n  async getProfileAsync(): Promise<WithId<ProfileResource> | undefined> {\n    if (this.profilePromise) {\n      return this.profilePromise;\n    }\n    if (this.sessionDetails) {\n      return this.sessionDetails.profile;\n    }\n    return this.refreshProfile();\n  }\n\n  /**\n   * Returns the current user configuration if available.\n   * @returns The current user configuration if available.\n   * @category User Profile\n   */\n  getUserConfiguration(): WithId<UserConfiguration> | undefined {\n    return this.sessionDetails?.config;\n  }\n\n  /**\n   * Returns the current user access policy if available.\n   * @returns The current user access policy if available.\n   * @category User Profile\n   */\n  getAccessPolicy(): AccessPolicy | undefined {\n    return this.sessionDetails?.accessPolicy;\n  }\n\n  /**\n   * Downloads the URL as a blob. Can accept binary URLs in the form of `Binary/{id}` as well.\n   * @category Read\n   * @param url - The URL to request. Can be a standard URL or one in the form of `Binary/{id}`.\n   * @param options - Optional fetch request init options.\n   * @returns Promise to the response body as a blob.\n   */\n  async download(url: URL | string, options: MedplumRequestOptions = {}): Promise<Blob> {\n    if (this.refreshPromise) {\n      await this.refreshPromise;\n    }\n    const urlString = url.toString();\n    if (urlString.startsWith(BINARY_URL_PREFIX)) {\n      url = this.fhirUrl(urlString);\n    }\n\n    let headers = options.headers as Record<string, string> | undefined;\n    if (!headers) {\n      headers = {};\n      options.headers = headers;\n    }\n\n    if (!headers['Accept']) {\n      headers['Accept'] = '*/*';\n    }\n\n    this.addFetchOptionsDefaults(options);\n    const response = await this.fetchWithRetry(url.toString(), options);\n    return response.blob();\n  }\n\n  /**\n   * Creates a FHIR Media resource with the provided data content.\n   *\n   * @category Create\n   * @param createMediaOptions - The media creation options. See `CreateMediaOptions` for full details.\n   * @param requestOptions - Optional fetch options.\n   * @returns The new media resource.\n   */\n  async createMedia(createMediaOptions: CreateMediaOptions, requestOptions?: MedplumRequestOptions): Promise<Media> {\n    const { additionalFields, ...createBinaryOptions } = createMediaOptions;\n\n    // First, create the media:\n    const media = await this.createResource({\n      resourceType: 'Media',\n      status: 'preparation',\n      content: {\n        contentType: createMediaOptions.contentType,\n      },\n      ...additionalFields,\n    });\n\n    // If the caller did not specify a security context, use the media reference:\n    if (!createBinaryOptions.securityContext) {\n      createBinaryOptions.securityContext = createReference(media);\n    }\n\n    // Next, upload the binary:\n    const content = await this.createAttachment(createBinaryOptions, requestOptions);\n\n    // Update the media with the binary content:\n    return this.updateResource({\n      ...media,\n      status: 'completed',\n      content,\n    });\n  }\n\n  /**\n   * Upload media to the server and create a Media instance for the uploaded content.\n   * @param contents - The contents of the media file, as a string, Uint8Array, File, or Blob.\n   * @param contentType - The media type of the content.\n   * @param filename - Optional filename for the binary, or extended upload options (see `BinaryUploadOptions`).\n   * @param additionalFields - Additional fields for Media.\n   * @param options - Optional fetch options.\n   * @returns Promise that resolves to the created Media\n   * @deprecated Use `createMedia` with `CreateMediaOptions` instead. To be removed in a future version.\n   */\n  async uploadMedia(\n    contents: string | Uint8Array | File | Blob,\n    contentType: string,\n    filename: string | undefined,\n    additionalFields?: Partial<Media>,\n    options?: MedplumRequestOptions\n  ): Promise<Media> {\n    return this.createMedia(\n      {\n        data: contents,\n        contentType,\n        filename,\n        additionalFields,\n      },\n      options\n    );\n  }\n\n  /**\n   * Creates a FHIR DocumentReference resource with the provided data content.\n   *\n   * @category Create\n   * @param createDocumentReferenceOptions - The document reference creation options. See `CreateDocumentReferenceOptions` for full details.\n   * @param requestOptions - Optional fetch options.\n   * @returns The new document reference resource.\n   */\n  async createDocumentReference(\n    createDocumentReferenceOptions: CreateDocumentReferenceOptions,\n    requestOptions?: MedplumRequestOptions\n  ): Promise<DocumentReference> {\n    const { additionalFields, ...createBinaryOptions } = createDocumentReferenceOptions;\n\n    // First, create the document reference:\n    const documentReference = await this.createResource({\n      resourceType: 'DocumentReference',\n      status: 'current',\n      content: [\n        {\n          attachment: {\n            contentType: createDocumentReferenceOptions.contentType,\n          },\n        },\n      ],\n      ...additionalFields,\n    });\n\n    // If the caller did not specify a security context, use the document reference:\n    if (!createBinaryOptions.securityContext) {\n      createBinaryOptions.securityContext = createReference(documentReference);\n    }\n\n    // Then create the binary:\n    const attachment = await this.createAttachment(createBinaryOptions, requestOptions);\n\n    // Finally, update the document reference with the binary reference:\n    return this.updateResource({\n      ...documentReference,\n      content: [{ attachment: attachment }],\n    });\n  }\n\n  /**\n   * Performs Bulk Data Export operation request flow. See The FHIR \"Bulk Data Export\" for full details: https://build.fhir.org/ig/HL7/bulk-data/export.html#bulk-data-export\n   * @param exportLevel - Optional export level. Defaults to system level export. 'Group/:id' - Group of Patients, 'Patient' - All Patients.\n   * @param resourceTypes - A string of comma-delimited FHIR resource types.\n   * @param since - Resources will be included in the response if their state has changed after the supplied time (e.g. if Resource.meta.lastUpdated is later than the supplied _since time).\n   * @param options - Optional fetch options.\n   * @returns Bulk Data Response containing links to Bulk Data files. See \"Response - Complete Status\" for full details: https://build.fhir.org/ig/HL7/bulk-data/export.html#response---complete-status\n   */\n  async bulkExport(\n    //eslint-disable-next-line default-param-last\n    exportLevel = '',\n    resourceTypes?: string,\n    since?: string,\n    options?: MedplumRequestOptions\n  ): Promise<Partial<BulkDataExport>> {\n    const fhirPath = exportLevel ? `${exportLevel}/` : exportLevel;\n    const url = this.fhirUrl(`${fhirPath}$export`);\n\n    if (resourceTypes) {\n      url.searchParams.set('_type', resourceTypes);\n    }\n    if (since) {\n      url.searchParams.set('_since', since);\n    }\n\n    return this.startAsyncRequest<Partial<BulkDataExport>>(url.toString(), options);\n  }\n\n  /**\n   * Starts an async request following the FHIR \"Asynchronous Request Pattern\".\n   * See: https://hl7.org/fhir/r4/async.html\n   * @param url - The URL to request.\n   * @param options - Optional fetch options.\n   * @returns The response body.\n   */\n  async startAsyncRequest<T>(url: string, options: MedplumRequestOptions = {}): Promise<T> {\n    this.addFetchOptionsDefaults(options);\n\n    const headers = options.headers as Record<string, string>;\n    headers['Prefer'] = 'respond-async';\n\n    return this.request('POST', url, options);\n  }\n\n  /**\n   * Returns the key value client.\n   * @returns The key value client.\n   */\n  get keyValue(): MedplumKeyValueClient {\n    if (!this.keyValueClient) {\n      this.keyValueClient = new MedplumKeyValueClient(this);\n    }\n    return this.keyValueClient;\n  }\n\n  //\n  // Private helpers\n  //\n\n  /**\n   * Internal helper method to get a bundle from a URL.\n   * In addition to returning the bundle, it also caches all of the resources in the bundle.\n   * This should be used by any method that returns a bundle of resources to be cached.\n   * @param url - The bundle URL.\n   * @param options - Optional fetch options.\n   * @returns Promise to the bundle.\n   */\n  private getBundle<T extends Resource = Resource>(\n    url: URL,\n    options?: MedplumRequestOptions\n  ): ReadablePromise<Bundle<T>> {\n    return new ReadablePromise(\n      (async () => {\n        const bundle = await this.get<Bundle<T>>(url, options);\n        if (bundle.entry) {\n          for (const entry of bundle.entry) {\n            this.cacheResource(entry.resource);\n          }\n        }\n        return bundle;\n      })()\n    );\n  }\n\n  /**\n   * Returns the cache entry if available and not expired.\n   * @param key - The cache key to retrieve.\n   * @param options - Optional fetch options for cache settings.\n   * @returns The cached entry if found.\n   */\n  private getCacheEntry(key: string, options: MedplumRequestOptions | undefined): RequestCacheEntry | undefined {\n    if (!this.requestCache || options?.cache === 'no-cache' || options?.cache === 'reload') {\n      return undefined;\n    }\n    const entry = this.requestCache.get(key);\n    if (!entry || entry.requestTime + this.cacheTime < Date.now()) {\n      return undefined;\n    }\n    return entry;\n  }\n\n  /**\n   * Adds a readable promise to the cache.\n   * @param key - The cache key to store.\n   * @param value - The readable promise to store.\n   */\n  private setCacheEntry(key: string, value: ReadablePromise<any>): void {\n    if (this.requestCache) {\n      this.requestCache.set(key, { requestTime: Date.now(), value });\n    }\n  }\n\n  /**\n   * Adds a concrete value as the cache entry for the given resource.\n   * This is used in cases where the resource is loaded indirectly.\n   * For example, when a resource is loaded as part of a Bundle.\n   * @param resource - The resource to cache.\n   */\n  private cacheResource(resource: Resource | undefined): void {\n    if (resource?.id && !resource.meta?.tag?.some((t) => t.code === 'SUBSETTED')) {\n      this.setCacheEntry(\n        this.fhirUrl(resource.resourceType, resource.id).toString(),\n        new ReadablePromise(Promise.resolve(resource))\n      );\n    }\n  }\n\n  /**\n   * Deletes a cache entry.\n   * @param key - The cache key to delete.\n   */\n  private deleteCacheEntry(key: string): void {\n    if (this.requestCache) {\n      this.requestCache.delete(key);\n    }\n  }\n\n  /**\n   * Makes an HTTP request.\n   * @param method - The HTTP method (GET, POST, etc).\n   * @param url - The target URL.\n   * @param options - Optional fetch request init options.\n   * @param state - Optional request state.\n   * @returns The JSON content body if available.\n   */\n  private async request<T>(\n    method: string,\n    url: string,\n    options: MedplumRequestOptions = {},\n    state: RequestState = {}\n  ): Promise<T> {\n    await this.refreshIfExpired();\n\n    options.method = method;\n    this.addFetchOptionsDefaults(options);\n\n    const response = await this.fetchWithRetry(url, options);\n\n    if (response.status === 401) {\n      // Refresh and try again\n      return this.handleUnauthenticated(method, url, options);\n    }\n\n    if (response.status === 204 || response.status === 304) {\n      // No content or change\n      return undefined as unknown as T;\n    }\n\n    const contentType = response.headers.get('content-type');\n    const isJson = contentType?.includes('json');\n\n    if (response.status === 404 && !isJson) {\n      // Special case for non-JSON 404 responses\n      // In the common case, the 404 response will include an OperationOutcome in JSON with additional details.\n      // In the non-JSON case, we can't parse the response, so we'll just throw a generic \"Not Found\" error.\n      throw new OperationOutcomeError(notFound);\n    }\n\n    const body = await this.parseBody(response, isJson);\n\n    if (\n      (response.status === 200 && options.followRedirectOnOk) ||\n      (response.status === 201 && options.followRedirectOnCreated)\n    ) {\n      const contentLocation = await tryGetContentLocation(response, body);\n      if (contentLocation) {\n        return this.request('GET', contentLocation, { ...options, body: undefined });\n      }\n    }\n\n    if (response.status === 202 && options.pollStatusOnAccepted) {\n      const contentLocation = await tryGetContentLocation(response, body);\n      const statusUrl = contentLocation ?? state.statusUrl;\n      if (statusUrl) {\n        return this.pollStatus(statusUrl, options, state);\n      }\n    }\n\n    if (response.status >= 400) {\n      throw new OperationOutcomeError(normalizeOperationOutcome(body));\n    }\n\n    return body as T;\n  }\n\n  private async parseBody(\n    response: Response,\n    isJson: boolean | undefined\n  ): Promise<Record<string, any> | string | undefined> {\n    let body: Record<string, string> | string | undefined = undefined;\n    // If there is no content length, don't attempt to parse the body\n    if (response.headers.get('content-length') === '0') {\n      return undefined;\n    }\n    if (isJson) {\n      try {\n        body = await response.json();\n      } catch (err) {\n        console.error('Error parsing response', response.status, err);\n        throw err;\n      }\n    } else {\n      body = await response.text();\n    }\n    return body;\n  }\n\n  private async fetchWithRetry(url: string, options: MedplumRequestOptions): Promise<Response> {\n    if (!url.startsWith('http')) {\n      url = concatUrls(this.baseUrl, url);\n    }\n\n    // Previously default for maxRetries was 3, but we will interpret maxRetries literally and not count first attempt\n    // Default of 2 matches old behavior with the new semantics\n    const maxRetries = options?.maxRetries ?? 2;\n\n    // We use <= since we want to retry maxRetries times and first retry is when attemptNum === 1\n    for (let attemptNum = 0; attemptNum <= maxRetries; attemptNum++) {\n      try {\n        if (this.options.verbose) {\n          this.logRequest(url, options);\n        }\n        const response = (await this.fetch(url, options)) as Response;\n        if (this.options.verbose) {\n          this.logResponse(response);\n        }\n\n        // Ensure current rate limits are set before calculating retry delay\n        this.setCurrentRateLimit(response);\n\n        // Handle non-500 response and max retries exceeded\n        // We return immediately for non-500 or 500 that has exceeded max retries\n        if (attemptNum >= maxRetries || !isRetryable(response)) {\n          return response;\n        }\n\n        const delayMs = this.getRetryDelay(attemptNum);\n        const maxRetryTime = options.maxRetryTime ?? 2_000;\n        // Return to user immediately if delay would be very long\n        if (delayMs > maxRetryTime) {\n          return response;\n        }\n        await sleep(delayMs);\n      } catch (err) {\n        // This is for the 1st retry to avoid multiple notifications\n        if ((err as Error).message === 'Failed to fetch' && attemptNum === 0) {\n          this.dispatchEvent({ type: 'offline' });\n        }\n\n        // If we got an abort error or exceeded retries, then throw immediately\n        if ((err as Error).name === 'AbortError' || attemptNum === maxRetries) {\n          throw err;\n        }\n      }\n    }\n\n    throw new Error('Unreachable');\n  }\n\n  private logRequest(url: string, options: MedplumRequestOptions): void {\n    console.log(`> ${options.method} ${url}`);\n    if (options.headers) {\n      const headers = options.headers as Record<string, string>;\n      for (const key of sortStringArray(Object.keys(headers))) {\n        console.log(`> ${key}: ${headers[key]}`);\n      }\n    }\n  }\n\n  private logResponse(response: Response): void {\n    console.log(`< ${response.status} ${response.statusText}`);\n    if (response.headers) {\n      response.headers.forEach((value, key) => console.log(`< ${key}: ${value}`));\n    }\n  }\n\n  private setCurrentRateLimit(res: Response): void {\n    const rateLimitHeader = res.headers?.get('ratelimit');\n    if (rateLimitHeader) {\n      this.currentRateLimits = rateLimitHeader;\n    }\n  }\n\n  /**\n   * Reports the last-seen rate limit information from the server.\n   * @returns Array of applicable rate limits.\n   */\n  rateLimitStatus(): RateLimitInfo[] {\n    if (!this.currentRateLimits) {\n      return [];\n    }\n    const header = this.currentRateLimits;\n    return header.split(/\\s*;\\s*/g).map((str) => {\n      const parts = str.split(/\\s*,\\s*/g);\n      if (parts.length !== 3) {\n        throw new Error('Could not parse RateLimit header: ' + header);\n      }\n\n      const name = parts[0].substring(1, parts[0].length - 1);\n      const remainingPart = parts.find((p) => p.startsWith('r='));\n      const remainingUnits = remainingPart ? parseInt(remainingPart.substring(2), 10) : NaN;\n      const timePart = parts.find((p) => p.startsWith('t='));\n      const secondsUntilReset = timePart ? parseInt(timePart.substring(2), 10) : NaN;\n      if (!name || Number.isNaN(remainingUnits) || Number.isNaN(secondsUntilReset)) {\n        throw new Error('Could not parse RateLimit header: ' + header);\n      }\n\n      return { name, remainingUnits, secondsUntilReset };\n    });\n  }\n\n  private getRetryDelay(attemptNum: number): number {\n    const rateLimits = this.rateLimitStatus();\n    let retryDelay = 500 * Math.pow(1.5, attemptNum);\n    for (const limit of rateLimits) {\n      if (!limit.remainingUnits) {\n        retryDelay = Math.max(retryDelay, limit.secondsUntilReset * 1000);\n      }\n    }\n    return retryDelay;\n  }\n\n  private async pollStatus<T>(statusUrl: string, options: MedplumRequestOptions, state: RequestState): Promise<T> {\n    const statusOptions: MedplumRequestOptions = { ...options, method: 'GET', body: undefined, redirect: 'follow' };\n    if (state.pollCount === undefined) {\n      // First request - try request immediately\n      if (options.headers && typeof options.headers === 'object' && 'Prefer' in options.headers) {\n        statusOptions.headers = { ...options.headers };\n        delete statusOptions.headers.Prefer;\n      }\n      state.statusUrl = statusUrl;\n      state.pollCount = 1;\n    } else {\n      // Subsequent requests - wait and retry\n      const retryDelay = options.pollStatusPeriod ?? 1000;\n      await sleep(retryDelay);\n      state.pollCount++;\n    }\n    return this.request('GET', statusUrl, statusOptions, state);\n  }\n\n  /**\n   * Executes a batch of requests that were automatically batched together.\n   */\n  private async executeAutoBatch(): Promise<void> {\n    // Get the current queue\n    if (this.autoBatchQueue === undefined) {\n      return;\n    }\n\n    const entries = [...this.autoBatchQueue];\n\n    // Clear the queue\n    this.autoBatchQueue.length = 0;\n\n    // Clear the timer\n    this.autoBatchTimerId = undefined;\n\n    // If there is only one request in the batch, just execute it\n    if (entries.length === 1) {\n      const entry = entries[0];\n      try {\n        entry.resolve(await this.request(entry.method, concatUrls(this.fhirBaseUrl, entry.url), entry.options));\n      } catch (err) {\n        entry.reject(new OperationOutcomeError(normalizeOperationOutcome(err)));\n      }\n      return;\n    }\n\n    // Build the batch request\n    const batch: Bundle = {\n      resourceType: 'Bundle',\n      type: 'batch',\n      entry: entries.map(\n        (e): BundleEntry => ({\n          request: {\n            method: e.method,\n            url: e.url,\n          },\n          resource: e.options.body ? (JSON.parse(e.options.body as string) as Resource) : undefined,\n        })\n      ),\n    };\n\n    // Execute the batch request\n    const response = (await this.post(this.fhirBaseUrl, batch)) as Bundle;\n\n    // Process the response\n    for (let i = 0; i < entries.length; i++) {\n      const entry = entries[i];\n      const responseEntry = response.entry?.[i];\n      if (responseEntry?.response?.outcome && !isOk(responseEntry.response.outcome)) {\n        entry.reject(new OperationOutcomeError(responseEntry.response.outcome));\n      } else {\n        entry.resolve(responseEntry?.resource);\n      }\n    }\n  }\n\n  /**\n   * Adds default options to the fetch options.\n   * @param options - The options to add defaults to.\n   */\n  private addFetchOptionsDefaults(options: MedplumRequestOptions): void {\n    // Apply default headers\n    Object.entries(this.defaultHeaders).forEach(([name, value]) => {\n      this.setRequestHeader(options, name, value);\n    });\n\n    this.setRequestHeader(options, 'Accept', DEFAULT_ACCEPT, true);\n\n    if (this.options.extendedMode !== false) {\n      this.setRequestHeader(options, 'X-Medplum', 'extended');\n    }\n\n    if (options.body) {\n      this.setRequestHeader(options, 'Content-Type', ContentType.FHIR_JSON, true);\n    }\n\n    if (this.accessToken) {\n      this.setRequestHeader(options, 'Authorization', 'Bearer ' + this.accessToken);\n    } else if (this.basicAuth) {\n      this.setRequestHeader(options, 'Authorization', 'Basic ' + this.basicAuth);\n    }\n\n    if (!options.cache) {\n      options.cache = 'no-cache';\n    }\n\n    if (!options.credentials) {\n      options.credentials = 'include';\n    }\n  }\n\n  /**\n   * Sets the \"Content-Type\" header on fetch options.\n   * @param options - The fetch options.\n   * @param contentType - The new content type to set.\n   */\n  private setRequestContentType(options: MedplumRequestOptions, contentType: string): void {\n    this.setRequestHeader(options, 'Content-Type', contentType);\n  }\n\n  /**\n   * Sets a header on fetch options.\n   * @param options - The fetch options.\n   * @param key - The header key.\n   * @param value - The header value.\n   * @param ifNoneExist - Optional flag to only set the header if it doesn't already exist.\n   */\n  private setRequestHeader(options: MedplumRequestOptions, key: string, value: string, ifNoneExist = false): void {\n    if (!options.headers) {\n      options.headers = {};\n    }\n    const headers = options.headers as Record<string, string>;\n    if (ifNoneExist && headers[key]) {\n      return;\n    }\n    headers[key] = value;\n  }\n\n  /**\n   * Sets the body on fetch options.\n   * @param options - The fetch options.\n   * @param data - The new content body.\n   */\n  private setRequestBody(options: MedplumRequestOptions, data: any): void {\n    if (\n      typeof data === 'string' ||\n      (typeof Blob !== 'undefined' && (data instanceof Blob || data?.constructor.name === 'Blob')) ||\n      (typeof File !== 'undefined' && (data instanceof File || data?.constructor.name === 'File')) ||\n      (typeof Uint8Array !== 'undefined' && (data instanceof Uint8Array || data?.constructor.name === 'Uint8Array'))\n    ) {\n      options.body = data;\n    } else if (data) {\n      options.body = JSON.stringify(data);\n    }\n  }\n\n  /**\n   * Handles an unauthenticated response from the server.\n   * First, tries to refresh the access token and retry the request.\n   * Otherwise, calls unauthenticated callbacks and rejects.\n   * @param method - The HTTP method of the original request.\n   * @param url - The URL of the original request.\n   * @param options - Optional fetch request init options.\n   * @returns The result of the retry.\n   */\n  private handleUnauthenticated(method: string, url: string, options: MedplumRequestOptions): Promise<any> {\n    if (this.refresh()) {\n      return this.request(method, url, options);\n    }\n    this.clear();\n    if (this.onUnauthenticated) {\n      this.onUnauthenticated();\n    }\n    return Promise.reject(new OperationOutcomeError(unauthorized));\n  }\n\n  /**\n   * Starts a new PKCE flow.\n   * These PKCE values are stateful, and must survive redirects and page refreshes.\n   * @category Authentication\n   * @returns The PKCE code challenge details.\n   */\n  async startPkce(): Promise<{ codeChallengeMethod: CodeChallengeMethod; codeChallenge: string }> {\n    const pkceState = getRandomString();\n    sessionStorage.setItem('pkceState', pkceState);\n\n    const codeVerifier = getRandomString().slice(0, 128);\n    sessionStorage.setItem('codeVerifier', codeVerifier);\n\n    const arrayHash = await encryptSHA256(codeVerifier);\n    const codeChallenge = arrayBufferToBase64(arrayHash).replaceAll('+', '-').replaceAll('/', '_').replaceAll('=', '');\n    sessionStorage.setItem('codeChallenge', codeChallenge);\n\n    return { codeChallengeMethod: 'S256', codeChallenge };\n  }\n\n  /**\n   * Redirects the user to the login screen for authorization.\n   * Clears all auth state including local storage and session storage.\n   * @param loginParams - The authorization login parameters.\n   * @see https://openid.net/specs/openid-connect-core-1_0.html#AuthorizationEndpoint\n   */\n  private async requestAuthorization(loginParams?: Partial<BaseLoginRequest>): Promise<void> {\n    const loginRequest = await this.ensureCodeChallenge(loginParams ?? {});\n    const url = new URL(this.authorizeUrl);\n    url.searchParams.set('response_type', 'code');\n    url.searchParams.set('state', sessionStorage.getItem('pkceState') as string);\n    url.searchParams.set('client_id', loginRequest.clientId ?? (this.clientId as string));\n    url.searchParams.set('redirect_uri', loginRequest.redirectUri ?? getWindowOrigin());\n    url.searchParams.set('code_challenge_method', loginRequest.codeChallengeMethod as string);\n    url.searchParams.set('code_challenge', loginRequest.codeChallenge as string);\n    url.searchParams.set('scope', loginRequest.scope ?? 'openid profile');\n    window.location.assign(url.toString());\n  }\n\n  /**\n   * Processes an OAuth authorization code.\n   * See: https://openid.net/specs/openid-connect-core-1_0.html#TokenRequest\n   * @param code - The authorization code received by URL parameter.\n   * @param loginParams - Optional login parameters.\n   * @returns The user profile resource.\n   * @category Authentication\n   */\n  processCode(code: string, loginParams?: Partial<BaseLoginRequest>): Promise<ProfileResource> {\n    const tokenParams: Record<string, string> = {\n      grant_type: OAuthGrantType.AuthorizationCode,\n      code,\n      client_id: loginParams?.clientId ?? this.clientId ?? '',\n      redirect_uri: loginParams?.redirectUri ?? getWindowOrigin(),\n    };\n\n    if (typeof sessionStorage !== 'undefined') {\n      const codeVerifier = sessionStorage.getItem('codeVerifier');\n      if (codeVerifier) {\n        tokenParams.code_verifier = codeVerifier;\n      }\n    }\n\n    return this.fetchTokens(tokenParams);\n  }\n\n  /**\n   * Refreshes the access token using the refresh token if available.\n   * @param gracePeriod - Optional grace period in milliseconds. If not specified, uses the client configured grace period (default 5 minutes).\n   * @returns Promise to refresh the access token.\n   */\n  refreshIfExpired(gracePeriod?: number): Promise<void> {\n    // If (1) not already refreshing, (2) we have an access token, and (3) the access token is expired,\n    // then start a refresh.\n    if (!this.refreshPromise && this.accessTokenExpires !== undefined && !this.isAuthenticated(gracePeriod)) {\n      // The result of the `refresh()` function is cached in `this.refreshPromise`,\n      // so we can safely ignore the return value here.\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this.refresh();\n    }\n    return this.refreshPromise ?? Promise.resolve();\n  }\n\n  /**\n   * Tries to refresh the auth tokens.\n   * @returns The refresh promise if available; otherwise undefined.\n   * @see https://openid.net/specs/openid-connect-core-1_0.html#RefreshTokens\n   */\n  private refresh(): Promise<void> | undefined {\n    if (this.refreshPromise) {\n      return this.refreshPromise;\n    }\n\n    if (this.refreshToken) {\n      this.refreshPromise = this.fetchTokens({\n        grant_type: OAuthGrantType.RefreshToken,\n        client_id: this.clientId ?? '',\n        refresh_token: this.refreshToken,\n      });\n      return this.refreshPromise;\n    }\n\n    if (this.clientId && this.clientSecret) {\n      this.refreshPromise = this.startClientLogin(this.clientId, this.clientSecret);\n      return this.refreshPromise;\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Starts a new OAuth2 client credentials flow.\n   *\n   * @example\n   * ```typescript\n   * await medplum.startClientLogin(import.meta.env.MEDPLUM_CLIENT_ID, import.meta.env.MEDPLUM_CLIENT_SECRET)\n   * // Example Search\n   * await medplum.searchResources('Patient')\n   * ```\n   *\n   * See: https://datatracker.ietf.org/doc/html/rfc6749#section-4.4\n   *\n   * @category Authentication\n   * @param clientId - The client ID.\n   * @param clientSecret - The client secret.\n   * @returns Promise that resolves to the client profile.\n   */\n  async startClientLogin(clientId: string, clientSecret: string): Promise<ProfileResource> {\n    this.clientId = clientId;\n    this.clientSecret = clientSecret;\n\n    return this.fetchTokens({\n      grant_type: OAuthGrantType.ClientCredentials,\n      client_id: clientId,\n      client_secret: clientSecret,\n    });\n  }\n\n  /**\n   * Starts a new OAuth2 JWT bearer flow.\n   *\n   * @example\n   * ```typescript\n   * await medplum.startJwtBearerLogin(import.meta.env.MEDPLUM_CLIENT_ID, import.meta.env.MEDPLUM_JWT_BEARER_ASSERTION, 'openid profile');\n   * // Example Search\n   * await medplum.searchResources('Patient')\n   * ```\n   *\n   * See: https://datatracker.ietf.org/doc/html/rfc7523#section-2.1\n   *\n   * @category Authentication\n   * @param clientId - The client ID.\n   * @param assertion - The JWT assertion.\n   * @param scope - The OAuth scope.\n   * @returns Promise that resolves to the client profile.\n   */\n  async startJwtBearerLogin(clientId: string, assertion: string, scope: string): Promise<ProfileResource> {\n    this.clientId = clientId;\n\n    return this.fetchTokens({\n      grant_type: OAuthGrantType.JwtBearer,\n      client_id: clientId,\n      assertion,\n      scope,\n    });\n  }\n\n  /**\n   * Starts a new OAuth2 JWT assertion flow.\n   *\n   * See: https://datatracker.ietf.org/doc/html/rfc7523#section-2.2\n   *\n   * @category Authentication\n   * @param jwt - The JWT assertion.\n   * @returns Promise that resolves to the client profile.\n   */\n  async startJwtAssertionLogin(jwt: string): Promise<ProfileResource> {\n    return this.fetchTokens({\n      grant_type: OAuthGrantType.ClientCredentials,\n      client_assertion_type: OAuthClientAssertionType.JwtBearer,\n      client_assertion: jwt,\n    });\n  }\n\n  /**\n   * Sets the client ID and secret for basic auth.\n   *\n   * @example\n   * ```typescript\n   * medplum.setBasicAuth(import.meta.env.MEDPLUM_CLIENT_ID, import.meta.env.MEDPLUM_CLIENT_SECRET);\n   * // Example Search\n   * await medplum.searchResources('Patient');\n   * ```\n   *\n   * @category Authentication\n   * @param clientId - The client ID.\n   * @param clientSecret - The client secret.\n   */\n  setBasicAuth(clientId: string, clientSecret: string): void {\n    this.clientId = clientId;\n    this.clientSecret = clientSecret;\n    this.basicAuth = encodeBase64(clientId + ':' + clientSecret);\n  }\n\n  /**\n   * Subscribes to a specified topic, listening for a list of specified events.\n   *\n   * Once you have the `SubscriptionRequest` returned from this method, you can call `fhircastConnect(subscriptionRequest)` to connect to the subscription stream.\n   *\n   * @category FHIRcast\n   * @param topic - The topic to publish to. Usually a UUID.\n   * @param events - An array of event names to listen for.\n   * @returns A `Promise` that resolves once the request completes, or rejects if it fails.\n   */\n  async fhircastSubscribe(topic: string, events: FhircastEventName[]): Promise<SubscriptionRequest> {\n    if (!(typeof topic === 'string' && topic !== '')) {\n      throw new OperationOutcomeError(validationError('Invalid topic provided. Topic must be a valid string.'));\n    }\n    if (!(typeof events === 'object' && Array.isArray(events) && events.length > 0)) {\n      throw new OperationOutcomeError(\n        validationError(\n          'Invalid events provided. Events must be an array of event names containing at least one event.'\n        )\n      );\n    }\n\n    const subRequest = {\n      channelType: 'websocket',\n      mode: 'subscribe',\n      topic,\n      events,\n    } as PendingSubscriptionRequest;\n\n    const body = (await this.post(\n      this.fhircastHubUrl,\n      serializeFhircastSubscriptionRequest(subRequest),\n      ContentType.FORM_URL_ENCODED\n    )) as { 'hub.channel.endpoint': string };\n\n    const endpoint = body['hub.channel.endpoint'];\n    if (!endpoint) {\n      throw new Error('Invalid response!');\n    }\n\n    // Add endpoint to subscription request before returning\n    (subRequest as SubscriptionRequest).endpoint = endpoint;\n    return subRequest as SubscriptionRequest;\n  }\n\n  /**\n   * Unsubscribes from the specified topic.\n   *\n   * @category FHIRcast\n   * @param subRequest - A `SubscriptionRequest` representing a subscription to cancel. Mode will be set to `unsubscribe` automatically.\n   * @returns A `Promise` that resolves when request to unsubscribe is completed.\n   */\n  async fhircastUnsubscribe(subRequest: SubscriptionRequest): Promise<void> {\n    if (!validateFhircastSubscriptionRequest(subRequest)) {\n      throw new OperationOutcomeError(\n        validationError('Invalid topic or subscriptionRequest. SubscriptionRequest must be an object.')\n      );\n    }\n    if (!(subRequest.endpoint && typeof subRequest.endpoint === 'string' && subRequest.endpoint.startsWith('ws'))) {\n      throw new OperationOutcomeError(\n        validationError('Provided subscription request must have an endpoint in order to unsubscribe.')\n      );\n    }\n\n    // Turn subRequest -> unsubRequest\n    subRequest.mode = 'unsubscribe';\n    // Send unsub request\n    await this.post(\n      this.fhircastHubUrl,\n      serializeFhircastSubscriptionRequest(subRequest),\n      ContentType.FORM_URL_ENCODED\n    );\n  }\n\n  /**\n   * Connects to a `FHIRcast` session.\n   *\n   * @category FHIRcast\n   * @param subRequest - The `SubscriptionRequest` to use for connecting.\n   * @returns A `FhircastConnection` which emits lifecycle events for the `FHIRcast` WebSocket connection.\n   */\n  fhircastConnect(subRequest: SubscriptionRequest): FhircastConnection {\n    return new FhircastConnection(subRequest);\n  }\n\n  /**\n   * Publishes a new context to a given topic for a specified event type.\n   *\n   * @category FHIRcast\n   * @param topic - The topic to publish to. Usually a UUID.\n   * @param event - The name of the event to publish an updated context for, ie. `Patient-open`.\n   * @param context - The updated context containing resources relevant to this event.\n   * @param versionId - The `versionId` of the `anchor context` of the given event. Used for `DiagnosticReport-update` event.\n   * @returns A `Promise` that resolves once the request completes, or rejects if it fails.\n   */\n  async fhircastPublish<EventName extends FhircastEventVersionOptional>(\n    topic: string,\n    event: EventName,\n    context: FhircastEventContext<EventName> | FhircastEventContext<EventName>[],\n    versionId?: never\n  ): Promise<Record<string, any>>;\n\n  async fhircastPublish<RequiredVersionEvent extends FhircastEventVersionRequired>(\n    topic: string,\n    event: RequiredVersionEvent,\n    context: FhircastEventContext<RequiredVersionEvent> | FhircastEventContext<RequiredVersionEvent>[],\n    versionId: string\n  ): Promise<Record<string, any>>;\n\n  async fhircastPublish<EventName extends FhircastEventVersionRequired | FhircastEventVersionOptional>(\n    topic: string,\n    event: EventName,\n    context: FhircastEventContext<EventName> | FhircastEventContext<EventName>[],\n    versionId?: string\n  ): Promise<Record<string, any>> {\n    if (isContextVersionRequired(event)) {\n      return this.post(\n        this.fhircastHubUrl,\n        createFhircastMessagePayload<typeof event>(topic, event, context, versionId as string),\n        ContentType.JSON\n      );\n    }\n    assertContextVersionOptional(event);\n    return this.post(\n      this.fhircastHubUrl,\n      createFhircastMessagePayload<typeof event>(topic, event, context),\n      ContentType.JSON\n    );\n  }\n\n  /**\n   * Gets the current context of the given FHIRcast `topic`.\n   *\n   * @category FHIRcast\n   * @param topic - The topic to get the current context for. Usually a UUID.\n   * @returns A Promise which resolves to the `CurrentContext` for the given topic.\n   */\n  async fhircastGetContext(topic: string): Promise<CurrentContext> {\n    return this.get(`${this.fhircastHubUrl}/${topic}`, { cache: 'no-cache' });\n  }\n\n  /**\n   * Invite a user to a project.\n   * @param projectId - The project ID.\n   * @param body - The InviteRequest.\n   * @returns Promise that returns a project membership or an operation outcome.\n   */\n  async invite(projectId: string, body: InviteRequest): Promise<ProjectMembership | OperationOutcome> {\n    return this.post('admin/projects/' + projectId + '/invite', body);\n  }\n\n  /**\n   * Makes a POST request to the tokens endpoint.\n   * See: https://openid.net/specs/openid-connect-core-1_0.html#TokenEndpoint\n   * @param params - Token parameters.\n   * @returns The user profile resource.\n   */\n  private async fetchTokens(params: Record<string, string>): Promise<ProfileResource> {\n    const formBody = new URLSearchParams(params);\n    const headers: HeadersInit = { ...this.defaultHeaders, 'Content-Type': ContentType.FORM_URL_ENCODED };\n    if (this.basicAuth) {\n      headers['Authorization'] = `Basic ${this.basicAuth}`;\n    }\n\n    if (this.credentialsInHeader) {\n      formBody.delete('client_id');\n      formBody.delete('client_secret');\n\n      if (!this.basicAuth && params.client_id && params.client_secret) {\n        headers['Authorization'] = `Basic ${encodeBase64(params.client_id + ':' + params.client_secret)}`;\n      }\n    }\n    const options: MedplumRequestOptions = {\n      method: 'POST',\n      headers,\n      body: formBody.toString(),\n      credentials: 'include',\n    };\n\n    let response: Response;\n    try {\n      response = await this.fetchWithRetry(this.tokenUrl, options);\n    } catch (err) {\n      this.refreshPromise = undefined;\n      throw err;\n    }\n\n    if (!response.ok) {\n      this.clearActiveLogin();\n      try {\n        const error = await response.json();\n        throw new OperationOutcomeError(badRequest(error.error_description));\n      } catch (err) {\n        throw new OperationOutcomeError(badRequest('Failed to fetch tokens'), err);\n      }\n    }\n    const tokens = await response.json();\n    await this.verifyTokens(tokens);\n    return this.getProfile() as ProfileResource;\n  }\n\n  /**\n   * Verifies the tokens received from the auth server.\n   * Validates the JWT against the JWKS.\n   * See: https://openid.net/specs/openid-connect-core-1_0.html#TokenEndpoint\n   * @param tokens - The token response.\n   * @returns Promise to complete.\n   */\n  private async verifyTokens(tokens: TokenResponse): Promise<void> {\n    const token = tokens.access_token;\n\n    if (isJwt(token)) {\n      // Verify token has not expired\n      const tokenPayload = parseJWTPayload(token);\n\n      if (Date.now() >= (tokenPayload.exp as number) * 1000) {\n        this.clearActiveLogin();\n        throw new OperationOutcomeError(unauthorizedTokenExpired);\n      }\n\n      // Verify app_client_id\n      if (tokenPayload.cid) {\n        if (tokenPayload.cid !== this.clientId) {\n          this.clearActiveLogin();\n          throw new OperationOutcomeError(unauthorizedTokenAudience);\n        }\n      } else if (this.clientId && tokenPayload.client_id !== this.clientId) {\n        this.clearActiveLogin();\n        throw new OperationOutcomeError(unauthorizedTokenAudience);\n      }\n    }\n\n    return this.setActiveLogin({\n      accessToken: token,\n      refreshToken: tokens.refresh_token,\n      project: tokens.project,\n      profile: tokens.profile,\n    });\n  }\n\n  private checkSessionDetailsMatchLogin(login?: LoginState): boolean {\n    // We only need to validate if we already have session details\n    if (!(this.sessionDetails && login)) {\n      return true;\n    }\n    // Make sure sessionDetails.profile.id matches the ID in the profile reference we are checking against\n    // Otherwise return false if no profile reference in login\n    return login.profile?.reference?.endsWith(this.sessionDetails.profile.id) ?? false;\n  }\n\n  /**\n   * Sets up a listener for window storage events.\n   * This synchronizes state across browser windows and browser tabs.\n   */\n  private setupStorageListener(): void {\n    try {\n      window.addEventListener('storage', (e: StorageEvent) => {\n        // Storage events fire when different tabs make changes.\n        // On storage clear (key === null) or profile change (key === 'activeLogin', and profile in 'activeLogin' is different)\n        // Refresh the page to ensure the active login is up to date.\n        if (e.key === null) {\n          window.location.reload();\n        } else if (e.key === 'activeLogin') {\n          const oldState = (e.oldValue ? JSON.parse(e.oldValue) : undefined) as LoginState | undefined;\n          const newState = (e.newValue ? JSON.parse(e.newValue) : undefined) as LoginState | undefined;\n          if (\n            oldState?.profile.reference !== newState?.profile.reference ||\n            !this.checkSessionDetailsMatchLogin(newState)\n          ) {\n            window.location.reload();\n          } else if (newState) {\n            this.setAccessToken(newState.accessToken, newState.refreshToken);\n          } else {\n            // Theoretically this should never be called, but we might want to keep it here just in case\n            this.clear();\n          }\n        }\n      });\n    } catch (_err) {\n      // Silently ignore if this environment does not support storage events\n    }\n  }\n\n  /**\n   * Gets the `SubscriptionManager` for WebSocket subscriptions.\n   *\n   * @category Subscriptions\n   * @returns the `SubscriptionManager` for this client.\n   */\n  getSubscriptionManager(): SubscriptionManager {\n    if (!this.subscriptionManager) {\n      this.subscriptionManager = new SubscriptionManager(this, getWebSocketUrl(this.baseUrl, '/ws/subscriptions-r4'));\n    }\n    return this.subscriptionManager;\n  }\n\n  /**\n   * Subscribes to a given criteria, listening to notifications over WebSockets.\n   *\n   * This uses Medplum's `WebSocket Subscriptions` under the hood.\n   *\n   * A `SubscriptionEmitter` is returned from this function, which can be used to listen for updates to resources described by the given criteria.\n   *\n   * When subscribing to the same criteria multiple times, the same `SubscriptionEmitter` will be returned, and a reference count will be incremented.\n   *\n   * -----\n   * @example\n   * ```ts\n   * const emitter = medplum.subscribeToCriteria('Communication');\n   *\n   * emitter.addEventListener('message', (bundle: Bundle) => {\n   *   // Called when a `Communication` resource is created or modified\n   *   console.log(bundle?.entry?.[1]?.resource); // Logs the `Communication` resource that was updated\n   * });\n   * ```\n   *\n   * @category Subscriptions\n   * @param criteria - The criteria to subscribe to.\n   * @param subscriptionProps - Optional properties to add to the created `Subscription` resource.\n   * @returns a `SubscriptionEmitter` that emits `Bundle` resources containing changes to resources based on the given criteria.\n   */\n  subscribeToCriteria(criteria: string, subscriptionProps?: Partial<Subscription>): SubscriptionEmitter {\n    return this.getSubscriptionManager().addCriteria(criteria, subscriptionProps);\n  }\n\n  /**\n   * Unsubscribes from the given criteria.\n   *\n   * When called the same amount of times as proceeding calls to `subscribeToCriteria` on a given `criteria`,\n   * the criteria is fully removed from the `SubscriptionManager`.\n   *\n   * @category Subscriptions\n   * @param criteria - The criteria to unsubscribe from.\n   * @param subscriptionProps - The optional properties that `subscribeToCriteria` was called with.\n   */\n  unsubscribeFromCriteria(criteria: string, subscriptionProps?: Partial<Subscription>): void {\n    if (!this.subscriptionManager) {\n      return;\n    }\n    this.subscriptionManager.removeCriteria(criteria, subscriptionProps);\n    if (this.subscriptionManager.getCriteriaCount() === 0) {\n      this.subscriptionManager.closeWebSocket();\n    }\n  }\n\n  /**\n   * Get the master `SubscriptionEmitter` for the `SubscriptionManager`.\n   *\n   * The master `SubscriptionEmitter` gets messages for all subscribed `criteria` as well as WebSocket errors, `connect` and `disconnect` events, and the `close` event.\n   *\n   * It can also be used to listen for `heartbeat` messages.\n   *\n   *------\n   * @example\n   * ### Listening for `heartbeat`:\n   * ```ts\n   * const masterEmitter = medplum.getMasterSubscriptionEmitter();\n   *\n   * masterEmitter.addEventListener('heartbeat', (bundle: Bundle<SubscriptionStatus>) => {\n   *   console.log(bundle?.entry?.[0]?.resource); // A `SubscriptionStatus` of type `heartbeat`\n   * });\n   *\n   * ```\n   * @category Subscriptions\n   * @returns the master `SubscriptionEmitter` from the `SubscriptionManager`.\n   */\n  getMasterSubscriptionEmitter(): SubscriptionEmitter {\n    return this.getSubscriptionManager().getMasterEmitter();\n  }\n}\n\n/**\n * Returns the default fetch method.\n * The default fetch is currently only available in browser environments.\n * If you want to use SSR such as Next.js, you should pass a custom fetch function.\n * @returns The default fetch function for the current environment.\n */\nfunction getDefaultFetch(): FetchLike {\n  if (!globalThis.fetch) {\n    throw new Error('Fetch not available in this environment');\n  }\n  return globalThis.fetch.bind(globalThis);\n}\n\n/**\n * Returns the base URL for the current page.\n * @returns The window origin string.\n * @category HTTP\n */\nfunction getWindowOrigin(): string {\n  if (typeof window === 'undefined') {\n    return '';\n  }\n  return window.location.protocol + '//' + window.location.host + '/';\n}\n\n/**\n * Attempts to retrieve the content location from the given HTTP response.\n *\n * This function prioritizes the \"Content-Location\" HTTP header as the\n * most authoritative source for the content location. If this header is\n * not present, it falls back to the \"Location\" HTTP header.\n *\n * Note that the FHIR spec does not follow the traditional HTTP semantics of \"Content-Location\" and \"Location\".\n * \"Content-Location\" is not typically used with HTTP 202 responses because the content itself isn't available at the time of the response.\n * However, the FHIR spec explicitly recommends it:\n *\n *   3.2.6.1.2 Kick-off Request\n *   3.2.6.1.2.0.3 Response - Success\n *   HTTP Status Code of 202 Accepted\n *   Content-Location header with the absolute URL of an endpoint for subsequent status requests (polling location)\n *\n * Source: https://hl7.org/fhir/async-bulk.html\n *\n * In cases where neither of these headers are available (for instance,\n * due to CORS restrictions), it attempts to retrieve the content location\n * from the 'diagnostics' field of the first issue in an OperationOutcome object\n * present in the response body. If all attempts fail, the function returns 'undefined'.\n *\n * @async\n * @param response - The HTTP response object from which to extract the content location.\n * @param body - The response body.\n * @returns A Promise that resolves to the content location string if it is found, or 'undefined' if the content location cannot be determined from the response.\n */\nasync function tryGetContentLocation(\n  response: Response,\n  body: Record<string, string> | string | undefined\n): Promise<string | undefined> {\n  // Accepted content location can come from multiple sources\n  // The authoritative source is the \"Content-Location\" HTTP header.\n  const contentLocation = response.headers.get('content-location');\n  if (contentLocation) {\n    return contentLocation;\n  }\n\n  // The next best source is the \"Location\" HTTP header.\n  const location = response.headers.get('location');\n  if (location) {\n    return location;\n  }\n\n  // However, \"Content-Location\" may not be available due to CORS limitations.\n  // In this case, we use the OperationOutcome.diagnostics field.\n  if (isOperationOutcome(body) && body.issue?.[0]?.diagnostics) {\n    return body.issue[0].diagnostics;\n  }\n\n  // If all else fails, return undefined.\n  return undefined;\n}\n\n/**\n * Converts a FHIR resource bundle to a resource array.\n * The bundle is attached to the array as a property named \"bundle\".\n * @param bundle - A FHIR resource bundle.\n * @returns The resource array with the bundle attached.\n */\nfunction bundleToResourceArray<T extends Resource>(bundle: Bundle<T>): ResourceArray<T> {\n  const array = bundle.entry?.map((e) => e.resource as T) ?? [];\n  return Object.assign(array, { bundle });\n}\n\nfunction isCreateBinaryOptions(input: unknown): input is CreateBinaryOptions {\n  return isObject(input) && 'data' in input && 'contentType' in input;\n}\n\n// This function can be deleted after Medplum 4.0 and we remove the legacy createBinary method\nexport function normalizeCreateBinaryOptions(\n  arg1: BinarySource | CreateBinaryOptions,\n  arg2: string | undefined | MedplumRequestOptions,\n  arg3?: string,\n  arg4?: (e: ProgressEvent) => void\n): CreateBinaryOptions {\n  if (isCreateBinaryOptions(arg1)) {\n    return arg1;\n  }\n  return {\n    data: arg1,\n    filename: arg2 as string | undefined,\n    contentType: arg3 as string,\n    onProgress: arg4,\n  };\n}\n\nfunction isCreatePdfOptions(input: unknown): input is CreatePdfOptions {\n  return isObject(input) && 'docDefinition' in input;\n}\n\n// This function can be deleted after Medplum 4.0 and we remove the legacy createPdf method\nexport function normalizeCreatePdfOptions(\n  arg1: TDocumentDefinitions | CreatePdfOptions,\n  arg2: string | undefined | MedplumRequestOptions,\n  arg3: Record<string, CustomTableLayout> | undefined,\n  arg4: TFontDictionary | undefined\n): CreatePdfOptions {\n  if (isCreatePdfOptions(arg1)) {\n    return arg1;\n  }\n  return {\n    docDefinition: arg1,\n    filename: arg2 as string,\n    tableLayouts: arg3,\n    fonts: arg4,\n  };\n}\n\nfunction isRetryable(response: Response): boolean {\n  return response.status === 429 || response.status >= 500;\n}\n", "import { TypeName } from './types';\n\nexport const ExternalSecretSystems = {\n  aws_ssm_parameter_store: 'aws_ssm_parameter_store',\n} as const;\n\nexport type ExternalSecretSystem = keyof typeof ExternalSecretSystems;\nexport type ExternalSecretPrimitive = string | boolean | number;\nexport type ExternalSecretPrimitiveType = 'string' | 'boolean' | 'number';\nexport type ExternalSecret<T extends ExternalSecretPrimitive = ExternalSecretPrimitive> = {\n  system: ExternalSecretSystem;\n  key: string;\n  type: TypeName<T>;\n};\nexport type ValueOrExternalSecret<T extends ExternalSecretPrimitive> = T | ExternalSecret<T>;\nexport type StringMap = { [key: string]: string };\n\nexport interface MedplumSourceInfraConfig {\n  name: ValueOrExternalSecret<string>;\n  stackName: ValueOrExternalSecret<string>;\n  accountNumber: ValueOrExternalSecret<string>;\n  region: string;\n  domainName: ValueOrExternalSecret<string>;\n  vpcId: ValueOrExternalSecret<string>;\n  apiPort: ValueOrExternalSecret<number>;\n  apiDomainName: ValueOrExternalSecret<string>;\n  apiSslCertArn: ValueOrExternalSecret<string>;\n  apiInternetFacing?: ValueOrExternalSecret<boolean>;\n  apiWafIpSetArn: ValueOrExternalSecret<string>;\n  appDomainName: ValueOrExternalSecret<string>;\n  appSslCertArn: ValueOrExternalSecret<string>;\n  appApiProxy?: ValueOrExternalSecret<boolean>;\n  appWafIpSetArn: ValueOrExternalSecret<string>;\n  appLoggingBucket?: ValueOrExternalSecret<string>;\n  appLoggingPrefix?: ValueOrExternalSecret<string>;\n  storageBucketName: ValueOrExternalSecret<string>;\n  storageDomainName: ValueOrExternalSecret<string>;\n  storageSslCertArn: ValueOrExternalSecret<string>;\n  signingKeyId: ValueOrExternalSecret<string>;\n  storagePublicKey: ValueOrExternalSecret<string>;\n  storageWafIpSetArn: ValueOrExternalSecret<string>;\n  storageLoggingBucket?: ValueOrExternalSecret<string>;\n  storageLoggingPrefix?: ValueOrExternalSecret<string>;\n  baseUrl: ValueOrExternalSecret<string>;\n  maxAzs: ValueOrExternalSecret<number>;\n  rdsInstances: ValueOrExternalSecret<number>;\n  rdsInstanceType: ValueOrExternalSecret<string>;\n  rdsInstanceVersion?: ValueOrExternalSecret<string>;\n  rdsSecretsArn?: ValueOrExternalSecret<string>;\n  rdsReaderInstanceType?: ValueOrExternalSecret<string>;\n  rdsProxyEnabled?: ValueOrExternalSecret<boolean>;\n  rdsClusterParameters?: StringMap;\n  cacheNodeType?: ValueOrExternalSecret<string>;\n  cacheSecurityGroupId?: ValueOrExternalSecret<string>;\n  desiredServerCount: ValueOrExternalSecret<number>;\n  serverImage: ValueOrExternalSecret<string>;\n  serverMemory: ValueOrExternalSecret<number>;\n  serverCpu: ValueOrExternalSecret<number>;\n  loadBalancerSecurityGroupId?: ValueOrExternalSecret<string>;\n  loadBalancerLoggingBucket?: ValueOrExternalSecret<string>;\n  loadBalancerLoggingPrefix?: ValueOrExternalSecret<string>;\n  clamscanEnabled: ValueOrExternalSecret<boolean>;\n  clamscanLoggingBucket: ValueOrExternalSecret<string>;\n  clamscanLoggingPrefix: ValueOrExternalSecret<string>;\n  skipDns?: ValueOrExternalSecret<boolean>;\n  hostedZoneName?: ValueOrExternalSecret<string>;\n  wafLogGroupName?: ValueOrExternalSecret<string>;\n  wafLogGroupCreate?: ValueOrExternalSecret<boolean>;\n  additionalContainers?: {\n    name: ValueOrExternalSecret<string>;\n    image: ValueOrExternalSecret<string>;\n    cpu?: ValueOrExternalSecret<number>;\n    memory?: ValueOrExternalSecret<number>;\n    essential?: ValueOrExternalSecret<boolean>;\n    command?: ValueOrExternalSecret<string>[];\n    environment?: {\n      [key: string]: ValueOrExternalSecret<string>;\n    };\n  }[];\n  containerInsights?: ValueOrExternalSecret<boolean>;\n  cloudTrailAlarms?: {\n    logGroupName: ValueOrExternalSecret<string>;\n    logGroupCreate?: ValueOrExternalSecret<boolean>;\n    snsTopicArn?: ValueOrExternalSecret<string>;\n    snsTopicName?: ValueOrExternalSecret<string>;\n  };\n  fargateAutoScaling?: {\n    minCapacity: ValueOrExternalSecret<number>;\n    maxCapacity: ValueOrExternalSecret<number>;\n    targetUtilizationPercent: ValueOrExternalSecret<number>;\n    scaleInCooldown: ValueOrExternalSecret<number>;\n    scaleOutCooldown: ValueOrExternalSecret<number>;\n  };\n  environment?: StringMap;\n\n  rdsIdsMajorVersionSuffix?: boolean;\n  rdsPersistentParameterGroups?: boolean;\n}\n\nexport interface MedplumInfraConfig {\n  name: string;\n  stackName: string;\n  accountNumber: string;\n  region: string;\n  domainName: string;\n  vpcId: string;\n  apiPort: number;\n  apiDomainName: string;\n  apiSslCertArn: string;\n  apiInternetFacing?: boolean;\n  apiWafIpSetArn?: string;\n  appDomainName: string;\n  appSslCertArn: string;\n  appApiProxy?: boolean;\n  appWafIpSetArn?: string;\n  appLoggingBucket?: string;\n  appLoggingPrefix?: string;\n  storageBucketName: string;\n  storageDomainName: string;\n  storageSslCertArn: string;\n  signingKeyId: string;\n  storagePublicKey: string;\n  storageWafIpSetArn?: string;\n  storageLoggingBucket?: string;\n  storageLoggingPrefix?: string;\n  baseUrl: string;\n  maxAzs: number;\n  rdsInstances: number;\n  rdsInstanceType: string;\n  rdsInstanceVersion?: string;\n  rdsClusterParameters?: StringMap;\n  rdsSecretsArn?: string;\n  rdsReaderInstanceType?: string;\n  rdsProxyEnabled?: boolean;\n  cacheNodeType?: string;\n  cacheSecurityGroupId?: string;\n  desiredServerCount: number;\n  serverImage: string;\n  serverMemory: number;\n  serverCpu: number;\n  loadBalancerSecurityGroupId?: string;\n  loadBalancerLoggingBucket?: string;\n  loadBalancerLoggingPrefix?: string;\n  clamscanEnabled: boolean;\n  clamscanLoggingBucket: string;\n  clamscanLoggingPrefix: string;\n  skipDns?: boolean;\n  hostedZoneName?: string;\n  wafLogGroupName?: string;\n  wafLogGroupCreate?: boolean;\n  additionalContainers?: {\n    name: string;\n    image: string;\n    cpu?: number;\n    memory?: number;\n    essential?: boolean;\n    command?: string[];\n    environment?: {\n      [key: string]: string;\n    };\n  }[];\n  containerInsights?: boolean;\n  cloudTrailAlarms?: {\n    logGroupName: string;\n    logGroupCreate?: boolean;\n    snsTopicArn?: string;\n    snsTopicName?: string;\n  };\n  fargateAutoScaling?: {\n    minCapacity: number;\n    maxCapacity: number;\n    targetUtilizationPercent: number;\n    scaleInCooldown: number;\n    scaleOutCooldown: number;\n  };\n  environment?: StringMap;\n\n  rdsIdsMajorVersionSuffix?: boolean;\n  rdsPersistentParameterGroups?: boolean;\n}\n", "import { Bundle, CodeableConcept, Observation, Quantity, SampledData } from '@medplum/fhirtypes';\nimport { getReferenceString } from './utils';\n\nexport type StatsFn = (data: number[]) => number | Quantity;\nexport type QuantityUnit = Pick<Quantity, 'unit' | 'code' | 'system'>;\nexport type SamplingInfo = Omit<SampledData, 'data'>;\n\n/**\n * Summarizes a group of Observations into a single computed summary value, with the individual values\n * preserved in `Observation.component.valueSampledData`.\n *\n * @param observations - The Observations to summarize.\n * @param summaryCode - The code for the summarized value.\n * @param summarizeFn - Function to summarize the data points.\n * @returns - The summary Observation resource.\n */\nexport function summarizeObservations(\n  observations: Observation[] | Bundle<Observation>,\n  summaryCode: CodeableConcept,\n  summarizeFn: StatsFn\n): Observation {\n  const sampler = new DataSampler();\n  if (!Array.isArray(observations)) {\n    observations = observations.entry?.map((e) => e.resource as Observation) ?? [];\n  }\n  for (const obs of observations) {\n    sampler.addObservation(obs);\n  }\n  return sampler.summarize(summaryCode, summarizeFn);\n}\n\nexport interface DataSampleOptions {\n  /** Code for the data points. */\n  code?: CodeableConcept;\n  /** Unit for the data points. */\n  unit?: QuantityUnit;\n  /** Sampling information for high-frequency Observations. */\n  sampling?: Omit<SampledData, 'data'>;\n}\n\nexport class DataSampler {\n  private code?: CodeableConcept;\n  private unit?: QuantityUnit;\n  private readonly sampling?: Omit<SampledData, 'data'>;\n  private readonly dataPoints: number[];\n\n  /**\n   * @param opts - Optional parameters.\n   */\n  constructor(opts?: DataSampleOptions) {\n    this.dataPoints = [];\n    this.code = opts?.code;\n    this.unit = opts?.unit;\n    this.sampling = opts?.sampling;\n  }\n\n  addObservation(obs: Observation): void {\n    if (!this.code) {\n      this.code = obs.code;\n    } else if (!codesOverlap(this.code, obs.code)) {\n      throw new Error('Observation does not match code of sampled data');\n    }\n\n    if (obs.valueQuantity?.value !== undefined) {\n      this.checkUnit(obs.valueQuantity);\n      this.addData(obs.valueQuantity.value);\n    } else if (obs.valueInteger !== undefined) {\n      this.addData(obs.valueInteger);\n    } else if (obs.valueSampledData?.data) {\n      this.checkUnit(obs.valueSampledData.origin);\n      this.addData(...expandSampledData(obs.valueSampledData));\n    }\n  }\n\n  addData(...data: number[]): void {\n    this.dataPoints.push(...data);\n  }\n\n  private checkUnit(quantity: Quantity): void {\n    if (!this.unit) {\n      this.unit = quantity;\n    } else if (quantity.code && quantity.system) {\n      if (this.unit.system !== quantity.system || this.unit.code !== quantity.code) {\n        throw new Error('Incorrect unit for Observation');\n      }\n    } else if (quantity.unit) {\n      if (this.unit.unit !== quantity.unit) {\n        throw new Error('Incorrect unit for Observation');\n      }\n    }\n  }\n\n  summarize(code: CodeableConcept, fn: StatsFn): Observation {\n    if (!this.code) {\n      throw new Error('Code is required for data points');\n    }\n\n    const computedValue = fn(this.dataPoints);\n    return {\n      resourceType: 'Observation',\n      status: 'final',\n      code,\n      valueQuantity: typeof computedValue === 'number' ? { ...this.unit, value: computedValue } : computedValue,\n      component: [\n        {\n          code: this.code,\n          valueSampledData: {\n            origin: { ...this.unit, value: 0 },\n            dimensions: 1,\n            period: 0,\n            ...this.sampling,\n            data: compressSampledData(this.dataPoints, this.sampling),\n          },\n        },\n      ],\n    };\n  }\n}\n\nfunction codesOverlap(a: CodeableConcept, b: CodeableConcept): boolean {\n  return Boolean(a.coding?.some((c) => b.coding?.some((t) => c.system === t.system && c.code === t.code)));\n}\n\nexport function expandSampledData(sample: SampledData): number[] {\n  return sample.data?.split(' ').map((d) => parseFloat(d) * (sample.factor ?? 1) + (sample.origin.value ?? 0)) ?? [];\n}\n\nfunction compressSampledData(data: number[], sampling?: SamplingInfo): string | undefined {\n  if (!data.length) {\n    return undefined;\n  }\n  return data.map((d) => (d - (sampling?.origin.value ?? 0)) / (sampling?.factor ?? 1)).join(' ');\n}\n\nexport function expandSampledObservation(obs: Observation): Observation[] {\n  const results: Observation[] = [];\n  const obsTimestamp = obs.effectiveInstant ?? obs.effectiveDateTime ?? obs.effectivePeriod?.start;\n  const startTime = obsTimestamp ? Date.parse(obsTimestamp).valueOf() : 0;\n\n  if (obs.valueSampledData) {\n    results.push(...convertSampleToObservations(obs.valueSampledData, startTime, obs));\n  }\n  if (obs.component) {\n    for (const component of obs.component) {\n      if (component.valueSampledData) {\n        results.push(...convertSampleToObservations(component.valueSampledData, startTime, { ...obs, ...component }));\n      }\n    }\n  }\n  return results;\n}\n\nfunction convertSampleToObservations(sample: SampledData, startTime: number, template: Observation): Observation[] {\n  const results: Observation[] = [];\n  const values = expandSampledData(sample);\n  const parentObservation = getReferenceString(template);\n\n  for (let i = 0; i < values.length; i++) {\n    const value = values[i];\n    const dataPointTime = startTime + Math.floor(i / sample.dimensions) * sample.period;\n    results.push({\n      ...template,\n      id: undefined,\n      effectiveInstant: undefined,\n      effectivePeriod: undefined,\n      effectiveTiming: undefined,\n      effectiveDateTime: dataPointTime ? new Date(dataPointTime).toISOString() : undefined,\n      valueQuantity: { ...sample.origin, value },\n      valueSampledData: undefined,\n      component: undefined,\n      derivedFrom: parentObservation\n        ? [...(template.derivedFrom ?? []), { reference: parentObservation }]\n        : template.derivedFrom,\n    });\n  }\n  return results;\n}\n", "import { AccessPolicyResource } from '@medplum/fhirtypes';\nimport { InternalSchemaElement } from './typeschema/types';\nimport { getPathDifference, splitN } from './utils';\n\nexport interface ExtendedInternalSchemaElement extends InternalSchemaElement {\n  readonly?: boolean;\n}\n\nexport type ExtendedElementProperties = { readonly: boolean; hidden: boolean };\n\n/*\nThroughout ElementsContext and the ResourceForm components, we use the following terminology:\n\"path\" refers to the FHIR path to an element including the resourceType, e.g. Patient.name.family\n\"key\" is a contextually relative path to an element not prefixed by the resourceType, e.g. name.family,\n*/\n\n/**\n * Information for the set of elements at a given path within in a resource. This mostly exists to\n * normalize access to elements regardless of whether they are from a profile, extension, or slice.\n */\nexport type ElementsContextType = {\n  /** The FHIR path from the root resource to which the keys of `elements` are relative. */\n  path: string;\n  /**\n   * The mapping of keys to `ExtendedInternalSchemaElement` at the current `path` relative to the\n   * root resource. `elements` originate from either `InternalTypeSchema.elements` or\n   * `SliceDefinition.elements` when the elements context is created within a slice.\n   */\n  elements: Record<string, ExtendedInternalSchemaElement>;\n  /**\n   * Similar mapping as `elements`, but with keys being the full path from the root resource rather\n   * than relative to `path`, in other words, the keys of the Record are `${path}.${key}`.\n   */\n  elementsByPath: Record<string, ExtendedInternalSchemaElement>;\n  /** The URL, if any, of the resource profile or extension from which the `elements` collection originated. */\n  profileUrl: string | undefined;\n  /** Whether debug logging is enabled */\n  debugMode: boolean;\n  /** The `AccessPolicyResource` provided, if any, used to determine hidden and readonly elements. */\n  accessPolicyResource?: AccessPolicyResource;\n  /**\n   * Used to get an `ExtendedElementProperties` object for an element at a given path. This\n   * is primarily useful when working with elements not included in `InternalTypeSchema.elements`\n   * as is the case for nested elements that have not been modified by a profile or extension,\n   * e.g. Patient.name.family.\n   *\n   * This function does not attempt to determine if the input `path` is actually an element in the\n   * resource. When a syntactically correct path to a nonexistent element, e.g. Patient.foobar, is provided,\n   * a `ExtendedElementProperties` object with default values is returned.\n   *\n   * @param path - The full path to an element in the resource, e.g. Patient.name.family\n   * @returns An `ExtendedElementProperties` object with `readonly` and `hidden` properties for the\n   * element at `path`, or `undefined` if the input path is malformed.\n   */\n  getExtendedProps(path: string): ExtendedElementProperties | undefined;\n  /** `true` if this is a default/placeholder `ElementsContextType` */\n  isDefaultContext?: boolean;\n};\n\nexport function buildElementsContext({\n  parentContext,\n  path,\n  elements,\n  profileUrl,\n  debugMode,\n  accessPolicyResource,\n}: {\n  /** The most recent `ElementsContextType` in which this context is being built. */\n  parentContext: ElementsContextType | undefined;\n  /** The FHIR path from the root resource to which the keys of `elements` are relative. */\n  path: string;\n  /**\n   * The mapping of keys to `InternalSchemaElement` at the current `path` relative to the\n   * root resource. This should be either `InternalTypeSchema.elements` or `SliceDefinition.elements`.\n   */\n  elements: Record<string, InternalSchemaElement>;\n  /** The URL, if any, of the resource profile or extension from which the `elements` collection originated. */\n  profileUrl?: string;\n  /** Whether debug logging is enabled */\n  debugMode?: boolean;\n  accessPolicyResource?: AccessPolicyResource;\n}): ElementsContextType | undefined {\n  if (path === parentContext?.path) {\n    return undefined;\n  }\n\n  debugMode ??= parentContext?.debugMode ?? false;\n  accessPolicyResource ??= parentContext?.accessPolicyResource;\n\n  let mergedElements: Record<string, ExtendedInternalSchemaElement> = mergeElementsForContext(\n    path,\n    elements,\n    parentContext,\n    Boolean(debugMode)\n  );\n\n  const keyPrefix = splitN(path, '.', 2)[1] as string | undefined;\n  mergedElements = removeHiddenFields(mergedElements, accessPolicyResource, keyPrefix);\n  mergedElements = markReadonlyFields(mergedElements, accessPolicyResource, keyPrefix);\n\n  const elementsByPath: Record<string, ExtendedInternalSchemaElement> = Object.create(null);\n  for (const [key, property] of Object.entries(mergedElements)) {\n    elementsByPath[path + '.' + key] = property;\n  }\n\n  /*\n  Since AccessPolicyResource.readonlyFields and hiddenFields are always relative to the root resource, we propagate\n  a memoized `getExtendedProps` from the outermost ElementsContext\n  */\n  let getExtendedProps: (path: string) => ExtendedElementProperties | undefined;\n  if (parentContext && !parentContext.isDefaultContext) {\n    getExtendedProps = parentContext.getExtendedProps;\n  } else {\n    const memoizedExtendedProps: Record<string, ExtendedElementProperties> = Object.create(null);\n    getExtendedProps = (path: string): ExtendedElementProperties | undefined => {\n      const key = splitN(path, '.', 2)[1] as string | undefined;\n      if (!key) {\n        return undefined;\n      }\n\n      if (!memoizedExtendedProps[key]) {\n        const hidden = matchesKeyPrefixes(key, accessPolicyResource?.hiddenFields);\n        memoizedExtendedProps[key] = {\n          hidden,\n          // hidden implies readonly even if it's not explicitly marked as such\n          readonly: hidden || matchesKeyPrefixes(key, accessPolicyResource?.readonlyFields),\n        };\n      }\n      return memoizedExtendedProps[key];\n    };\n  }\n\n  return {\n    path: path,\n    elements: mergedElements,\n    elementsByPath,\n    profileUrl: profileUrl ?? parentContext?.profileUrl,\n    debugMode,\n    getExtendedProps,\n    accessPolicyResource,\n  };\n}\n\nfunction mergeElementsForContext(\n  path: string,\n  elements: Record<string, InternalSchemaElement>,\n  parentContext: ElementsContextType | undefined,\n  debugMode: boolean\n): Record<string, InternalSchemaElement> {\n  const result: Record<string, InternalSchemaElement> = Object.create(null);\n\n  if (parentContext) {\n    for (const [elementPath, element] of Object.entries(parentContext.elementsByPath)) {\n      const key = getPathDifference(path, elementPath);\n      if (key !== undefined) {\n        result[key] = element;\n      }\n    }\n  }\n\n  let usedNewElements = false;\n  if (elements) {\n    for (const [key, element] of Object.entries(elements)) {\n      if (!(key in result)) {\n        result[key] = element;\n        usedNewElements = true;\n      }\n    }\n  }\n\n  // if no new elements are used, the ElementsContext is unnecessary.\n  // We could add another guard against unnecessary contexts if usedNewElements is false,\n  // but unnecessary contexts **should** already be taken care before\n  // this is ever hit. Leaving the debug logging in for now.\n  if (debugMode) {\n    console.assert(usedNewElements, 'Unnecessary ElementsContext; not using any newly provided elements');\n  }\n  return result;\n}\n\nfunction removeHiddenFields(\n  elements: Record<string, InternalSchemaElement>,\n  accessPolicyResource: AccessPolicyResource | undefined,\n  keyPrefix?: string\n): Record<string, InternalSchemaElement> {\n  if (!accessPolicyResource?.hiddenFields?.length) {\n    return elements;\n  }\n\n  const prefix = keyPrefix ? keyPrefix + '.' : '';\n  return Object.fromEntries(\n    Object.entries(elements).filter(([key]) => !matchesKeyPrefixes(prefix + key, accessPolicyResource.hiddenFields))\n  );\n}\n\nfunction markReadonlyFields(\n  elements: Record<string, InternalSchemaElement>,\n  accessPolicyResource: AccessPolicyResource | undefined,\n  keyPrefix?: string\n): Record<string, ExtendedInternalSchemaElement> {\n  if (!accessPolicyResource?.readonlyFields?.length) {\n    return elements;\n  }\n\n  const result: Record<string, ExtendedInternalSchemaElement> = Object.create(null);\n\n  const prefix = keyPrefix ? keyPrefix + '.' : '';\n  for (const [key, element] of Object.entries(elements)) {\n    const isReadonly = matchesKeyPrefixes(prefix + key, accessPolicyResource.readonlyFields);\n    if (isReadonly) {\n      // shallow-clone `element` to avoid modifying the in-memory DATA_TYPES cache access via `getDataType`\n      result[key] = { ...element, readonly: true };\n    } else {\n      result[key] = element;\n    }\n  }\n\n  return result;\n}\n\nfunction matchesKeyPrefixes(key: string, prefixes: string[] | undefined): boolean {\n  // It might be a performance win to convert prefixes to a set, but the\n  // cardinality of prefixes, i.e. hidden/readonly fields, is expected to be small (< 10)\n  // such that the memory overhead of a set is not worth the performance gain.\n\n  if (!prefixes?.length) {\n    return false;\n  }\n\n  const keyParts = key.split('.');\n  for (let i = 1; i <= keyParts.length; i++) {\n    const key = keyParts.slice(0, i).join('.');\n    if (prefixes.includes(key)) {\n      return true;\n    }\n  }\n  return false;\n}\n", "import { TypedValue } from '../types';\nimport { getNestedProperty } from './crawler';\nimport { InternalTypeSchema, SliceDefinition, SliceDiscriminator } from './types';\nimport { matchDiscriminant } from './validation';\n\nexport type SliceDefinitionWithTypes = SliceDefinition & {\n  type: NonNullable<SliceDefinition['type']>;\n  typeSchema?: InternalTypeSchema;\n};\n\nexport function isSliceDefinitionWithTypes(slice: SliceDefinition): slice is SliceDefinitionWithTypes {\n  return slice.type !== undefined && slice.type.length > 0;\n}\n\nfunction isDiscriminatorComponentMatch(\n  typedValue: TypedValue,\n  discriminator: SliceDiscriminator,\n  slice: SliceDefinitionWithTypes,\n  profileUrl: string | undefined\n): boolean {\n  const nestedProp = getNestedProperty(typedValue, discriminator.path, { profileUrl });\n\n  if (nestedProp) {\n    const elements = slice.typeSchema?.elements ?? slice.elements;\n    return nestedProp.some((v: any) => matchDiscriminant(v, discriminator, slice, elements)) ?? false;\n  }\n\n  console.assert(false, 'getNestedProperty[%s] in isDiscriminatorComponentMatch missed', discriminator.path);\n  return false;\n}\n\nexport function getValueSliceName(\n  value: any,\n  slices: SliceDefinitionWithTypes[],\n  discriminators: SliceDiscriminator[],\n  profileUrl: string | undefined\n): string | undefined {\n  if (!value) {\n    return undefined;\n  }\n\n  for (const slice of slices) {\n    const typedValue: TypedValue = {\n      value,\n      type: slice.typeSchema?.type ?? slice.type?.[0].code,\n    };\n    if (\n      discriminators.every((d) =>\n        isDiscriminatorComponentMatch(typedValue, d, slice, slice.typeSchema?.url ?? profileUrl)\n      )\n    ) {\n      return slice.name;\n    }\n  }\n  return undefined;\n}\n", "import { ElementsContextType, buildElementsContext } from './elements-context';\nimport { SliceDefinitionWithTypes, isSliceDefinitionWithTypes } from './typeschema/slices';\nimport {\n  InternalSchemaElement,\n  InternalTypeSchema,\n  SliceDefinition,\n  SlicingRules,\n  tryGetProfile,\n} from './typeschema/types';\nimport { isPopulated } from './utils';\n\nexport type VisitorSlicingRules = Omit<SlicingRules, 'slices'> & {\n  slices: SliceDefinitionWithTypes[];\n};\n\nexport interface SchemaVisitor {\n  /**\n   * Called when entering a schema. This is called once for the root profile and once for each\n   * extension with a profile associated with it.\n   * @param schema - The schema being entered.\n   */\n  onEnterSchema?: (schema: InternalTypeSchema) => void;\n  /**\n   * Called when exiting a schema. See `onEnterSchema` for more information.\n   * @param schema - The schema being exited.\n   */\n  onExitSchema?: (schema: InternalTypeSchema) => void;\n\n  /**\n   * Called when entering an element. This is called for every element in the schema in a\n   * tree-like fashion. If the element has slices, the slices are crawled after `onEnterElement`\n   * but before `onExitElement`.\n   *\n   * @example\n   * Example of tree-like method invocation ordering:\n   * '''typescript\n   * onEnterElement('Patient.name')\n   * onEnterElement('Patient.name.given')\n   * onExitElement('Patient.name.given')\n   * onEnterElement('Patient.name.family')\n   * onExitElement('Patient.name.family')\n   * onExitElement('Patient.name')\n   * '''\n   *\n   *\n   * @param path - The full path of the element being entered, even if within an extension. e.g The\n   * path of the ombCategory extension within the US Core Race extension will be\n   * 'Patient.extension.extension.value[x]' rather than 'Extension.extension.value[x]'. The latter is\n   * accessible on the element parameter.\n   * @param element - The element being entered.\n   * @param elementsContext - The context of the elements currently being crawled.\n   */\n  onEnterElement?: (path: string, element: InternalSchemaElement, elementsContext: ElementsContextType) => void;\n\n  /**\n   * Called when exiting an element. See `onEnterElement` for more information.\n   * @param path - The full path of the element being exited.\n   * @param element - The element being exited.\n   * @param elementsContext - The context of the elements currently being crawled.\n   */\n  onExitElement?: (path: string, element: InternalSchemaElement, elementsContext: ElementsContextType) => void;\n\n  /**\n   * Called when entering a slice. Called for every slice in a given sliced element. `onEnterElement` and `onExitElement`\n   * will be called in a tree-like fashion for elements within the slice followed by `onExitSlice`.\n   *\n   * @example\n   * Example of a sliced element being crawled with some elements excluded for brevity:\n   * '''typescript\n   * onEnterElement  ('Observation.component')\n   *\n   * // systolic\n   * onEnterSlice    ('Observation.component', systolicSlice, slicingRules)\n   * onEnterElement  ('Observation.component.code')\n   * onExitElement   ('Observation.component.code')\n   * onEnterElement  ('Observation.component.value[x]')\n   * onEnterElement  ('Observation.component.value[x].code')\n   * onExitElement   ('Observation.component.value[x].code')\n   * onEnterElement  ('Observation.component.value[x].system')\n   * onExitElement   ('Observation.component.value[x].system')\n   * onExitElement   ('Observation.component.value[x]')\n   * onExitSlice     ('Observation.component', systolicSlice, slicingRules)\n   *\n   * // similar set of invocations for diastolic slice\n   *\n   * onExitElement  ('Observation.component')\n   * '''\n   *\n   * @param path - The full path of the sliced element being entered. See `onEnterElement` for more information.\n   * @param slice - The slice being entered.\n   * @param slicing - The slicing rules related to the slice being entered.\n   */\n  onEnterSlice?: (path: string, slice: SliceDefinitionWithTypes, slicing: VisitorSlicingRules) => void;\n\n  /**\n   * Called when exiting a slice. See `onEnterSlice` for more information.\n   * @param path - The full path of the sliced element being exited. See `onEnterElement` for more information.\n   * @param slice - The slice being exited.\n   * @param slicing - The slicing rules related to the slice.\n   */\n  onExitSlice?: (path: string, slice: SliceDefinitionWithTypes, slicing: VisitorSlicingRules) => void;\n}\n\nexport class SchemaCrawler {\n  private readonly rootSchema: InternalTypeSchema & { type: string };\n  private readonly visitor: SchemaVisitor;\n  private readonly elementsContextStack: ElementsContextType[];\n  private sliceAllowList: SliceDefinition[] | undefined;\n\n  constructor(schema: InternalTypeSchema, visitor: SchemaVisitor, elements?: InternalTypeSchema['elements']) {\n    if (schema.type === undefined) {\n      throw new Error('schema must include a type');\n    }\n    this.rootSchema = schema as InternalTypeSchema & { type: string };\n\n    const rootContext = buildElementsContext({\n      parentContext: undefined,\n      path: this.rootSchema.type,\n      elements: elements ?? this.rootSchema.elements,\n      profileUrl: this.rootSchema.name === this.rootSchema.type ? undefined : this.rootSchema.url,\n    });\n    if (rootContext === undefined) {\n      throw new Error('Could not create root elements context');\n    }\n\n    this.elementsContextStack = [rootContext];\n    this.visitor = visitor;\n  }\n\n  private get elementsContext(): ElementsContextType {\n    return this.elementsContextStack[this.elementsContextStack.length - 1];\n  }\n\n  crawlElement(element: InternalSchemaElement, key: string, path: string): void {\n    if (this.visitor.onEnterSchema) {\n      this.visitor.onEnterSchema(this.rootSchema);\n    }\n\n    const allowedElements = Object.fromEntries(\n      Object.entries(this.elementsContext.elements).filter(([elementKey]) => {\n        return elementKey.startsWith(key);\n      })\n    );\n\n    this.crawlElementsImpl(allowedElements, path);\n\n    if (this.visitor.onExitSchema) {\n      this.visitor.onExitSchema(this.rootSchema);\n    }\n  }\n\n  crawlSlice(key: string, slice: SliceDefinition, slicing: SlicingRules): void {\n    const visitorSlicing = this.prepareSlices(slicing.slices, slicing);\n\n    if (!isPopulated(visitorSlicing.slices)) {\n      throw new Error(`cannot crawl slice ${slice.name} since it has no type information`);\n    }\n\n    if (this.visitor.onEnterSchema) {\n      this.visitor.onEnterSchema(this.rootSchema);\n    }\n\n    this.sliceAllowList = [slice];\n\n    this.crawlSliceImpl(visitorSlicing.slices[0], slice.path, visitorSlicing);\n    this.sliceAllowList = undefined;\n\n    if (this.visitor.onExitSchema) {\n      this.visitor.onExitSchema(this.rootSchema);\n    }\n  }\n\n  crawlResource(): void {\n    if (this.visitor.onEnterSchema) {\n      this.visitor.onEnterSchema(this.rootSchema);\n    }\n\n    this.crawlElementsImpl(this.rootSchema.elements, this.rootSchema.type);\n\n    if (this.visitor.onExitSchema) {\n      this.visitor.onExitSchema(this.rootSchema);\n    }\n  }\n\n  private crawlElementsImpl(elements: InternalTypeSchema['elements'], path: string): void {\n    const elementTree = createElementTree(elements);\n    for (const node of elementTree) {\n      this.crawlElementNode(node, path);\n    }\n  }\n\n  private crawlElementNode(node: ElementNode, path: string): void {\n    const nodePath = path + '.' + node.key;\n    if (this.visitor.onEnterElement) {\n      this.visitor.onEnterElement(nodePath, node.element, this.elementsContext);\n    }\n\n    for (const child of node.children) {\n      this.crawlElementNode(child, path);\n    }\n\n    if (isPopulated(node.element?.slicing?.slices)) {\n      this.crawlSlicingImpl(node.element.slicing, nodePath);\n    }\n\n    if (this.visitor.onExitElement) {\n      this.visitor.onExitElement(nodePath, node.element, this.elementsContext);\n    }\n  }\n\n  private prepareSlices(slices: SliceDefinition[], slicing: SlicingRules): VisitorSlicingRules {\n    const slicesToVisit: SliceDefinitionWithTypes[] = [];\n    for (const slice of slices) {\n      if (!isSliceDefinitionWithTypes(slice)) {\n        continue;\n      }\n      const profileUrl = slice.type.find((t) => isPopulated(t.profile))?.profile?.[0];\n      if (isPopulated(profileUrl)) {\n        const schema = tryGetProfile(profileUrl);\n        if (schema) {\n          slice.typeSchema = schema;\n        }\n      }\n      slicesToVisit.push(slice);\n    }\n\n    const visitorSlicing = { ...slicing, slices: slicesToVisit } as VisitorSlicingRules;\n    return visitorSlicing;\n  }\n\n  private crawlSlicingImpl(slicing: SlicingRules, path: string): void {\n    const visitorSlicing = this.prepareSlices(slicing.slices, slicing);\n\n    for (const slice of visitorSlicing.slices) {\n      if (this.sliceAllowList === undefined || this.sliceAllowList.includes(slice)) {\n        this.crawlSliceImpl(slice, path, visitorSlicing);\n      }\n    }\n  }\n\n  private crawlSliceImpl(slice: SliceDefinitionWithTypes, path: string, slicing: VisitorSlicingRules): void {\n    const sliceSchema = slice.typeSchema;\n    if (sliceSchema) {\n      if (this.visitor.onEnterSchema) {\n        this.visitor.onEnterSchema(sliceSchema);\n      }\n    }\n\n    if (this.visitor.onEnterSlice) {\n      this.visitor.onEnterSlice(path, slice, slicing);\n    }\n\n    let elementsContext: ElementsContextType | undefined;\n\n    const sliceElements = sliceSchema?.elements ?? slice.elements;\n    if (isPopulated(sliceElements)) {\n      elementsContext = buildElementsContext({\n        path,\n        parentContext: this.elementsContext,\n        elements: sliceElements,\n      });\n    }\n    if (elementsContext) {\n      this.elementsContextStack.push(elementsContext);\n    }\n\n    this.crawlElementsImpl(sliceElements, path);\n\n    if (elementsContext) {\n      this.elementsContextStack.pop();\n    }\n\n    if (this.visitor.onExitSlice) {\n      this.visitor.onExitSlice(path, slice, slicing);\n    }\n\n    if (sliceSchema) {\n      if (this.visitor.onExitSchema) {\n        this.visitor.onExitSchema(sliceSchema);\n      }\n    }\n  }\n}\n\ntype ElementNode = {\n  key: string;\n  element: InternalSchemaElement;\n  children: ElementNode[];\n};\n\n/**\n * Creates a tree of InternalSchemaElements nested by their key hierarchy:\n *\n * @param elements -\n * @returns The list of root nodes of the tree\n */\nfunction createElementTree(elements: Record<string, InternalSchemaElement>): ElementNode[] {\n  const rootNodes: ElementNode[] = [];\n\n  function isChildKey(parentKey: string, childKey: string): boolean {\n    return childKey.startsWith(parentKey + '.');\n  }\n\n  function addNode(currentNode: ElementNode, newNode: ElementNode): void {\n    for (const child of currentNode.children) {\n      // If the new node is a child of an existing child, recurse deeper\n      if (isChildKey(child.key, newNode.key)) {\n        addNode(child, newNode);\n        return;\n      }\n    }\n    // Otherwise, add it here\n    currentNode.children.push(newNode);\n  }\n\n  const elementEntries = Object.entries(elements);\n  /*\n   By sorting beforehand, we guarantee that no false root nodes are created.\n   e.g. if 'a.b' were to be added to the tree before 'a', 'a.b' would be made a\n   root node when it should be a child of 'a'.\n  */\n  elementEntries.sort((a, b) => a[0].localeCompare(b[0]));\n\n  for (const [key, element] of elementEntries) {\n    const newNode: ElementNode = { key, element, children: [] };\n\n    let added = false;\n    for (const rootNode of rootNodes) {\n      if (isChildKey(rootNode.key, key)) {\n        addNode(rootNode, newNode);\n        added = true;\n        break;\n      }\n    }\n\n    // If the string is not a child of any existing node, add it as a new root\n    if (!added) {\n      rootNodes.push(newNode);\n    }\n  }\n\n  return rootNodes;\n}\n", "import { Resource } from '@medplum/fhirtypes';\nimport { ElementsContextType } from './elements-context';\nimport { SchemaCrawler, SchemaVisitor, VisitorSlicingRules } from './schema-crawler';\nimport { SliceDefinitionWithTypes, getValueSliceName } from './typeschema/slices';\nimport { InternalSchemaElement, InternalTypeSchema, SliceDefinition, SlicingRules } from './typeschema/types';\nimport { capitalize, deepClone, getPathDifference, isComplexTypeCode, isEmpty, isObject, isPopulated } from './utils';\n\n/**\n * Used when an array entry, typically an empty one, needs to be assigned\n * to a given slice even though it doesn't match the slice's discriminator.\n */\nconst SLICE_NAME_KEY = '__sliceName';\n\n/**\n * Adds default values to `resource` based on the supplied `schema`. Default values includes all required fixed and pattern\n * values specified on elements in the schema. If an element has a fixed/pattern value but is optional, i.e.\n * `element.min === 0`, the default value is not added.\n *\n * @param resource - The resource to which default values should be added.\n * @param schema - The schema to use for adding default values.\n * @returns A clone of `resource` with default values added.\n */\nexport function applyDefaultValuesToResource(resource: Resource, schema: InternalTypeSchema): Resource {\n  const visitor = new DefaultValueVisitor(resource, resource.resourceType, 'resource');\n  const crawler = new SchemaCrawler(schema, visitor);\n  crawler.crawlResource();\n  return visitor.getDefaultValue();\n}\n\n/**\n * Adds default values to `existingValue` for the given `key` and its children. If `key` is undefined,\n * default values are added to all elements in `elements`. Default values consist of all fixed and pattern\n * values defined in the relevant elements.\n * @param existingValue - The\n * @param elements - The elements to which default values should be added.\n * @param key - (optional) The key of the element(s) for which default values should be added. Elements with nested\n * keys are also included. If undefined, default values for all elements are added.\n * @returns `existingValue` with default values added\n */\nexport function applyDefaultValuesToElement(\n  existingValue: object,\n  elements: Record<string, InternalSchemaElement>,\n  key?: string\n): object {\n  for (const [elementKey, element] of Object.entries(elements)) {\n    if (key === undefined || key === elementKey) {\n      applyFixedOrPatternValue(existingValue, elementKey, element, elements);\n      continue;\n    }\n\n    const keyDifference = getPathDifference(key, elementKey);\n    if (keyDifference !== undefined) {\n      applyFixedOrPatternValue(existingValue, keyDifference, element, elements);\n    }\n  }\n\n  return existingValue;\n}\n\nexport function getDefaultValuesForNewSliceEntry(\n  key: string,\n  slice: SliceDefinition,\n  slicing: SlicingRules,\n  schema: InternalTypeSchema\n): Resource {\n  const visitor = new DefaultValueVisitor([{ [SLICE_NAME_KEY]: slice.name }], slice.path, 'element');\n  const crawler = new SchemaCrawler(schema, visitor);\n  crawler.crawlSlice(key, slice, slicing);\n  return visitor.getDefaultValue()[0];\n}\n\ntype ValueContext = {\n  type: 'resource' | 'element' | 'slice';\n  path: string;\n  values: any[];\n};\n\nclass DefaultValueVisitor implements SchemaVisitor {\n  private readonly rootValue: any;\n  private readonly schemaStack: InternalTypeSchema[];\n  private readonly valueStack: ValueContext[];\n\n  constructor(rootValue: any, path: string, type: ValueContext['type']) {\n    this.schemaStack = [];\n    this.valueStack = [];\n\n    this.rootValue = deepClone(rootValue);\n    this.valueStack.splice(0, this.valueStack.length, {\n      type,\n      path,\n      values: [this.rootValue],\n    });\n  }\n\n  private get schema(): InternalTypeSchema {\n    return this.schemaStack[this.schemaStack.length - 1];\n  }\n\n  private get value(): ValueContext {\n    return this.valueStack[this.valueStack.length - 1];\n  }\n\n  onEnterSchema(schema: InternalTypeSchema): void {\n    this.schemaStack.push(schema);\n  }\n\n  onExitSchema(): void {\n    this.schemaStack.pop();\n  }\n\n  onEnterElement(path: string, element: InternalSchemaElement, elementsContext: ElementsContextType): void {\n    // eld-6: Fixed value may only be specified if there is one type\n    // eld-7: Pattern may only be specified if there is one type\n    // It may be possible to optimize this by checking element.type.length > 1 and short-circuiting\n\n    const parentValues = this.value.values;\n    const parentPath = this.value.path;\n    const key = getPathDifference(parentPath, path);\n    if (key === undefined) {\n      throw new Error(`Expected ${path} to be prefixed by ${parentPath}`);\n    }\n    const elementValues: any[] = [];\n\n    for (const parentValue of parentValues) {\n      if (parentValue === undefined) {\n        continue;\n      }\n\n      const elementsKeyPrefix = getPathDifference(elementsContext.path, parentPath);\n      const parentArray: any[] = Array.isArray(parentValue) ? parentValue : [parentValue];\n      for (const parent of parentArray) {\n        applyMinimums(parent, key, element, elementsContext.elements, elementsKeyPrefix);\n        applyFixedOrPatternValue(parent, key, element, elementsContext.elements);\n        const elementValue = getValueAtKey(parent, key, elementsContext.elements, elementsKeyPrefix);\n        if (elementValue !== undefined) {\n          elementValues.push(elementValue);\n        }\n      }\n    }\n\n    this.valueStack.push({\n      type: 'element',\n      path: path,\n      values: elementValues,\n    });\n  }\n\n  onExitElement(path: string, element: InternalSchemaElement, elementsContext: ElementsContextType): void {\n    const elementValueContext = this.valueStack.pop();\n    if (!elementValueContext) {\n      throw new Error('Expected value context to exist when exiting element');\n    }\n\n    const key = getPathDifference(this.value.path, path);\n    if (key === undefined) {\n      throw new Error(`Expected ${path} to be prefixed by ${this.value.path}`);\n    }\n\n    const elementsKeyPrefix = getPathDifference(elementsContext.path, this.value.path);\n    for (const parentValue of this.value.values) {\n      const elementValue = getValueAtKey(parentValue, key, elementsContext.elements, elementsKeyPrefix);\n\n      // remove empty items from arrays\n      if (Array.isArray(elementValue)) {\n        for (let i = elementValue.length - 1; i >= 0; i--) {\n          const value: any = elementValue[i];\n          if (!isPopulated(value)) {\n            elementValue.splice(i, 1);\n          }\n        }\n      }\n\n      if (isEmpty(elementValue)) {\n        // setting undefined to delete the key\n        setValueAtKey(parentValue, undefined, key, element);\n      }\n    }\n  }\n\n  onEnterSlice(path: string, slice: SliceDefinitionWithTypes, slicing: VisitorSlicingRules): void {\n    const elementValues = this.value.values;\n    const sliceValues: any[] = [];\n\n    for (const value of elementValues) {\n      if (value !== undefined) {\n        const elementValues = Array.isArray(value) ? value : [value];\n        const matchingItems: any[] = this.getMatchingSliceValues(elementValues, slice, slicing);\n        sliceValues.push(matchingItems);\n      }\n    }\n\n    this.valueStack.push({\n      type: 'slice',\n      path,\n      values: sliceValues,\n    });\n  }\n\n  getMatchingSliceValues(elementValue: any[], slice: SliceDefinitionWithTypes, slicing: VisitorSlicingRules): any[] {\n    const matchingItems: any[] = [];\n    for (const arrayItem of elementValue) {\n      const sliceName: string | undefined =\n        arrayItem[SLICE_NAME_KEY] ?? getValueSliceName(arrayItem, [slice], slicing.discriminator, this.schema.url);\n\n      if (sliceName === slice.name) {\n        matchingItems.push(arrayItem);\n      }\n    }\n\n    // Make sure at least slice.min values exist\n    for (let i = matchingItems.length; i < slice.min; i++) {\n      if (isComplexTypeCode(slice.type[0].code)) {\n        const emptySliceValue = Object.create(null);\n        matchingItems.push(emptySliceValue);\n\n        // push onto input array so that it propagates upwards as well\n        elementValue.push(emptySliceValue);\n      }\n    }\n\n    return matchingItems;\n  }\n\n  onExitSlice(): void {\n    const sliceValuesContext = this.valueStack.pop();\n    if (!sliceValuesContext) {\n      throw new Error('Expected value context to exist in onExitSlice');\n    }\n\n    for (const sliceValueArray of sliceValuesContext.values) {\n      for (let i = sliceValueArray.length - 1; i >= 0; i--) {\n        const sliceValue = sliceValueArray[i];\n        if (SLICE_NAME_KEY in sliceValue) {\n          delete sliceValue[SLICE_NAME_KEY];\n        }\n      }\n    }\n  }\n\n  getDefaultValue(): any {\n    return this.rootValue;\n  }\n}\n\nfunction applyMinimums(\n  parent: any,\n  key: string,\n  element: InternalSchemaElement,\n  elements: Record<string, InternalSchemaElement>,\n  /** The prefix, if any, that should be added to keys when looking up values in `elements` */\n  elementsKeyPrefix: string | undefined\n): void {\n  const existingValue = getValueAtKey(parent, key, elements, elementsKeyPrefix);\n\n  if (element.min > 0 && existingValue === undefined) {\n    if (isComplexTypeCode(element.type[0].code)) {\n      if (element.isArray) {\n        setValueAtKey(parent, [Object.create(null)], key, element);\n      } else {\n        setValueAtKey(parent, Object.create(null), key, element);\n      }\n    }\n  }\n}\n\nfunction setValueAtKey(parent: any, value: any, key: string, element: InternalSchemaElement): void {\n  if (key.includes('.')) {\n    throw new Error('key cannot be nested');\n  }\n\n  let resolvedKey = key;\n\n  if (key.includes('[x]')) {\n    const code = element.type[0].code;\n    resolvedKey = key.replace('[x]', capitalize(code));\n  }\n\n  if (value === undefined) {\n    delete parent[resolvedKey];\n  } else {\n    parent[resolvedKey] = value;\n  }\n}\n\nfunction getValueAtKey(\n  value: object,\n  key: string,\n  elements: Record<string, InternalSchemaElement>,\n  /** The prefix, if any, that should be added to keys when looking up values in `elements` */\n  elementsKeyPrefix: string | undefined\n): any {\n  const keyParts = key.split('.');\n  let last: any = value;\n  let answer: any;\n  for (let i = 0; i < keyParts.length; i++) {\n    let keyPart = keyParts[i];\n    if (keyPart.includes('[x]')) {\n      const key = (elementsKeyPrefix ? elementsKeyPrefix + '.' : '') + keyParts.slice(0, i + 1).join('.');\n      const keyPartElem = elements[key];\n\n      // this should loop through all possible types instead of using type[0]\n      const code = keyPartElem.type[0].code;\n      keyPart = keyPart.replace('[x]', capitalize(code));\n    }\n\n    // final key part\n    if (i === keyParts.length - 1) {\n      if (Array.isArray(last)) {\n        answer = last.map((item) => item[keyPart]);\n      } else {\n        answer = last[keyPart];\n      }\n      continue;\n    }\n\n    // intermediate key part\n    if (Array.isArray(last)) {\n      last = last.map((lastItem) => lastItem[keyPart]);\n    } else if (isObject(last)) {\n      if (last[keyPart] === undefined) {\n        return undefined;\n      }\n      last = last[keyPart];\n    } else {\n      return undefined;\n    }\n  }\n\n  return answer;\n}\n\nexport function applyFixedOrPatternValue(\n  inputValue: any,\n  key: string,\n  element: InternalSchemaElement,\n  elements: Record<string, InternalSchemaElement>\n): any {\n  if (!(element.fixed || element.pattern)) {\n    return inputValue;\n  }\n\n  if (Array.isArray(inputValue)) {\n    return inputValue.map((iv) => applyFixedOrPatternValue(iv, key, element, elements));\n  }\n\n  if (inputValue === undefined || inputValue === null) {\n    inputValue = Object.create(null);\n  }\n\n  const outputValue = inputValue;\n\n  const keyParts = key.split('.');\n  let last: any = outputValue;\n  for (let i = 0; i < keyParts.length; i++) {\n    let keyPart = keyParts[i];\n    if (keyPart.includes('[x]')) {\n      const keyPartElem = elements[keyParts.slice(0, i + 1).join('.')];\n      const code = keyPartElem.type[0].code;\n      keyPart = keyPart.replace('[x]', capitalize(code));\n    }\n\n    if (i === keyParts.length - 1) {\n      const lastArray = Array.isArray(last) ? last : [last];\n      for (const item of lastArray) {\n        if (element.fixed) {\n          item[keyPart] ??= element.fixed.value;\n        } else if (element.pattern) {\n          item[keyPart] = applyPattern(item[keyPart], element.pattern.value);\n        }\n      }\n    } else {\n      if (!(keyPart in last)) {\n        const elementKey = keyParts.slice(0, i + 1).join('.');\n        last[keyPart] = elements[elementKey].isArray ? [Object.create(null)] : Object.create(null);\n      }\n      last = last[keyPart];\n    }\n  }\n  return outputValue;\n}\n\nfunction applyPattern(existingValue: any, pattern: any): any {\n  if (Array.isArray(pattern) && (Array.isArray(existingValue) || existingValue === undefined)) {\n    if ((existingValue?.length ?? 0) > 0) {\n      // Cannot yet apply a pattern to a non-empty array since that would require considering cardinality and slicing\n      return existingValue;\n    }\n    return deepClone(pattern);\n  } else if (isObject(pattern)) {\n    if ((isObject(existingValue) && !Array.isArray(existingValue)) || existingValue === undefined) {\n      const resultObj = (deepClone(existingValue) ?? Object.create(null)) as { [key: string]: any };\n      for (const key of Object.keys(pattern)) {\n        resultObj[key] = applyPattern(resultObj[key], pattern[key]);\n      }\n      return resultObj;\n    }\n  }\n\n  return existingValue;\n}\n", "import { CodeableConcept, Coding, ConceptMap, ConceptMapGroup, OperationOutcome } from '@medplum/fhirtypes';\nimport { OperationOutcomeError, badRequest, isOperationOutcome } from '../outcomes';\n\nexport interface ConceptMapTranslateParameters {\n  url?: string;\n  source?: string;\n  code?: string;\n  system?: string;\n  coding?: Coding;\n  codeableConcept?: CodeableConcept;\n  targetsystem?: string;\n}\n\nexport interface ConceptMapTranslateMatch {\n  equivalence?: string;\n  concept?: Coding;\n}\n\nexport interface ConceptMapTranslateOutput {\n  result: boolean;\n  message?: string;\n  match?: ConceptMapTranslateMatch[];\n}\n\nexport function conceptMapTranslate(map: ConceptMap, params: ConceptMapTranslateParameters): ConceptMapTranslateOutput {\n  if (!map.group) {\n    throw new OperationOutcomeError(badRequest('ConceptMap does not specify a mapping group', 'ConceptMap.group'));\n  }\n\n  const sourceCodes = constructSourceSet(params);\n  if (isOperationOutcome(sourceCodes)) {\n    throw new OperationOutcomeError(sourceCodes);\n  }\n\n  const matches = translateCodes(\n    sourceCodes,\n    params.targetsystem ? map.group.filter((g) => g.target === params.targetsystem) : map.group\n  );\n\n  const result = matches.length > 0;\n\n  return {\n    result,\n    match: result ? matches : undefined,\n  };\n}\n\nfunction constructSourceSet(params: ConceptMapTranslateParameters): Record<string, string[]> | OperationOutcome {\n  if (params.code && !params.coding && !params.codeableConcept) {\n    if (params.system === undefined) {\n      return badRequest(`Missing required 'system' input parameter with 'code' parameter`);\n    }\n    return { [params.system]: [params.code] };\n  } else if (params.coding && !params.code && !params.codeableConcept) {\n    return { [params.coding.system ?? '']: [params.coding.code ?? ''] };\n  } else if (params.codeableConcept && !params.code && !params.coding) {\n    return indexCodes(params.codeableConcept);\n  } else if (params.code || params.coding || params.codeableConcept) {\n    return badRequest('Ambiguous input: multiple source codings provided');\n  } else {\n    return badRequest(\n      `No source provided: 'code'+'system', 'coding', or 'codeableConcept' input parameter is required`\n    );\n  }\n}\n\nfunction indexCodes(concept: CodeableConcept): Record<string, string[]> {\n  const result: Record<string, string[]> = Object.create(null);\n  if (!concept.coding?.length) {\n    return result;\n  }\n\n  for (const { system, code } of concept.coding) {\n    if (!code) {\n      continue;\n    }\n    const key = system ?? '';\n    result[key] = result[key] ? [...result[key], code] : [code];\n  }\n  return result;\n}\n\nfunction translateCodes(sourceCodes: Record<string, string[]>, groups: ConceptMapGroup[]): ConceptMapTranslateMatch[] {\n  const matches: ConceptMapTranslateMatch[] = [];\n  for (const [system, codes] of Object.entries(sourceCodes)) {\n    for (const group of groups.filter((g) => (g.source ?? '') === system)) {\n      let mappings: ConceptMapTranslateMatch[] | undefined = group.element\n        ?.filter((m) => codes.includes(m.code as string))\n        .flatMap(\n          (m) =>\n            m.target?.map((target) => ({\n              equivalence: target.equivalence,\n              concept: {\n                system: group.target,\n                code: target.code,\n                display: target.display,\n              },\n            })) ?? []\n        );\n\n      if (!mappings?.length) {\n        mappings = handleUnmappedCodes(codes, group);\n      }\n      if (mappings) {\n        matches.push(...mappings);\n      }\n    }\n  }\n  return matches;\n}\n\nfunction handleUnmappedCodes(codes: string[], group: ConceptMapGroup): ConceptMapTranslateMatch[] | undefined {\n  switch (group.unmapped?.mode) {\n    case 'provided':\n      return codes.map((code) => ({\n        equivalence: 'equal',\n        concept: { system: group.target, code },\n      }));\n    case 'fixed':\n      return [\n        {\n          equivalence: 'equivalent',\n          concept: {\n            system: group.target,\n            code: group.unmapped.code,\n            display: group.unmapped.display,\n          },\n        },\n      ];\n    default:\n      return undefined;\n  }\n}\n", "import { Token, Tokenizer } from '../fhirlexer/tokenize';\nimport { FHIRPATH_KEYWORDS, FHIRPATH_OPERATORS } from '../fhirpath/tokenize';\n\nconst MAPPING_LANGUAGE_OPERATORS = [...FHIRPATH_OPERATORS, '->', '<<', '>>', '=='];\n\nexport function tokenize(str: string): Token[] {\n  return new Tokenizer(str, FHIRPATH_KEYWORDS, MAPPING_LANGUAGE_OPERATORS).tokenize();\n}\n", "import {\n  ConceptMap,\n  StructureMap,\n  StructureMapGroup,\n  StructureMapGroupInput,\n  StructureMapGroupRule,\n  StructureMapGroupRuleDependent,\n  StructureMapGroupRuleSource,\n  StructureMapGroupRuleTarget,\n  StructureMapGroupRuleTargetParameter,\n  StructureMapStructure,\n} from '@medplum/fhirtypes';\nimport { Atom, Parser } from '../fhirlexer/parse';\nimport { FunctionAtom, LiteralAtom, SymbolAtom } from '../fhirpath/atoms';\nimport { OperatorPrecedence, initFhirPathParserBuilder } from '../fhirpath/parse';\nimport { tokenize } from './tokenize';\n\n/**\n * Mapping from FHIR Mapping Language equivalence operators to FHIR ConceptMap equivalence codes.\n *\n * See: https://build.fhir.org/mapping.g4 for FHIR Mapping Language operators.\n *\n * See: https://hl7.org/fhir/r4/valueset-concept-map-equivalence.html for ConceptMap equivalence codes.\n *\n * @internal\n */\nconst CONCEPT_MAP_EQUIVALENCE: Record<string, string> = {\n  '-': 'disjoint',\n  '==': 'equal',\n};\n\nclass StructureMapParser {\n  readonly parser: Parser;\n  readonly structureMap: Partial<StructureMap> = {\n    resourceType: 'StructureMap',\n    status: 'active',\n  };\n\n  constructor(parser: Parser) {\n    this.parser = parser;\n  }\n\n  parse(): StructureMap {\n    while (this.parser.hasMore()) {\n      const next = this.parser.peek()?.value;\n      switch (next) {\n        case 'map':\n          this.parseMap();\n          break;\n        case 'uses':\n          this.parseUses();\n          break;\n        case 'imports':\n          this.parseImport();\n          break;\n        case 'group':\n          this.parseGroup();\n          break;\n        case 'conceptmap':\n          this.parseConceptMap();\n          break;\n        default:\n          throw new Error(`Unexpected token: ${next}`);\n      }\n    }\n    return this.structureMap as StructureMap;\n  }\n\n  private parseMap(): void {\n    // 'map' url '=' identifier\n    // map \"http://hl7.org/fhir/StructureMap/tutorial\" = tutorial\n    this.parser.consume('Symbol', 'map');\n    this.structureMap.url = this.parser.consume('String').value;\n    this.parser.consume('=');\n    this.structureMap.name = this.parser.consume().value;\n  }\n\n  private parseUses(): void {\n    // 'uses' url structureAlias? 'as' modelMode\n    // uses \"http://hl7.org/fhir/StructureDefinition/tutorial-left\" as source\n    this.parser.consume('Symbol', 'uses');\n    const result: Partial<StructureMapStructure> = {};\n    result.url = this.parser.consume('String').value;\n    if (this.parser.peek()?.value === 'alias') {\n      this.parser.consume('Symbol', 'alias');\n      result.alias = this.parser.consume('Symbol').value;\n    }\n    this.parser.consume('Symbol', 'as');\n    result.mode = this.parser.consume().value as 'source' | 'queried' | 'target' | 'produced';\n    if (!this.structureMap.structure) {\n      this.structureMap.structure = [];\n    }\n    this.structureMap.structure.push(result as StructureMapStructure);\n  }\n\n  private parseImport(): void {\n    this.parser.consume('Symbol', 'imports');\n    if (!this.structureMap.import) {\n      this.structureMap.import = [];\n    }\n    this.structureMap.import.push(this.parser.consume('String').value);\n  }\n\n  private parseGroup(): void {\n    // 'group' identifier parameters extends? typeMode? rules\n    // group tutorial(source src : TLeft, target tgt : TRight) {\n    const result: Partial<StructureMapGroup> = {};\n    this.parser.consume('Symbol', 'group');\n    result.name = this.parser.consume('Symbol').value;\n    result.input = this.parseParameters();\n\n    if (this.parser.peek()?.value === 'extends') {\n      this.parser.consume('Symbol', 'extends');\n      result.extends = this.parser.consume('Symbol').value;\n    }\n\n    if (this.parser.peek()?.value === '<<') {\n      this.parser.consume('<<');\n      result.typeMode = this.parser.consume().value as 'none' | 'types' | 'type-and-types';\n      if (this.parser.peek()?.value === '+') {\n        this.parser.consume('+');\n        result.typeMode = 'type-and-types';\n      }\n      this.parser.consume('>>');\n    } else {\n      result.typeMode = 'none';\n    }\n\n    result.rule = this.parseRules();\n\n    if (!this.structureMap.group) {\n      this.structureMap.group = [];\n    }\n    this.structureMap.group.push(result as StructureMapGroup);\n  }\n\n  private parseParameters(): StructureMapGroupInput[] {\n    const parameters: StructureMapGroupInput[] = [];\n    this.parser.consume('(');\n    while (this.parser.hasMore() && this.parser.peek()?.value !== ')') {\n      parameters.push(this.parseParameter());\n      if (this.parser.peek()?.value === ',') {\n        this.parser.consume(',');\n      }\n    }\n    this.parser.consume(')');\n    return parameters;\n  }\n\n  private parseParameter(): StructureMapGroupInput {\n    // inputMode identifier type?\n    // ':' identifier\n    // source src : TLeft\n    const result: Partial<StructureMapGroupInput> = {};\n    result.mode = this.parser.consume().value as 'source' | 'target';\n    result.name = this.parser.consume('Symbol').value;\n    if (this.parser.peek()?.value === ':') {\n      this.parser.consume(':');\n      result.type = this.parser.consume('Symbol').value;\n    }\n    return result as StructureMapGroupInput;\n  }\n\n  private parseRules(): StructureMapGroupRule[] {\n    const rules = [];\n    this.parser.consume('{');\n    while (this.parser.hasMore() && this.parser.peek()?.value !== '}') {\n      rules.push(this.parseRule());\n    }\n    this.parser.consume('}');\n    return rules;\n  }\n\n  private parseRule(): StructureMapGroupRule {\n    const result: Partial<StructureMapGroupRule> = {\n      source: this.parseRuleSources(),\n    };\n\n    if (this.parser.peek()?.value === '->') {\n      this.parser.consume('->');\n      result.target = this.parseRuleTargets();\n    }\n\n    if (this.parser.peek()?.value === 'then') {\n      this.parser.consume('Symbol', 'then');\n      if (this.parser.peek()?.id === '{') {\n        result.rule = this.parseRules();\n      } else {\n        result.dependent = this.parseRuleDependents();\n      }\n    }\n\n    if (this.parser.peek()?.id === 'String') {\n      result.name = this.parser.consume().value;\n    } else {\n      result.name = result.source?.[0]?.element;\n    }\n\n    this.parser.consume(';');\n    return result as StructureMapGroupRule;\n  }\n\n  private parseRuleSources(): StructureMapGroupRuleSource[] {\n    if (this.parser.hasMore() && this.parser.peek()?.value === 'for') {\n      // The \"for\" keyword is optional\n      // It is not in the official grammar: https://build.fhir.org/mapping.g4\n      // But it is used in the examples: https://build.fhir.org/mapping-tutorial.html\n      this.parser.consume('Symbol', 'for');\n    }\n    const sources = [this.parseRuleSource()];\n    while (this.parser.hasMore() && this.parser.peek()?.value === ',') {\n      this.parser.consume(',');\n      sources.push(this.parseRuleSource());\n    }\n    return sources;\n  }\n\n  private parseRuleSource(): StructureMapGroupRuleSource {\n    const result: Partial<StructureMapGroupRuleSource> = {};\n\n    const context = this.parseRuleContext();\n    const parts = context.split('.');\n    result.context = parts[0];\n    result.element = parts[1];\n\n    if (this.parser.hasMore() && this.parser.peek()?.value === ':') {\n      this.parser.consume(':');\n      result.type = this.parser.consume().value;\n    }\n\n    if (this.parser.hasMore() && this.parser.peek()?.value === 'default') {\n      this.parser.consume('Symbol', 'default');\n      result.defaultValueString = this.parser.consume('String').value;\n    }\n\n    if (\n      this.parser.peek()?.value === 'first' ||\n      this.parser.peek()?.value === 'not_first' ||\n      this.parser.peek()?.value === 'last' ||\n      this.parser.peek()?.value === 'not_last' ||\n      this.parser.peek()?.value === 'only_one'\n    ) {\n      result.listMode = this.parser.consume().value as 'first' | 'not_first' | 'last' | 'not_last' | 'only_one';\n    }\n\n    if (this.parser.peek()?.value === 'as') {\n      this.parser.consume('Symbol', 'as');\n      result.variable = this.parser.consume().value;\n    }\n\n    if (this.parser.peek()?.value === 'log') {\n      this.parser.consume('Symbol', 'log');\n      result.logMessage = this.parser.consume().value;\n    }\n\n    if (this.parser.peek()?.value === 'where') {\n      this.parser.consume('Symbol', 'where');\n      const whereFhirPath = this.parser.consumeAndParse(OperatorPrecedence.Arrow);\n      result.condition = whereFhirPath.toString();\n    }\n\n    if (this.parser.peek()?.value === 'check') {\n      this.parser.consume('Symbol', 'check');\n      const checkFhirPath = this.parser.consumeAndParse(OperatorPrecedence.Arrow);\n      result.check = checkFhirPath.toString();\n    }\n\n    return result as StructureMapGroupRuleSource;\n  }\n\n  private parseRuleTargets(): StructureMapGroupRuleTarget[] {\n    const targets = [this.parseRuleTarget()];\n    while (this.parser.hasMore() && this.parser.peek()?.value === ',') {\n      this.parser.consume(',');\n      targets.push(this.parseRuleTarget());\n    }\n    return targets;\n  }\n\n  private parseRuleTarget(): StructureMapGroupRuleTarget {\n    const result: StructureMapGroupRuleTarget = {};\n\n    const context = this.parseRuleContext();\n    const parts = context.split('.');\n    result.contextType = 'variable';\n    result.context = parts[0];\n    result.element = parts[1];\n\n    if (this.parser.peek()?.value === '=') {\n      this.parser.consume('=');\n      this.parseRuleTargetTransform(result);\n    }\n\n    if (this.parser.peek()?.value === 'as') {\n      this.parser.consume('Symbol', 'as');\n      result.variable = this.parser.consume().value;\n    }\n\n    if (this.parser.peek()?.value === 'share') {\n      this.parser.consume('Symbol', 'share');\n      result.listMode = ['share'];\n      this.parser.consume('Symbol'); // NB: Not in the spec, but used by FHIRCH maps\n    }\n\n    if (\n      this.parser.peek()?.value === 'first' ||\n      this.parser.peek()?.value === 'last' ||\n      this.parser.peek()?.value === 'collate'\n    ) {\n      result.listMode = [this.parser.consume().value as 'first' | 'last' | 'collate'];\n    }\n\n    return result;\n  }\n\n  private parseRuleTargetTransform(result: StructureMapGroupRuleTarget): void {\n    const transformAtom = this.parser.consumeAndParse(OperatorPrecedence.As);\n    if (transformAtom instanceof FunctionAtom) {\n      result.transform = transformAtom.name as 'append' | 'truncate';\n      result.parameter = transformAtom.args?.map(atomToParameter);\n    } else if (transformAtom instanceof LiteralAtom || transformAtom instanceof SymbolAtom) {\n      result.transform = 'copy';\n      result.parameter = [atomToParameter(transformAtom)];\n    } else {\n      result.transform = 'evaluate';\n      result.parameter = [{ valueString: transformAtom.toString() }];\n    }\n  }\n\n  private parseRuleContext(): string {\n    let identifier = this.parser.consume().value;\n    while (this.parser.peek()?.value === '.') {\n      this.parser.consume('.');\n      identifier += '.' + this.parser.consume().value;\n    }\n    return identifier;\n  }\n\n  private parseRuleDependents(): StructureMapGroupRuleDependent[] | undefined {\n    const atom = this.parser.consumeAndParse(OperatorPrecedence.Arrow) as FunctionAtom;\n    return [\n      {\n        name: atom.name,\n        variable: atom.args.map((arg) => (arg as SymbolAtom).name),\n      },\n    ];\n  }\n\n  private parseConceptMap(): void {\n    this.parser.consume('Symbol', 'conceptmap');\n\n    const conceptMap: ConceptMap = {\n      resourceType: 'ConceptMap',\n      status: 'active',\n      url: '#' + this.parser.consume('String').value,\n    };\n\n    this.parser.consume('{');\n\n    const prefixes: Record<string, string> = {};\n\n    let next = this.parser.peek()?.value;\n    while (next !== '}') {\n      if (next === 'prefix') {\n        this.parseConceptMapPrefix(prefixes);\n      } else {\n        this.parseConceptMapRule(conceptMap, prefixes);\n      }\n      next = this.parser.peek()?.value;\n    }\n    this.parser.consume('}');\n\n    if (!this.structureMap.contained) {\n      this.structureMap.contained = [];\n    }\n    this.structureMap.contained.push(conceptMap as ConceptMap);\n  }\n\n  private parseConceptMapPrefix(prefixes: Record<string, string>): void {\n    this.parser.consume('Symbol', 'prefix');\n    const prefix = this.parser.consume().value;\n    this.parser.consume('=');\n    const uri = this.parser.consume().value;\n    prefixes[prefix] = uri;\n  }\n\n  private parseConceptMapRule(conceptMap: Partial<ConceptMap>, prefixes: Record<string, string>): void {\n    const sourcePrefix = this.parser.consume().value;\n    const sourceSystem = prefixes[sourcePrefix];\n    this.parser.consume(':');\n    const sourceCode = this.parser.consume().value;\n    const equivalence = CONCEPT_MAP_EQUIVALENCE[this.parser.consume().value] as 'relatedto';\n    const targetPrefix = this.parser.consume().value;\n    const targetSystem = prefixes[targetPrefix];\n    this.parser.consume(':');\n    const targetCode = this.parser.consume().value;\n\n    let group = conceptMap?.group?.find((g) => g.source === sourceSystem && g.target === targetSystem);\n\n    if (!group) {\n      group = { source: sourceSystem, target: targetSystem, element: [] };\n      if (!conceptMap.group) {\n        conceptMap.group = [];\n      }\n      conceptMap.group.push(group);\n    }\n\n    if (!group.element) {\n      group.element = [];\n    }\n\n    group.element.push({\n      code: sourceCode,\n      target: [{ code: targetCode, equivalence }],\n    });\n  }\n}\n\nfunction atomToParameter(atom: Atom): StructureMapGroupRuleTargetParameter {\n  if (atom instanceof SymbolAtom) {\n    return { valueId: atom.name };\n  }\n  if (atom instanceof LiteralAtom) {\n    return literalToParameter(atom);\n  }\n  throw new Error(`Unknown parameter atom type: ${atom.constructor.name} (${atom.toString()})`);\n}\n\nfunction literalToParameter(literalAtom: LiteralAtom): StructureMapGroupRuleTargetParameter {\n  switch (literalAtom.value.type) {\n    case 'boolean':\n      return { valueBoolean: literalAtom.value.value as boolean };\n    case 'decimal':\n      return { valueDecimal: literalAtom.value.value as number };\n    case 'integer':\n      return { valueInteger: literalAtom.value.value as number };\n    case 'dateTime':\n    case 'string':\n      return { valueString: literalAtom.value.value as string };\n    default:\n      throw new Error('Unknown target literal type: ' + literalAtom.value.type);\n  }\n}\n\nconst fhirPathParserBuilder = initFhirPathParserBuilder()\n  .registerInfix('->', { precedence: OperatorPrecedence.Arrow })\n  .registerInfix(';', { precedence: OperatorPrecedence.Semicolon });\n\n/**\n * Parses a FHIR Mapping Language document into an AST.\n * @param input - The FHIR Mapping Language document to parse.\n * @returns The AST representing the document.\n */\nexport function parseMappingLanguage(input: string): StructureMap {\n  const parser = fhirPathParserBuilder.construct(tokenize(input));\n  parser.removeComments();\n  return new StructureMapParser(parser).parse();\n}\n", "import {\n  ConceptMap,\n  ExtractResource,\n  ResourceType,\n  StructureMap,\n  StructureMapGroup,\n  StructureMapGroupInput,\n  StructureMapGroupRule,\n  StructureMapGroupRuleDependent,\n  StructureMapGroupRuleSource,\n  StructureMapGroupRuleTarget,\n  StructureMapGroupRuleTargetParameter,\n} from '@medplum/fhirtypes';\nimport { generateId } from '../crypto';\nimport { evalFhirPathTyped } from '../fhirpath/parse';\nimport { getTypedPropertyValue, toJsBoolean, toTypedValue } from '../fhirpath/utils';\nimport { TypedValue } from '../types';\nimport { InternalSchemaElement, tryGetDataType } from '../typeschema/types';\nimport { conceptMapTranslate } from './conceptmaptranslate';\n\n/**\n * The TransformMapCollection class is a collection of StructureMap and ConceptMap resources.\n * It is used to store and retrieve imported StructureMaps and ConceptMaps by URL.\n */\nexport class TransformMapCollection {\n  readonly resources: (StructureMap | ConceptMap)[];\n\n  constructor(resources: (StructureMap | ConceptMap)[] = []) {\n    this.resources = resources;\n  }\n\n  get<K extends ResourceType>(resourceType: K, url: string): ExtractResource<K>[] {\n    const result = [];\n    for (const r of this.resources) {\n      if (r.resourceType === resourceType && r.url && this.matchesUrl(r.url as string, url)) {\n        result.push(r);\n      }\n    }\n    return result as ExtractResource<K>[];\n  }\n\n  private matchesUrl(url: string, pattern: string): boolean {\n    if (pattern.includes('*')) {\n      const parts = pattern.split('*');\n      return url.startsWith(parts[0]) && url.endsWith(parts[1]);\n    } else {\n      return url === pattern;\n    }\n  }\n}\n\ninterface TransformContext {\n  root: StructureMap;\n  transformMaps?: TransformMapCollection;\n  parent?: TransformContext;\n  variables?: Record<string, TypedValue[] | TypedValue>;\n}\n\n/**\n * Transforms input values using a FHIR StructureMap.\n *\n * See: https://www.hl7.org/fhir/mapping-language.html\n *\n * @param structureMap - The StructureMap to transform.\n * @param input - The input values.\n * @param transformMaps - Optional collection of imported StructureMaps and ConceptMaps.\n * @returns The transformed values.\n */\nexport function structureMapTransform(\n  structureMap: StructureMap,\n  input: TypedValue[],\n  transformMaps = new TransformMapCollection()\n): TypedValue[] {\n  return evalStructureMap({ root: structureMap, transformMaps }, structureMap, input);\n}\n\n/**\n * Evaluates a FHIR StructureMap.\n *\n * @param ctx - The transform context.\n * @param structureMap - The FHIR StructureMap definition.\n * @param input - The input values.\n * @returns The transformed values.\n * @internal\n */\nfunction evalStructureMap(ctx: TransformContext, structureMap: StructureMap, input: TypedValue[]): TypedValue[] {\n  evalImports(ctx, structureMap);\n  registerGlobals(ctx, structureMap);\n  return evalGroup(ctx, structureMap.group[0], input);\n}\n\n/**\n * Evaluates the imports in a FHIR StructureMap.\n * For each import statement, the loader function is called to load the imported StructureMap.\n * The imported StructureMap is then hoisted into the current context.\n * @param ctx - The transform context.\n * @param structureMap - The FHIR StructureMap definition.\n * @internal\n */\nfunction evalImports(ctx: TransformContext, structureMap: StructureMap): void {\n  const transformMaps = getTransformMaps(ctx);\n  if (transformMaps && structureMap.import) {\n    for (const url of structureMap.import) {\n      const importedMaps = transformMaps.get('StructureMap', url);\n      for (const importedMap of importedMaps) {\n        registerGlobals(ctx, importedMap);\n      }\n    }\n  }\n}\n\n/**\n * Registers all globals in a FHIR StructureMap into the current context.\n * Adds all contained StructureMaps and ConceptMaps to the map collection.\n * Hoists the groups in a FHIR StructureMap into the current context.\n * This is necessary to allow groups to reference each other.\n *\n * @param ctx - The transform context.\n * @param structureMap - The FHIR StructureMap definition.\n * @internal\n */\nfunction registerGlobals(ctx: TransformContext, structureMap: StructureMap): void {\n  const transformMaps = getTransformMaps(ctx);\n  if (transformMaps && structureMap.contained) {\n    for (const c of structureMap.contained) {\n      if (c.resourceType === 'StructureMap' || c.resourceType === 'ConceptMap') {\n        transformMaps.resources.push(c);\n      }\n    }\n  }\n\n  if (structureMap.group) {\n    for (const group of structureMap.group) {\n      setVariable(ctx, group.name as string, { type: 'StructureMapGroup', value: group });\n    }\n  }\n}\n\n/**\n * Evaluates a FHIR StructureMapGroup.\n *\n * A \"group\" is similar to a function in a programming language.\n *\n * @param ctx - The transform context.\n * @param group - The FHIR StructureMapGroup definition.\n * @param input - The input values.\n * @returns The transformed values.\n * @internal\n */\nfunction evalGroup(ctx: TransformContext, group: StructureMapGroup, input: TypedValue[]): TypedValue[] {\n  const sourceDefinitions: StructureMapGroupInput[] = [];\n  const targetDefinitions: StructureMapGroupInput[] = [];\n\n  for (const inputDefinition of group.input as StructureMapGroupInput[]) {\n    if (inputDefinition.mode === 'source') {\n      sourceDefinitions.push(inputDefinition);\n    }\n    if (inputDefinition.mode === 'target') {\n      targetDefinitions.push(inputDefinition);\n    }\n  }\n\n  if (sourceDefinitions.length === 0) {\n    throw new Error('Missing source definitions');\n  }\n\n  if (targetDefinitions.length === 0) {\n    throw new Error('Missing target definitions');\n  }\n\n  if (input.length < sourceDefinitions.length) {\n    throw new Error(`Not enough arguments (got ${input.length}, min ${sourceDefinitions.length})`);\n  }\n\n  if (input.length > sourceDefinitions.length + targetDefinitions.length) {\n    throw new Error(\n      `Too many arguments (got ${input.length}, max ${sourceDefinitions.length + targetDefinitions.length})`\n    );\n  }\n\n  const variables: Record<string, TypedValue> = {};\n  const outputs = [];\n  let inputIndex = 0;\n\n  for (const sourceDefinition of sourceDefinitions) {\n    safeAssign(variables, sourceDefinition.name as string, input[inputIndex++]);\n  }\n\n  for (const targetDefinition of targetDefinitions) {\n    const output = input[inputIndex++] ?? { type: targetDefinition.type ?? 'BackboneElement', value: {} };\n    safeAssign(variables, targetDefinition.name as string, output);\n    outputs.push(output);\n  }\n\n  const newContext: TransformContext = { root: ctx.root, parent: ctx, variables };\n\n  if (group.rule) {\n    for (const rule of group.rule) {\n      evalRule(newContext, rule);\n    }\n  }\n\n  return outputs;\n}\n\n/**\n * Entry point for evaluating a rule.\n * Rule sources are evaluated first, followed by the rule target, child rules, and dependent groups.\n * Rule sources are evaluated recursively to handle multiple source statements.\n *\n * @param ctx - The transform context.\n * @param rule - The FHIR Mapping rule definition.\n * @internal\n */\nfunction evalRule(ctx: TransformContext, rule: StructureMapGroupRule): void {\n  // https://build.fhir.org/mapping-language.html#7.8.0.8.1\n  // If there are multiple source statements, the rule applies for the permutation of the source elements from each source statement.\n  // E.g. if there are 2 source statements, each with 2 matching elements, the rule applies 4 times, one for each combination.\n  // Typically, if there is more than one source statement, only one of the elements would repeat.\n  // If any of the source data elements have no value, then the rule never applies;\n  // only existing permutations are executed: for multiple source statements, all of them need to match.\n  if (rule.source) {\n    evalRuleSourceAt(ctx, rule, 0);\n  }\n}\n\n/**\n * Recursively evaluates a rule at a specific source index.\n *\n * @param ctx - The transform context.\n * @param rule - The FHIR Mapping rule definition.\n * @param index - The source index to evaluate.\n * @internal\n */\nfunction evalRuleSourceAt(\n  ctx: TransformContext,\n  rule: StructureMapGroupRule & { source: StructureMapGroupRuleSource[] },\n  index: number\n): void {\n  const source = rule.source[index];\n  for (const sourceValue of evalSource(ctx, source)) {\n    setVariable(ctx, '_', sourceValue);\n\n    if (source.variable) {\n      setVariable(ctx, source.variable, sourceValue);\n    }\n\n    if (index < rule.source.length - 1) {\n      // If there are more sources, evaluate the next source\n      evalRuleSourceAt(ctx, rule, index + 1);\n    } else {\n      // Otherwise, evaluate the rule after the sources\n      evalRuleAfterSources(ctx, rule);\n    }\n  }\n}\n\n/**\n * Evaluates a rule after the sources have been evaluated.\n *\n * This includes the rule targets, child rules, and dependent groups.\n *\n * @param ctx - The transform context.\n * @param rule - The FHIR Mapping rule definition.\n * @internal\n */\nfunction evalRuleAfterSources(ctx: TransformContext, rule: StructureMapGroupRule): void {\n  if (tryEvalShorthandRule(ctx, rule)) {\n    return;\n  }\n  if (rule.target) {\n    for (const target of rule.target) {\n      evalTarget(ctx, target);\n    }\n  }\n  if (rule.rule) {\n    for (const childRule of rule.rule) {\n      evalRule(ctx, childRule);\n    }\n  }\n  if (rule.dependent) {\n    for (const dependent of rule.dependent) {\n      evalDependent(ctx, dependent);\n    }\n  }\n}\n\n/**\n * Tries to evaluate a shorthand rule.\n * @param ctx - The transform context.\n * @param rule - The FHIR Mapping rule definition.\n * @returns True if the rule is a shorthand rule, false otherwise.\n */\nfunction tryEvalShorthandRule(ctx: TransformContext, rule: StructureMapGroupRule): boolean {\n  // First, check if this is actually a shorthand rule\n  // Shorthand rule has exactly one target, no transform, no rule, and no dependent\n  if (!rule.target || rule.target.length !== 1 || rule.target[0].transform || rule.rule || rule.dependent) {\n    return false;\n  }\n\n  // Determine the source value\n  let sourceValue = getVariable(ctx, '_');\n  if (Array.isArray(sourceValue)) {\n    sourceValue = sourceValue[0];\n  }\n  if (!sourceValue) {\n    return false;\n  }\n\n  // Ok, this is a shorthand rule.\n  // Next, try to find a \"types\" group that matches the input and output types\n  const group = tryFindTypesGroup(ctx, sourceValue);\n  if (!group) {\n    // No group found, fallback to simple copy transform\n    // This is commonly used for primitive types such as \"string\" and \"code\"\n    evalTarget(ctx, { ...rule.target[0], transform: 'copy', parameter: [{ valueId: '_' }] });\n    return true;\n  }\n\n  const target = rule.target[0];\n  const targetContext = getVariable(ctx, target.context as string) as TypedValue;\n  const originalValue = targetContext.value[target.element as string];\n  const isArray = isArrayProperty(targetContext, target.element as string) || Array.isArray(originalValue);\n  const newContext: TransformContext = { root: ctx.root, parent: ctx, variables: {} };\n  const targetValue = evalGroup(newContext, group, [sourceValue]);\n  setTargetValue(ctx, target, targetContext, targetValue, isArray, originalValue);\n  return true;\n}\n\n/**\n * Tries to find a \"types\" group that matches the input and output types.\n * This is used to determine the transform for a shorthand rule.\n * @param ctx - The transform context.\n * @param sourceValue - The source value.\n * @returns The matching group, if found; otherwise, undefined.\n */\nfunction tryFindTypesGroup(ctx: TransformContext, sourceValue: TypedValue): StructureMapGroup | undefined {\n  let currentContext: TransformContext | undefined = ctx;\n  while (currentContext) {\n    if (currentContext.variables) {\n      for (const value of Object.values(currentContext.variables)) {\n        const array = arrayify(value);\n        for (const entry of array) {\n          if (entry.type === 'StructureMapGroup') {\n            const group = entry.value as StructureMapGroup;\n            if (\n              (group.typeMode === 'types' || group.typeMode === 'type-and-types') &&\n              group.input.length === 2 &&\n              group.input[0].mode === 'source' &&\n              group.input[0].type === sourceValue.type &&\n              group.input[1].mode === 'target'\n            ) {\n              return group;\n            }\n          }\n        }\n      }\n    }\n    currentContext = currentContext.parent;\n  }\n\n  return undefined;\n}\n\n/**\n * Evaluates a FHIR Mapping source definition.\n *\n * If the source has a condition, the condition is evaluated.\n * If the source has a check, the check is evaluated.\n *\n * @param ctx - The transform context.\n * @param source - The FHIR Mapping source definition.\n * @returns The evaluated source values.\n * @internal\n */\nfunction evalSource(ctx: TransformContext, source: StructureMapGroupRuleSource): TypedValue[] {\n  const sourceContext = getVariable(ctx, source.context as string) as TypedValue | undefined;\n  if (!sourceContext) {\n    return [];\n  }\n\n  const sourceElement = source.element;\n  if (!sourceElement) {\n    return [sourceContext];\n  }\n\n  let sourceValue = evalFhirPathTyped(sourceElement, [sourceContext]);\n  if (!sourceValue || sourceValue.length === 0) {\n    return [];\n  }\n\n  if (source.condition) {\n    if (!evalCondition(sourceContext, { [source.variable as string]: sourceValue[0] }, source.condition)) {\n      return [];\n    }\n  }\n\n  if (source.check) {\n    if (!evalCondition(sourceContext, { [source.variable as string]: sourceValue[0] }, source.check)) {\n      throw new Error('Check failed: ' + source.check);\n    }\n  }\n\n  if (source.listMode) {\n    sourceValue = evalListMode(source, sourceValue);\n  }\n\n  return sourceValue;\n}\n\n/**\n * Evaluates a FHIRPath condition for a FHIR Mapping source.\n *\n * This is used for both the \"condition\" and \"check\" properties.\n *\n * @param input - The input value, typically the rule source.\n * @param variables - The variables in scope for the FHIRPath expression.\n * @param condition - The FHIRPath condition to evaluate.\n * @returns True if the condition is true, false otherwise.\n * @internal\n */\nfunction evalCondition(input: TypedValue, variables: Record<string, TypedValue>, condition: string): boolean {\n  return toJsBoolean(evalFhirPathTyped(condition, [input], variables));\n}\n\n/**\n * Evaluates the list mode for a FHIR Mapping source.\n *\n * @param source - The FHIR Mapping source definition.\n * @param sourceValue - The source values.\n * @returns The evaluated source values.\n * @internal\n */\nfunction evalListMode(source: StructureMapGroupRuleSource, sourceValue: TypedValue[]): TypedValue[] {\n  // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n  switch (source.listMode) {\n    case 'first':\n      return [sourceValue[0]];\n    case 'not_first':\n      return sourceValue.slice(1);\n    case 'last':\n      return [sourceValue[sourceValue.length - 1]];\n    case 'not_last':\n      return sourceValue.slice(0, sourceValue.length - 1);\n    case 'only_one':\n      if (sourceValue.length !== 1) {\n        throw new Error('Expected only one value');\n      }\n      break;\n  }\n  return sourceValue;\n}\n\n/**\n * Evaluates a FHIR Mapping target definition.\n *\n * @param ctx - The transform context.\n * @param target - The FHIR Mapping target definition.\n * @internal\n */\nfunction evalTarget(ctx: TransformContext, target: StructureMapGroupRuleTarget): void {\n  const targetContext = getVariable(ctx, target.context as string) as TypedValue | undefined;\n  if (!targetContext) {\n    throw new Error('Target not found: ' + target.context);\n  }\n\n  const originalValue = targetContext.value[target.element as string];\n  let targetValue: TypedValue[];\n\n  // Determine if the target property is an array field or not\n  // If the target property is an array, then we need to append to the array\n  const isArray = isArrayProperty(targetContext, target.element as string) || Array.isArray(originalValue);\n\n  if (!target.transform) {\n    const elementTypes = tryGetPropertySchema(targetContext, target.element as string)?.type;\n    const elementType = elementTypes?.length === 1 ? elementTypes[0].code : undefined;\n    if (isArray || originalValue === undefined) {\n      targetValue = [elementType ? { type: elementType, value: {} } : toTypedValue({})];\n    } else {\n      targetValue = [elementType ? { type: elementType, value: originalValue } : toTypedValue(originalValue)];\n    }\n  } else {\n    switch (target.transform) {\n      case 'append':\n        targetValue = evalAppend(ctx, target);\n        break;\n      case 'cast':\n        targetValue = evalCast(ctx, target);\n        break;\n      case 'cc':\n        targetValue = evalCc(ctx, target);\n        break;\n      case 'copy':\n        targetValue = evalCopy(ctx, target);\n        break;\n      case 'create':\n        targetValue = evalCreate(ctx, target);\n        break;\n      case 'evaluate':\n        targetValue = evalEvaluate(ctx, target);\n        break;\n      case 'translate':\n        targetValue = evalTranslate(ctx, target);\n        break;\n      case 'truncate':\n        targetValue = evalTruncate(ctx, target);\n        break;\n      case 'uuid':\n        targetValue = [{ type: 'string', value: generateId() }];\n        break;\n      default:\n        throw new Error(`Unsupported transform: ${target.transform}`);\n    }\n  }\n\n  setTargetValue(ctx, target, targetContext, targetValue, isArray, originalValue);\n}\n\n/**\n * Sets a target value.\n *\n * @param ctx - The transform context.\n * @param target - The FHIR Mapping target definition.\n * @param targetContext - The target context.\n * @param targetValue - The target value.\n * @param isArray - True if the target property is an array field.\n * @param originalValue - The original value of the target property.\n * @internal\n */\nfunction setTargetValue(\n  ctx: TransformContext,\n  target: StructureMapGroupRuleTarget,\n  targetContext: TypedValue,\n  targetValue: TypedValue[],\n  isArray: boolean,\n  originalValue: any\n): void {\n  if (targetValue.length === 0) {\n    return;\n  }\n\n  if (isArray) {\n    if (!originalValue) {\n      originalValue = [];\n      safeAssign(targetContext.value, target.element as string, originalValue);\n    }\n    for (const el of targetValue) {\n      originalValue.push(el.value);\n    }\n  } else {\n    safeAssign(targetContext.value, target.element as string, targetValue[0].value);\n  }\n\n  if (target.variable) {\n    setVariable(ctx, target.variable, unarrayify(targetValue));\n  }\n}\n\n/**\n * Returns true if the target property is an array field.\n *\n * @param targetContext - The target context.\n * @param element - The element to check (i.e., the property name).\n * @returns True if the target property is an array field.\n * @internal\n */\nfunction isArrayProperty(targetContext: TypedValue, element: string): boolean | undefined {\n  return tryGetPropertySchema(targetContext, element)?.isArray;\n}\n\n/**\n * Returns the type schema\n * @param targetContext - The target context.\n * @param element - The element to check (i.e., the property name).\n * @returns the type schema for the target element, if it is loeaded\n * @internal\n */\nfunction tryGetPropertySchema(targetContext: TypedValue, element: string): InternalSchemaElement | undefined {\n  return tryGetDataType(targetContext.type)?.elements?.[element];\n}\n\n/**\n * Evaluates the \"append\" transform.\n *\n * \"Source is element or string - just append them all together\"\n *\n * See: https://build.fhir.org/mapping-language.html#7.8.0.8.2\n *\n * @param ctx - The transform context.\n * @param target - The FHIR Mapping target definition.\n * @returns The evaluated target values.\n * @internal\n */\nfunction evalAppend(ctx: TransformContext, target: StructureMapGroupRuleTarget): TypedValue[] {\n  const arg1 = resolveParameter(ctx, target.parameter?.[0])?.[0]?.value;\n  const arg2 = resolveParameter(ctx, target.parameter?.[1])?.[0]?.value;\n  return [{ type: 'string', value: (arg1 ?? '').toString() + (arg2 ?? '').toString() }];\n}\n\n/**\n * Evaluates the \"cast\" transform.\n *\n * \"Cast source from one type to another. target type can be left as implicit if there is one and only one target type known.\"\n *\n * See: https://build.fhir.org/mapping-language.html#7.8.0.8.2\n *\n * @param ctx - The transform context.\n * @param target - The FHIR Mapping target definition.\n * @returns The evaluated target values.\n * @internal\n */\nfunction evalCast(ctx: TransformContext, target: StructureMapGroupRuleTarget): TypedValue[] {\n  const arg1 = resolveParameter(ctx, target.parameter?.[0])?.[0];\n  const arg2 = resolveParameter(ctx, target.parameter?.[1])?.[0]?.value;\n  if (arg2 === 'string') {\n    return [{ type: 'string', value: arg1?.value?.toString() }];\n  }\n  return [arg1];\n}\n\n/**\n * Evaluates the \"cc\" transform.\n *\n * \"Create a CodeableConcept from the parameters provided.\"\n *\n * If there are two parameters, the first is the system and the second is the code.\n *\n * If there is only one parameter, it is the text.\n *\n * See: https://build.fhir.org/mapping-language.html#7.8.0.8.2\n *\n * @param ctx - The transform context.\n * @param target - The FHIR Mapping target definition.\n * @returns The evaluated target values.\n * @internal\n */\nfunction evalCc(ctx: TransformContext, target: StructureMapGroupRuleTarget): TypedValue[] {\n  const params = target.parameter as StructureMapGroupRuleTargetParameter[];\n  if (params.length === 2) {\n    // system and code\n    const system = resolveParameter(ctx, params[0])?.[0]?.value;\n    const code = resolveParameter(ctx, params[1])?.[0]?.value;\n    return [{ type: 'CodeableConcept', value: { coding: [{ system, code }] } }];\n  } else {\n    // text\n    const text = resolveParameter(ctx, params[0])?.[0]?.value;\n    return [{ type: 'CodeableConcept', value: { text } }];\n  }\n}\n\n/**\n * Evaluates the \"copy\" transform.\n *\n * \"Simply copy the source to the target as is (only allowed when the types in source and target match- typically for primitive types).\n * In the concrete syntax, this is simply represented as the source variable, e.g. src.a = tgt.b\"\n *\n * See: https://build.fhir.org/mapping-language.html#7.8.0.8.2\n *\n * @param ctx - The transform context.\n * @param target - The FHIR Mapping target definition.\n * @returns The evaluated target values.\n * @internal\n */\nfunction evalCopy(ctx: TransformContext, target: StructureMapGroupRuleTarget): TypedValue[] {\n  return (target.parameter as StructureMapGroupRuleTargetParameter[]).flatMap((p) => resolveParameter(ctx, p));\n}\n\n/**\n * Evaluates the \"create\" transform.\n *\n * \"Use the standard API to create a new instance of data.\n * Where structure definitions have been provided, the type parameter must be a string which is a known type of a root element.\n * Where they haven't, the application must know the name somehow.\"\"\n *\n * See: https://build.fhir.org/mapping-language.html#7.8.0.8.2\n *\n * @param ctx - The transform context.\n * @param target - The FHIR Mapping target definition.\n * @returns The evaluated target values.\n * @internal\n */\nfunction evalCreate(ctx: TransformContext, target: StructureMapGroupRuleTarget): TypedValue[] {\n  const result: Record<string, unknown> = {};\n  if (target.parameter && target.parameter.length > 0) {\n    result.resourceType = resolveParameter(ctx, target.parameter?.[0])?.[0]?.value;\n  }\n  return [toTypedValue(result)];\n}\n\n/**\n * Evaluates the \"evaluate\" transform.\n *\n * \"Execute the supplied FHIRPath expression and use the value returned by that.\"\n *\n * See: https://build.fhir.org/mapping-language.html#7.8.0.8.2\n *\n * @param ctx - The transform context.\n * @param target - The FHIR Mapping target definition.\n * @returns The evaluated target values.\n * @internal\n */\nfunction evalEvaluate(ctx: TransformContext, target: StructureMapGroupRuleTarget): TypedValue[] {\n  const typedExpr = resolveParameter(ctx, target.parameter?.[0]);\n  const expr = typedExpr[0].value as string;\n  return evalFhirPathTyped(expr, [], buildFhirPathVariables(ctx) as Record<string, TypedValue>);\n}\n\n/**\n * Evaluates the \"translate\" transform.\n *\n * \"Use the translate operation. The source is some type of code or coded datatype,\n * and the source and map_uri are passed to the translate operation.\n * The output determines what value from the translate operation is used for the result of the operation\n * (code, system, display, Coding, or CodeableConcept)\"\n *\n * See: https://build.fhir.org/mapping-language.html#7.8.0.8.2\n *\n * @param ctx - The transform context.\n * @param target - The FHIR Mapping target definition.\n * @returns The evaluated target values.\n * @internal\n */\nfunction evalTranslate(ctx: TransformContext, target: StructureMapGroupRuleTarget): TypedValue[] {\n  const args = (target.parameter as StructureMapGroupRuleTargetParameter[]).flatMap((p) => resolveParameter(ctx, p));\n  const sourceValue = args[0].value;\n  const mapUri = args[1].value;\n  const transformMaps = getTransformMaps(ctx);\n  const conceptMap = transformMaps?.get('ConceptMap', mapUri)[0];\n  if (!conceptMap) {\n    throw new Error('ConceptMap not found: ' + mapUri);\n  }\n  // TODO: Verify whether system is actually required\n  // The FHIR Mapping Language spec does not say whether it is required\n  // But our current implementation requires it\n  const result = conceptMapTranslate(conceptMap, { system: conceptMap.group?.[0]?.source, code: sourceValue });\n  return [toTypedValue(result.match?.[0]?.concept?.code)];\n}\n\n/**\n * Evaluates the \"truncate\" transform.\n *\n * \"Source must be some stringy type that has some meaningful length property\"\n *\n * See: https://build.fhir.org/mapping-language.html#7.8.0.8.2\n *\n * @param ctx - The transform context.\n * @param target - The FHIR Mapping target definition.\n * @returns The evaluated target values.\n * @internal\n */\nfunction evalTruncate(ctx: TransformContext, target: StructureMapGroupRuleTarget): TypedValue[] {\n  const targetValue = resolveParameter(ctx, target.parameter?.[0])?.[0];\n  const targetLength = resolveParameter(ctx, target.parameter?.[1])?.[0]?.value as number;\n  if (targetValue.type === 'string') {\n    return [{ type: 'string', value: targetValue.value.substring(0, targetLength) }];\n  }\n  return [targetValue];\n}\n\n/**\n * Evaluates a rule dependent group.\n *\n * See: https://hl7.org/fhir/r4/structuremap-definitions.html#StructureMap.group.rule.dependent\n *\n * @param ctx - The transform context.\n * @param dependent - The FHIR Mapping dependent definition.\n * @internal\n */\nfunction evalDependent(ctx: TransformContext, dependent: StructureMapGroupRuleDependent): void {\n  const dependentGroup = getVariable(ctx, dependent.name as string) as TypedValue | undefined;\n  if (!dependentGroup) {\n    throw new Error('Dependent group not found: ' + dependent.name);\n  }\n\n  const variables = dependent.variable as string[];\n  const args: TypedValue[] = [];\n  for (const variable of variables) {\n    const variableValue = getVariable(ctx, variable) as TypedValue | undefined;\n    if (!variableValue) {\n      throw new Error('Dependent variable not found: ' + variable);\n    }\n    args.push(variableValue);\n  }\n\n  const newContext: TransformContext = { root: ctx.root, parent: ctx, variables: {} };\n  evalGroup(newContext, dependentGroup.value as StructureMapGroup, args);\n}\n\nfunction getTransformMaps(ctx: TransformContext): TransformMapCollection | undefined {\n  if (ctx.transformMaps) {\n    return ctx.transformMaps;\n  }\n  if (ctx.parent) {\n    return getTransformMaps(ctx.parent);\n  }\n  return undefined;\n}\n\n/**\n * Resolves the value of a FHIR Mapping target parameter.\n *\n * For literal values, the value is returned as-is.\n *\n * For variables, the value is looked up in the current context.\n *\n * @param ctx - The transform context.\n * @param parameter - The FHIR Mapping target parameter definition.\n * @returns The resolved parameter values.\n * @internal\n */\nfunction resolveParameter(\n  ctx: TransformContext,\n  parameter: StructureMapGroupRuleTargetParameter | undefined\n): TypedValue[] {\n  const typedParameter = { type: 'StructureMapGroupRuleTargetParameter', value: parameter };\n  let paramValue = getTypedPropertyValue(typedParameter, 'value');\n  if (!paramValue) {\n    throw new Error('Missing target parameter: ' + JSON.stringify(parameter));\n  }\n\n  paramValue = arrayify(paramValue);\n\n  if (paramValue.length === 1 && paramValue[0].type === 'id') {\n    const variableValue = getVariable(ctx, paramValue[0].value as string);\n    if (!variableValue) {\n      throw new Error('Variable not found: ' + paramValue[0].value);\n    }\n    return arrayify(variableValue);\n  }\n\n  return paramValue;\n}\n\n/**\n * Returns a variable value by name.\n *\n * Recursively searches the parent context if the variable is not found in the current context.\n *\n * @param ctx - The transform context.\n * @param name - The variable name.\n * @returns The variable value.\n * @internal\n */\nfunction getVariable(ctx: TransformContext, name: string): TypedValue[] | TypedValue | undefined {\n  const value = ctx.variables?.[name];\n  if (value) {\n    return value;\n  }\n  if (ctx.parent) {\n    return getVariable(ctx.parent, name);\n  }\n  return undefined;\n}\n\n/**\n * Builds a collection of FHIRPath variables from the current context.\n *\n * Recursively searches the parent context to build the complete set of variables.\n *\n * @param ctx - The transform context.\n * @param result - The builder output.\n * @returns The result with the FHIRPath variables.\n * @internal\n */\nfunction buildFhirPathVariables(\n  ctx: TransformContext,\n  result: Record<string, TypedValue[] | TypedValue> = {}\n): Record<string, TypedValue[] | TypedValue> {\n  if (ctx.parent) {\n    buildFhirPathVariables(ctx.parent, result);\n  }\n  if (ctx.variables) {\n    for (const [key, value] of Object.entries(ctx.variables)) {\n      result[key] = value;\n      result['%' + key] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * Sets a variable value in the current context.\n *\n * @param ctx - The transform context.\n * @param name - The variable name.\n * @param value - The variable value.\n * @internal\n */\nfunction setVariable(ctx: TransformContext, name: string, value: TypedValue[] | TypedValue): void {\n  if (!ctx.variables) {\n    ctx.variables = {};\n  }\n  safeAssign(ctx.variables, name, value);\n}\n\nfunction safeAssign(target: Record<string, unknown>, key: string, value: unknown): void {\n  if (key === '__proto__' || key === 'constructor' || key === 'prototype') {\n    throw new Error('Invalid key: ' + key);\n  }\n  target[key] = value;\n}\n\nfunction arrayify<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n\nfunction unarrayify<T>(value: T[]): T | T[] {\n  return value.length === 1 ? value[0] : value;\n}\n", "const DEFAULT_INDENT = ' '.repeat(2);\n\nexport class FileBuilder {\n  private readonly indent: string;\n  private readonly b: string[];\n  indentCount: number;\n\n  constructor(indent = DEFAULT_INDENT, header = true) {\n    this.indent = indent;\n    this.b = [];\n    this.indentCount = 0;\n\n    if (header) {\n      this.appendNoWrap('/*');\n      this.appendNoWrap(' * This is a generated file');\n      this.appendNoWrap(' * Do not edit manually.');\n      this.appendNoWrap(' */');\n      this.newLine();\n    }\n  }\n\n  newLine(): void {\n    this.b.push('\\n');\n  }\n\n  appendNoWrap(line: string): void {\n    this.b.push(this.indent.repeat(this.indentCount));\n    this.b.push(line);\n    this.b.push('\\n');\n  }\n\n  append(line: string): void {\n    const nowrap = this.indent.repeat(this.indentCount) + line;\n    if (nowrap.length < 160) {\n      this.b.push(nowrap);\n      this.b.push('\\n');\n    } else {\n      let first = true;\n      for (const wrappedLine of wordWrap(nowrap, 120 - this.indent.length * this.indentCount)) {\n        if (first) {\n          this.b.push(this.indent.repeat(this.indentCount));\n        } else {\n          this.b.push(this.indent.repeat(this.indentCount + 2));\n        }\n        this.b.push(wrappedLine.trim());\n        this.b.push('\\n');\n        first = false;\n      }\n    }\n  }\n\n  toString(): string {\n    return this.b.join('').replaceAll('\\n\\n\\n', '\\n\\n');\n  }\n}\n\n/**\n * Returns a word-wrapped string.\n * Based on: https://stackoverflow.com/a/38709683\n * @param text - Original input string.\n * @param maxLength - Width in number of characters.\n * @returns Array of lines.\n */\nexport function wordWrap(text: string, maxLength: number): string[] {\n  const result = [];\n  let line: string[] = [];\n  let length = 0;\n  text.split(' ').forEach(function (word) {\n    if (length + word.length > maxLength) {\n      result.push(line.join(' ').trim());\n      line = [];\n      length = 0;\n    }\n    length += word.length + 1;\n    line.push(word);\n  });\n  if (line.length > 0) {\n    result.push(line.join(' ').trim());\n  }\n  return result;\n}\n", "import { Token, Tokenizer } from '../fhirlexer/tokenize';\nimport { FHIRPATH_KEYWORDS, FHIRPATH_OPERATORS } from '../fhirpath/tokenize';\n\nconst MAPPING_LANGUAGE_OPERATORS = [...FHIRPATH_OPERATORS, 'eq', 'ne', 'co'];\n\nexport function tokenize(str: string): Token[] {\n  return new Tokenizer(str, FHIRPATH_KEYWORDS, MAPPING_LANGUAGE_OPERATORS, {\n    dateTimeLiterals: true,\n    symbolRegex: /[^\\s\\])]/,\n  }).tokenize();\n}\n", "// See: https://hl7.org/fhir/search_filter.html\n\nimport { Operator } from '../search/search';\n\n/**\n * The FhirFilterExpression type is the base type of all filter expressions.\n */\nexport type FhirFilterExpression = FhirFilterComparison | FhirFilterNegation | FhirFilterConnective;\n\n/**\n * The FhirFilterComparison class represents a comparison expression.\n */\nexport class FhirFilterComparison {\n  readonly path: string;\n  readonly operator: Operator;\n  readonly value: string;\n\n  constructor(path: string, operator: Operator, value: string) {\n    this.path = path;\n    this.operator = operator;\n    this.value = value;\n  }\n}\n\n/**\n * The FhirFilterNegation class represents a negation expression.\n * It contains a single child expression.\n */\nexport class FhirFilterNegation {\n  readonly child: FhirFilterExpression;\n\n  constructor(child: FhirFilterExpression) {\n    this.child = child;\n  }\n}\n\n/**\n * The FhirFilterConnective class represents a connective expression.\n * It contains a list of child expressions.\n */\nexport class FhirFilterConnective {\n  readonly keyword: 'and' | 'or';\n  readonly left: FhirFilterExpression;\n  readonly right: FhirFilterExpression;\n\n  constructor(keyword: 'and' | 'or', left: FhirFilterExpression, right: FhirFilterExpression) {\n    this.keyword = keyword;\n    this.left = left;\n    this.right = right;\n  }\n}\n", "import { Parser } from '../fhirlexer/parse';\nimport { initFhirPathParserBuilder } from '../fhirpath/parse';\nimport { OperationOutcomeError, badRequest } from '../outcomes';\nimport { Operator } from '../search/search';\nimport { tokenize } from './tokenize';\nimport { FhirFilterComparison, FhirFilterConnective, FhirFilterExpression, FhirFilterNegation } from './types';\n\n/**\n * The operatorMap maps FHIR _filter operators to Medplum search operators.\n * See _filter operators: https://www.hl7.org/fhir/search_filter.html#ops\n */\nconst operatorMap: Record<string, Operator | undefined> = {\n  // eq - an item in the set has an equal value\n  eq: Operator.EXACT,\n  // ne - An item in the set has an unequal value\n  ne: Operator.NOT_EQUALS,\n  // co - An item in the set contains this value\n  co: Operator.CONTAINS,\n  // sw - An item in the set starts with this value\n  sw: Operator.STARTS_WITH,\n  // ew - An item in the set ends with this value\n  ew: undefined,\n  // gt / lt / ge / le - A value in the set is (greater than, less than, greater or equal, less or equal) the given value\n  gt: Operator.GREATER_THAN,\n  lt: Operator.LESS_THAN,\n  ge: Operator.GREATER_THAN_OR_EQUALS,\n  le: Operator.LESS_THAN_OR_EQUALS,\n  // ap - A value in the set is approximately the same as this value.\n  // Note that the recommended value for the approximation is 10% of the stated value (or for a date, 10% of the gap between now and the date), but systems may choose other values where appropriate\n  ap: Operator.APPROXIMATELY,\n  // sa - The value starts after the specified value\n  sa: Operator.STARTS_AFTER,\n  // eb - The value ends before the specified value\n  eb: Operator.ENDS_BEFORE,\n  // pr - The set is empty or not (value is false or true)\n  pr: Operator.PRESENT,\n  // po - True if a (implied) date period in the set overlaps with the implied period in the value\n  po: undefined,\n  // ss - True if the value subsumes a concept in the set\n  ss: undefined,\n  // sb - True if the value is subsumed by a concept in the set\n  sb: undefined,\n  // in - True if one of the concepts is in the nominated value set by URI, either a relative, literal or logical vs\n  in: Operator.IN,\n  // ni - True if none of the concepts are in the nominated value set by URI, either a relative, literal or logical vs\n  ni: Operator.NOT_IN,\n  // re - True if one of the references in set points to the given URL\n  re: Operator.EQUALS,\n  // identifier - True if the identifier is in the identifier set (Medplum extension)\n  identifier: Operator.IDENTIFIER,\n};\n\nfunction getOperator(value: string): Operator {\n  const operator = operatorMap[value];\n  if (!operator) {\n    throw new OperationOutcomeError(badRequest('Invalid operator: ' + value));\n  }\n  return operator;\n}\n\nclass FilterParameterParser {\n  readonly parser: Parser;\n\n  constructor(parser: Parser) {\n    this.parser = parser;\n  }\n\n  parse(): FhirFilterExpression {\n    let result: FhirFilterExpression;\n\n    if (this.parser.peek()?.value === '(') {\n      this.parser.consume('(');\n      result = this.parse();\n      this.parser.consume(')');\n    } else if (this.parser.peek()?.value === 'not') {\n      this.parser.consume('Symbol', 'not');\n      this.parser.consume('(');\n      result = new FhirFilterNegation(this.parse());\n      this.parser.consume(')');\n    } else {\n      result = new FhirFilterComparison(\n        this.parser.consume('Symbol').value,\n        getOperator(this.parser.consume('Symbol').value),\n        this.parser.consume().value\n      );\n    }\n\n    const next = this.parser.peek()?.value;\n    if (next === 'and' || next === 'or') {\n      this.parser.consume('Symbol', next);\n      return new FhirFilterConnective(next, result, this.parse());\n    }\n\n    return result;\n  }\n}\n\nconst fhirPathParserBuilder = initFhirPathParserBuilder();\n\n/**\n * Parses a FHIR _filter parameter expression into an AST.\n * @param input - The FHIR _filter parameter expression.\n * @returns The AST representing the filters.\n */\nexport function parseFilterParameter(input: string): FhirFilterExpression {\n  const parser = fhirPathParserBuilder.construct(tokenize(input));\n  parser.removeComments();\n  return new FilterParameterParser(parser).parse();\n}\n", "import { isStringArray } from './utils';\n\nexport const AckCode = {\n  /** AA - Application Accept */\n  AA: 'AA',\n  /** AE - Application Error */\n  AE: 'AE',\n  /** AR - Application Reject */\n  AR: 'AR',\n  /** CA - Commit Accept */\n  CA: 'CA',\n  /** CE - Commit Error */\n  CE: 'CE',\n  /** CR - Commit Reject */\n  CR: 'CR',\n} as const;\nexport type AckCode = keyof typeof AckCode;\n\nexport interface Hl7AckOptions {\n  ackCode: AckCode;\n  errSegment?: Hl7Segment;\n}\n\nconst TEXT_MSG_FOR_ACK_CODE = {\n  AA: 'OK',\n  AE: 'Application Error',\n  AR: 'Application Reject',\n  CA: 'Commit Accept',\n  CE: 'Commit Error',\n  CR: 'Commit Reject',\n} as Record<AckCode, string>;\n\n/**\n * The Hl7Context class represents the parsing context for an HL7 message.\n *\n * @see MSH-1: https://hl7-definition.caristix.com/v2/HL7v2.6/Fields/MSH.1\n * @see MSH-2: https://hl7-definition.caristix.com/v2/HL7v2.6/Fields/MSH.2\n * @see See this tutorial on MSH, and why it's a bad idea to use anything other than the default values: https://www.hl7soup.com/HL7TutorialMSH.html\n */\nexport class Hl7Context {\n  readonly segmentSeparator: string;\n  readonly fieldSeparator: string;\n  readonly componentSeparator: string;\n  readonly repetitionSeparator: string;\n  readonly escapeCharacter: string;\n  readonly subcomponentSeparator: string;\n\n  constructor(\n    segmentSeparator = '\\r',\n    fieldSeparator = '|',\n    componentSeparator = '^',\n    repetitionSeparator = '~',\n    escapeCharacter = '\\\\',\n    subcomponentSeparator = '&'\n  ) {\n    this.segmentSeparator = segmentSeparator;\n    this.fieldSeparator = fieldSeparator;\n    this.componentSeparator = componentSeparator;\n    this.repetitionSeparator = repetitionSeparator;\n    this.escapeCharacter = escapeCharacter;\n    this.subcomponentSeparator = subcomponentSeparator;\n  }\n\n  /**\n   * Returns the MSH-1 field value based on the configured separators.\n   * @returns The HL7 MSH-1 field value.\n   */\n  getMsh1(): string {\n    return this.fieldSeparator;\n  }\n\n  /**\n   * Returns the MSH-2 field value based on the configured separators.\n   * @returns The HL7 MSH-2 field value.\n   */\n  getMsh2(): string {\n    return this.componentSeparator + this.repetitionSeparator + this.escapeCharacter + this.subcomponentSeparator;\n  }\n}\n\n/**\n * The Hl7Message class represents one HL7 message.\n * A message is a collection of segments.\n */\nexport class Hl7Message {\n  readonly context: Hl7Context;\n  readonly segments: Hl7Segment[];\n\n  /**\n   * Creates a new HL7 message.\n   * @param segments - The HL7 segments.\n   * @param context - Optional HL7 parsing context.\n   */\n  constructor(segments: Hl7Segment[], context = new Hl7Context()) {\n    this.context = context;\n    this.segments = segments;\n  }\n\n  /**\n   * Returns the HL7 message header.\n   * @returns The HL7 message header.\n   */\n  get header(): Hl7Segment {\n    return this.segments[0];\n  }\n\n  /**\n   * Returns an HL7 segment by index or by name.\n   * @param index - The HL7 segment index or name.\n   * @returns The HL7 segment if found; otherwise, undefined.\n   * @deprecated Use getSegment() instead. This method will be removed in a future release.\n   */\n  get(index: number | string): Hl7Segment | undefined {\n    return this.getSegment(index);\n  }\n\n  /**\n   * Returns all HL7 segments of a given name.\n   * @param name - The HL7 segment name.\n   * @returns An array of HL7 segments with the specified name.\n   * @deprecated Use getAllSegments() instead. This method will be removed in a future release.\n   */\n  getAll(name: string): Hl7Segment[] {\n    return this.getAllSegments(name);\n  }\n\n  /**\n   * Returns an HL7 segment by index or by name.\n   *\n   * When using a numeric index, the first segment (usually the MSH header segment) is at index 0.\n   *\n   * When using a string index, this method returns the first segment with the specified name.\n   *\n   * @param index - The HL7 segment index or name.\n   * @returns The HL7 segment if found; otherwise, undefined.\n   */\n  getSegment(index: number | string): Hl7Segment | undefined {\n    if (typeof index === 'number') {\n      return this.segments[index];\n    }\n    return this.segments.find((s) => s.name === index);\n  }\n\n  /**\n   * Returns all HL7 segments of a given name.\n   * @param name - The HL7 segment name.\n   * @returns An array of HL7 segments with the specified name.\n   */\n  getAllSegments(name: string): Hl7Segment[] {\n    return this.segments.filter((s) => s.name === name);\n  }\n\n  /**\n   * Returns the HL7 message as a string.\n   * @returns The HL7 message as a string.\n   */\n  toString(): string {\n    return this.segments.map((s) => s.toString()).join(this.context.segmentSeparator);\n  }\n\n  /**\n   * Returns an HL7 \"ACK\" (acknowledgement) message for this message.\n   * @param options - The optional options to configure the \"ACK\" message.\n   * @returns The HL7 \"ACK\" message.\n   */\n  buildAck(options?: Hl7AckOptions): Hl7Message {\n    const now = new Date();\n    const msh = this.getSegment('MSH');\n    const sendingApp = msh?.getField(3)?.toString() ?? '';\n    const sendingFacility = msh?.getField(4)?.toString() ?? '';\n    const receivingApp = msh?.getField(5)?.toString() ?? '';\n    const receivingFacility = msh?.getField(6)?.toString() ?? '';\n    const controlId = msh?.getField(10)?.toString() ?? '';\n    const versionId = msh?.getField(12)?.toString() ?? '2.5.1';\n    const ackCode = options?.ackCode ?? 'AA';\n\n    return new Hl7Message([\n      new Hl7Segment(\n        [\n          'MSH',\n          this.context.getMsh2(),\n          receivingApp,\n          receivingFacility,\n          sendingApp,\n          sendingFacility,\n          formatHl7DateTime(now),\n          '',\n          this.buildAckMessageType(msh),\n          now.getTime().toString(),\n          'P',\n          versionId,\n        ],\n        this.context\n      ),\n      new Hl7Segment(['MSA', ackCode, controlId, TEXT_MSG_FOR_ACK_CODE[ackCode]], this.context),\n      ...(options?.errSegment ? [options.errSegment] : []),\n    ]);\n  }\n\n  private buildAckMessageType(msh: Hl7Segment | undefined): string {\n    // MSH 7 is the message type\n    // https://hl7-definition.caristix.com/v2/HL7v2.4/DataTypes/MSG\n    // In HL7 v2.1, the message type is a single field\n    // In HL7 v2.2 through v2.3, message type has two components.\n    // In HL7 v2.3.1 and later, message type has three components.\n    // Rather than using version to determine behavior, we instead mirror the original message.\n    const messageType = msh?.getField(9);\n    const triggerEvent = messageType?.getComponent(2);\n    const messageStructure = messageType?.getComponent(3);\n    let result = 'ACK';\n    if (triggerEvent && messageStructure) {\n      result = `ACK^${triggerEvent}^ACK`;\n    } else if (triggerEvent) {\n      result = `ACK^${triggerEvent}`;\n    }\n    return result;\n  }\n\n  /**\n   * Parses an HL7 message string into an Hl7Message object.\n   * @param text - The HL7 message text.\n   * @returns The parsed HL7 message.\n   */\n  static parse(text: string): Hl7Message {\n    if (!text.startsWith('MSH')) {\n      const err = new Error('Invalid HL7 message');\n      (err as any).type = 'entity.parse.failed';\n      throw err;\n    }\n    const context = new Hl7Context(\n      '\\r',\n      text.charAt(3), // Field separator, recommended \"|\"\n      text.charAt(4), // Component separator, recommended \"^\"\n      text.charAt(5), // Repetition separator, recommended \"~\"\n      text.charAt(6), // Escape character, recommended \"\\\"\n      text.charAt(7) // Subcomponent separator, recommended \"&\"\n    );\n    return new Hl7Message(\n      text.split(/[\\r\\n]+/).map((line) => Hl7Segment.parse(line, context)),\n      context\n    );\n  }\n\n  /**\n   * Sets or replaces a segment at the specified index.\n   * Only allows MSH header to be replaced as first segment.\n   * If index is a number and is larger than the length of the segments array, it will be appended as the last segment.\n   * If the index is a string, replaces the first segment with that name.\n   * @param index - The segment index or name\n   * @param segment - The new segment to set\n   * @returns true if the segment was set, false otherwise\n   */\n  setSegment(index: number | string, segment: Hl7Segment): boolean {\n    // Special handling for MSH segment\n    if (segment.name === 'MSH') {\n      if (typeof index === 'number') {\n        if (index !== 0) {\n          return false; // MSH can only be the first segment\n        }\n      } else {\n        const existingIndex = this.segments.findIndex((s) => s.name === index);\n        if (existingIndex !== 0) {\n          return false; // MSH can only be the first segment\n        }\n      }\n    } else if (typeof index === 'number' && index === 0 && segment.name !== 'MSH') {\n      return false; // Cannot replace MSH segment with non-MSH segment\n    }\n\n    if (typeof index === 'number') {\n      if (index >= this.segments.length) {\n        // Append as last segment\n        this.segments.push(segment);\n        return true;\n      }\n      this.segments[index] = segment;\n      return true;\n    }\n\n    const existingIndex = this.segments.findIndex((s) => s.name === index);\n    if (existingIndex === 0 && segment.name !== 'MSH') {\n      return false; // Cannot replace MSH segment with non-MSH segment\n    }\n    if (existingIndex !== -1) {\n      this.segments[existingIndex] = segment;\n      return true;\n    }\n    return false;\n  }\n}\n\n/**\n * The Hl7Segment class represents one HL7 segment.\n * A segment is a collection of fields.\n * The name field is the first field.\n */\nexport class Hl7Segment {\n  readonly context: Hl7Context;\n  readonly name: string;\n  readonly fields: Hl7Field[];\n\n  /**\n   * Creates a new HL7 segment.\n   * @param fields - The HL7 fields. The first field is the segment name.\n   * @param context - Optional HL7 parsing context.\n   */\n  constructor(fields: Hl7Field[] | string[], context = new Hl7Context()) {\n    this.context = context;\n    if (isStringArray(fields)) {\n      this.fields = fields.map((f) => Hl7Field.parse(f, context));\n    } else {\n      this.fields = fields;\n    }\n    this.name = this.fields[0].components[0][0];\n  }\n\n  /**\n   * Returns an HL7 field by index.\n   * @param index - The HL7 field index.\n   * @returns The HL7 field.\n   * @deprecated Use getField() instead. This method includes the segment name in the index, which leads to confusing behavior. This method will be removed in a future release.\n   */\n  get(index: number): Hl7Field {\n    return this.fields[index];\n  }\n\n  /**\n   * Returns an HL7 field by index.\n   *\n   * Note that the index is 1-based, not 0-based.\n   *\n   * For example, to get the first field, use `getField(1)`.\n   *\n   * This aligns with HL7 field names such as PID.1, PID.2, etc.\n   *\n   * Field zero is the segment name.\n   *\n   * @param index - The HL7 field index.\n   * @returns The HL7 field.\n   */\n  getField(index: number): Hl7Field {\n    if (this.name === 'MSH') {\n      // MSH segments require special handling due to field separator\n      if (index === 1) {\n        // MSH.1 is the field separator\n        return new Hl7Field([[this.context.getMsh1()]], this.context);\n      }\n      if (index === 2) {\n        // MSH.2 is the encoding characters\n        return new Hl7Field([[this.context.getMsh2()]], this.context);\n      }\n      if (index > 2) {\n        // MSH.3 through MSH.n are offset by 1\n        return this.fields[index - 1];\n      }\n    }\n    return this.fields[index];\n  }\n\n  /**\n   * Returns an HL7 component by field index and component index.\n   *\n   * This is a shortcut for `getField(field).getComponent(component)`.\n   *\n   * Note that both indexex are 1-based, not 0-based.\n   *\n   * For example, to get the first component, use `getComponent(1, 1)`.\n   *\n   * This aligns with HL7 component names such as MSH.9.2.\n   *\n   * @param fieldIndex - The HL7 field index.\n   * @param component - The component index.\n   * @param subcomponent - Optional subcomponent index.\n   * @param repetition - Optional repetition index.\n   * @returns The string value of the specified component.\n   */\n  getComponent(fieldIndex: number, component: number, subcomponent?: number, repetition = 0): string {\n    return this.getField(fieldIndex)?.getComponent(component, subcomponent, repetition) ?? '';\n  }\n\n  /**\n   * Returns the HL7 segment as a string.\n   * @returns The HL7 segment as a string.\n   */\n  toString(): string {\n    return this.fields.map((f) => f.toString()).join(this.context.fieldSeparator);\n  }\n\n  /**\n   * Parses an HL7 segment string into an Hl7Segment object.\n   * @param text - The HL7 segment text.\n   * @param context - Optional HL7 parsing context.\n   * @returns The parsed HL7 segment.\n   */\n  static parse(text: string, context = new Hl7Context()): Hl7Segment {\n    return new Hl7Segment(\n      text.split(context.fieldSeparator).map((f) => Hl7Field.parse(f, context)),\n      context\n    );\n  }\n\n  /**\n   * Sets a field at the specified index. If that index does not exist, it will be added.\n   * Note that the index is 1-based, not 0-based.\n   * @param index - The field index\n   * @param field - The new field value\n   * @returns true if the field was set, false otherwise\n   */\n  setField(index: number, field: Hl7Field | string): boolean {\n    if (this.name === 'MSH') {\n      // MSH segments require special handling\n      if (index === 1) {\n        // MSH.1 is the field separator - cannot be changed\n        return false;\n      }\n      if (index === 2) {\n        // MSH.2 is the encoding characters - cannot be changed\n        return false;\n      }\n      if (index > 2) {\n        // MSH.3 through MSH.n are offset by 1\n        const actualIndex = index - 1;\n        // Add new fields if needed\n        while (this.fields.length <= actualIndex) {\n          this.fields.push(new Hl7Field([['']], this.context));\n        }\n        this.fields[actualIndex] = typeof field === 'string' ? Hl7Field.parse(field, this.context) : field;\n        return true;\n      }\n    }\n\n    // Add new fields if needed\n    while (this.fields.length <= index) {\n      this.fields.push(new Hl7Field([['']], this.context));\n    }\n    this.fields[index] = typeof field === 'string' ? Hl7Field.parse(field, this.context) : field;\n    return true;\n  }\n\n  /**\n   * Sets a component value by field index and component index.\n   * This is a shortcut for `getField(field).setComponent(component, value)`.\n   * Note that both indices are 1-based, not 0-based.\n   * @param fieldIndex - The HL7 field index\n   * @param component - The component index\n   * @param value - The new component value\n   * @param subcomponent - Optional subcomponent index\n   * @param repetition - Optional repetition index\n   * @returns true if the component was set, false otherwise\n   */\n  setComponent(fieldIndex: number, component: number, value: string, subcomponent?: number, repetition = 0): boolean {\n    const field = this.getField(fieldIndex);\n    if (!field) {\n      return false;\n    }\n    return field.setComponent(component, value, subcomponent, repetition);\n  }\n}\n\n/**\n * The Hl7Field class represents one HL7 field.\n * A field is a collection of components.\n */\nexport class Hl7Field {\n  readonly context: Hl7Context;\n  readonly components: string[][];\n\n  /**\n   * Creates a new HL7 field.\n   * @param components - The HL7 components.\n   * @param context - Optional HL7 parsing context.\n   */\n  constructor(components: string[][], context = new Hl7Context()) {\n    this.context = context;\n    this.components = components;\n  }\n\n  /**\n   * Returns an HL7 component by index.\n   * @param component - The component index.\n   * @param subcomponent - Optional subcomponent index.\n   * @param repetition - Optional repetition index.\n   * @returns The string value of the specified component.\n   * @deprecated Use getComponent() instead. This method will be removed in a future release.\n   */\n  get(component: number, subcomponent?: number, repetition = 0): string {\n    return this.getComponent(component + 1, subcomponent, repetition);\n  }\n\n  /**\n   * Returns an HL7 component by index.\n   *\n   * Note that the index is 1-based, not 0-based.\n   *\n   * For example, to get the first component, use `getComponent(1)`.\n   *\n   * This aligns with HL7 component names such as MSH.9.2.\n   *\n   * @param component - The component index.\n   * @param subcomponent - Optional subcomponent index.\n   * @param repetition - Optional repetition index.\n   * @returns The string value of the specified component.\n   */\n  getComponent(component: number, subcomponent?: number, repetition = 0): string {\n    let value = this.components[repetition][component - 1] ?? '';\n\n    if (subcomponent !== undefined) {\n      value = value.split(this.context.subcomponentSeparator)[subcomponent] ?? '';\n    }\n\n    return value;\n  }\n\n  /**\n   * Returns the HL7 field as a string.\n   * @returns The HL7 field as a string.\n   */\n  toString(): string {\n    return this.components.map((r) => r.join(this.context.componentSeparator)).join(this.context.repetitionSeparator);\n  }\n\n  /**\n   * Parses an HL7 field string into an Hl7Field object.\n   * @param text - The HL7 field text.\n   * @param context - Optional HL7 parsing context.\n   * @returns The parsed HL7 field.\n   */\n  static parse(text: string, context = new Hl7Context()): Hl7Field {\n    return new Hl7Field(\n      text.split(context.repetitionSeparator).map((r) => r.split(context.componentSeparator)),\n      context\n    );\n  }\n\n  /**\n   * Sets a component value at the specified indices.\n   * Note that the indices are 1-based, not 0-based.\n   * @param component - The component index\n   * @param value - The new component value\n   * @param subcomponent - Optional subcomponent index\n   * @param repetition - Optional repetition index\n   * @returns true if the component was set, false otherwise\n   */\n  setComponent(component: number, value: string, subcomponent?: number, repetition = 0): boolean {\n    if (component < 1) {\n      return false;\n    }\n\n    if (repetition >= this.components.length) {\n      // Add new repetitions if needed\n      while (this.components.length <= repetition) {\n        this.components.push(['']);\n      }\n    }\n\n    if (subcomponent !== undefined) {\n      if (subcomponent < 0) {\n        return false;\n      }\n      // Handle subcomponent setting\n      const currentValue = this.components[repetition][component - 1] || '';\n      const subcomponents = currentValue.split(this.context.subcomponentSeparator);\n\n      // Ensure we have enough subcomponents\n      while (subcomponents.length <= subcomponent) {\n        subcomponents.push('');\n      }\n\n      subcomponents[subcomponent] = value;\n      this.components[repetition][component - 1] = subcomponents.join(this.context.subcomponentSeparator);\n    } else {\n      // Handle regular component setting\n      this.components[repetition][component - 1] = value;\n    }\n\n    return true;\n  }\n}\n\nexport interface Hl7DateParseOptions {\n  /**\n   * Default timezone offset.\n   * Example: \"-0500\"\n   */\n  tzOffset?: string;\n}\n\n/**\n * Returns a formatted string representing the date in ISO-8601 format.\n *\n * HL7-Definition V2\n * Specifies a point in time using a 24-hour clock notation.\n *\n * Format: YYYY[MM[DD[HH[MM[SS[. S[S[S[S]]]]]]]]][+/-ZZZZ].\n *\n * @param hl7DateTime - Date/time string.\n * @param options - Optional parsing options.\n * @returns The date in ISO-8601 format.\n */\nexport function parseHl7DateTime(hl7DateTime: string | undefined, options?: Hl7DateParseOptions): string | undefined {\n  if (!hl7DateTime) {\n    return undefined;\n  }\n\n  const year = parseIntOrDefault(hl7DateTime.slice(0, 4), 0);\n  const month = parseIntOrDefault(hl7DateTime.slice(4, 6), 1) - 1; // Months are 0-indexed in JavaScript Date\n  const day = parseIntOrDefault(hl7DateTime.slice(6, 8), 1); // Default to first day of month\n  const hour = parseIntOrDefault(hl7DateTime.slice(8, 10), 0);\n  const minute = parseIntOrDefault(hl7DateTime.slice(10, 12), 0);\n  const second = parseIntOrDefault(hl7DateTime.slice(12, 14), 0);\n\n  let millisecond = 0;\n  if (hl7DateTime.includes('.')) {\n    millisecond = parseIntOrDefault(hl7DateTime.slice(15, 19), 0);\n  }\n\n  let date = new Date(Date.UTC(year, month, day, hour, minute, second, millisecond));\n\n  const tzOffset = parseTimeZoneOffset(hl7DateTime, options?.tzOffset);\n  if (tzOffset !== 0) {\n    date = new Date(date.getTime() - tzOffset);\n  }\n\n  return date.toISOString();\n}\n\n/**\n * Parses an integer value from a string.\n * @param str - The string to parse.\n * @param defaultValue - The default value to return if the string is not a number.\n * @returns The parsed integer value, or the default value if the string is not a number.\n */\nfunction parseIntOrDefault(str: string, defaultValue: number): number {\n  const result = parseInt(str, 10);\n  return isNaN(result) ? defaultValue : result;\n}\n\n/**\n * Returns the timezone offset in milliseconds.\n * @param hl7DateTime - The HL7 date/time string.\n * @param defaultOffset - Optional default timezone offset.\n * @returns The timezone offset in milliseconds.\n */\nfunction parseTimeZoneOffset(hl7DateTime: string, defaultOffset?: string): number {\n  let offsetStr = defaultOffset;\n\n  const plusIndex = hl7DateTime.indexOf('+');\n  if (plusIndex !== -1) {\n    offsetStr = hl7DateTime.slice(plusIndex);\n  }\n\n  const minusIndex = hl7DateTime.indexOf('-');\n  if (minusIndex !== -1) {\n    offsetStr = hl7DateTime.slice(minusIndex);\n  }\n\n  if (!offsetStr) {\n    return 0;\n  }\n\n  const sign = offsetStr.startsWith('-') ? -1 : 1;\n\n  // Remove plus, minus, and optional colon\n  offsetStr = offsetStr.slice(1).replace(':', '');\n\n  const hour = parseInt(offsetStr.slice(0, 2), 10);\n  const minute = parseInt(offsetStr.slice(2, 4), 10);\n  return sign * (hour * 60 * 60 * 1000 + minute * 60 * 1000);\n}\n\n/**\n * Formats an ISO date/time string into an HL7 date/time string.\n * @param isoDate - The ISO date/time string.\n * @returns The HL7 date/time string.\n */\nexport function formatHl7DateTime(isoDate: Date | string): string {\n  const date = isoDate instanceof Date ? isoDate : new Date(isoDate);\n  const isoString = date.toISOString();\n\n  // Replace \"T\" and all dashes (-) and colons (:) with empty strings\n  // Replace Z with \"+0000\"\n  // Replace the last 3 digits before 'Z' with the 4-digit milliseconds\n  let result = isoString.replace(/[-:T]/g, '').replace(/(\\.\\d+)?Z$/, '');\n\n  const milliseconds = date.getUTCMilliseconds();\n  if (milliseconds > 0) {\n    result += '.' + milliseconds.toString();\n  }\n\n  return result;\n}\n", "/*\n * Once upon a time, we used Winston, and that was fine.\n * Then the log4j fiasco happened, and everyone started auditing logging libraries.\n * And we decided that we did not use any fancy logging features,\n * and that logging to console.log was actually perfectly adequate.\n */\n\n/**\n * Logging level, with greater values representing more detailed logs emitted.\n *\n * The zero value means no server logs will be emitted.\n */\nexport const LogLevel = {\n  NONE: 0,\n  ERROR: 1,\n  WARN: 2,\n  INFO: 3,\n  DEBUG: 4,\n};\nexport type LogLevel = (typeof LogLevel)[keyof typeof LogLevel];\n\nexport const LogLevelNames = ['NONE', 'ERROR', 'WARN', 'INFO', 'DEBUG'];\n\nexport interface LoggerOptions {\n  prefix?: string;\n}\n\nexport interface LoggerConfig {\n  write: (msg: string) => void;\n  metadata: Record<string, any>;\n  level: LogLevel;\n  options?: LoggerOptions;\n}\n\nexport type LoggerConfigOverride = Partial<LoggerConfig>;\n\nexport class Logger {\n  readonly write: (msg: string) => void;\n  readonly metadata: Record<string, any>;\n  readonly options?: LoggerOptions;\n  readonly prefix?: string;\n  level: LogLevel;\n\n  constructor(\n    write: (msg: string) => void,\n    metadata: Record<string, any> = {},\n    level: LogLevel = LogLevel.INFO,\n    options: LoggerOptions = {}\n  ) {\n    this.write = write;\n    this.metadata = metadata;\n    this.level = level;\n    this.options = options;\n\n    if (options?.prefix) {\n      this.prefix = options.prefix;\n    }\n\n    this.error = this.error.bind(this);\n    this.warn = this.warn.bind(this);\n    this.info = this.info.bind(this);\n    this.debug = this.debug.bind(this);\n    this.log = this.log.bind(this);\n  }\n\n  clone(override?: LoggerConfigOverride): Logger {\n    const config = this.getLoggerConfig();\n    const mergedConfig = override\n      ? { ...config, override, options: { ...config.options, ...override.options } }\n      : config;\n    return new Logger(mergedConfig.write, mergedConfig.metadata, mergedConfig.level, mergedConfig.options);\n  }\n\n  private getLoggerConfig(): LoggerConfig {\n    const { write, metadata, level, options } = this;\n    return { write, metadata, level, options };\n  }\n\n  error(msg: string, data?: Record<string, any> | Error): void {\n    this.log(LogLevel.ERROR, msg, data);\n  }\n\n  warn(msg: string, data?: Record<string, any> | Error): void {\n    this.log(LogLevel.WARN, msg, data);\n  }\n\n  info(msg: string, data?: Record<string, any> | Error): void {\n    this.log(LogLevel.INFO, msg, data);\n  }\n\n  debug(msg: string, data?: Record<string, any> | Error): void {\n    this.log(LogLevel.DEBUG, msg, data);\n  }\n\n  log(level: LogLevel, msg: string, data?: Record<string, any> | Error): void {\n    if (level > this.level) {\n      return;\n    }\n    if (data instanceof Error) {\n      data = {\n        error: data.toString(),\n        stack: data.stack?.split('\\n'),\n      };\n    }\n    this.write(\n      JSON.stringify({\n        level: LogLevelNames[level],\n        timestamp: new Date().toISOString(),\n        msg: this.prefix ? `${this.prefix}${msg}` : msg,\n        ...data,\n        ...this.metadata,\n      })\n    );\n  }\n}\n\nexport function parseLogLevel(level: string): LogLevel {\n  const value = LogLevel[level.toUpperCase() as keyof typeof LogLevel];\n  if (value === undefined) {\n    throw new Error(`Invalid log level: ${level}`);\n  }\n\n  return value;\n}\n", "import { OperationOutcomeIssue } from '@medplum/fhirtypes';\nimport { createStructureIssue, OperationOutcomeError, validationError } from './outcomes';\nimport { isResourceType } from './typeschema/types';\n\n/**\n * Validates that the given string is a valid FHIR resource type.\n *\n * On success, silently returns void.\n * On failure, throws an OperationOutcomeError.\n *\n * @example\n * ```ts\n * validateResourceType('Patient'); // nothing\n * validateResourceType('XYZ'); // throws OperationOutcomeError\n * ```\n *\n * Note that this depends on globalSchema, which is populated by the StructureDefinition loader.\n *\n * @example\n * In a server context, you can load all schema definitions:\n *\n * ```ts\n * import { indexStructureDefinitionBundle } from '@medplum/core';\n * import { readJson } from '@medplum/definitions';\n * import { Bundle } from '@medplum/fhirtypes';\n *\n * indexStructureDefinitionBundle(readJson('fhir/r4/profiles-resources.json') as Bundle);\n * ```\n *\n * @example\n * In a client context, you can load the schema definitions using MedplumClient:\n *\n * ```ts\n * import { MedplumClient } from '@medplum/core';\n *\n * const medplum = new MedplumClient();\n * await medplum.requestSchema('Patient');\n * ```\n *\n * @param resourceType - The candidate resource type string.\n */\nexport function validateResourceType(resourceType: string): void {\n  if (!resourceType) {\n    throw new OperationOutcomeError(validationError('Resource type is null'));\n  }\n  if (!isResourceType(resourceType)) {\n    throw new OperationOutcomeError(validationError('Unknown resource type'));\n  }\n}\n\n/**\n * Recursively checks for null values in an object.\n *\n * Note that \"null\" is a special value in JSON that is not allowed in FHIR.\n * @param value - Input value of any type.\n * @param path - Path string to the value for OperationOutcome.\n * @param issues - Output list of issues.\n */\nexport function checkForNull(value: unknown, path: string, issues: OperationOutcomeIssue[]): void {\n  if (value === null) {\n    issues.push(createStructureIssue(path, 'Invalid null value'));\n  } else if (Array.isArray(value)) {\n    checkArrayForNull(value, path, issues);\n  } else if (typeof value === 'object') {\n    checkObjectForNull(value as Record<string, unknown>, path, issues);\n  }\n}\n\nfunction checkArrayForNull(array: unknown[], path: string, issues: OperationOutcomeIssue[]): void {\n  for (let i = 0; i < array.length; i++) {\n    if (array[i] === undefined) {\n      issues.push(createStructureIssue(`${path}[${i}]`, 'Invalid undefined value'));\n    } else {\n      checkForNull(array[i], `${path}[${i}]`, issues);\n    }\n  }\n}\n\nfunction checkObjectForNull(obj: Record<string, unknown>, path: string, issues: OperationOutcomeIssue[]): void {\n  for (const [key, value] of Object.entries(obj)) {\n    checkForNull(value, `${path}${path ? '.' : ''}${key}`, issues);\n  }\n}\n", "import { Readable } from 'stream';\n\n/**\n * Reads data from a Readable stream and returns a Promise that resolves with a Buffer containing all the data.\n * @param stream - The Readable stream to read from.\n * @returns A Promise that resolves with a Buffer containing all the data from the Readable stream.\n */\nexport function streamToBuffer(stream: Readable): Promise<Buffer> {\n  const chunks: Uint8Array[] = [];\n  return new Promise<Buffer>((resolve, reject) => {\n    stream.on('data', (chunk: Uint8Array) => chunks.push(Buffer.from(chunk)));\n    stream.on('error', (err: Error) => {\n      stream.destroy();\n      reject(err);\n    });\n    stream.on('end', () => {\n      resolve(Buffer.concat(chunks));\n    });\n    stream.on('close', () => {\n      stream.destroy();\n    });\n  });\n}\n", "import { Resource, ViewDefinition, ViewDefinitionSelect } from '@medplum/fhirtypes';\nimport { evalFhirPathTyped } from '../fhirpath/parse';\nimport { getTypedPropertyValue, toTypedValue } from '../fhirpath/utils';\nimport { TypedValue } from '../types';\n\n/**\n * Represents a \"selection structure\" in the SQL-on-FHIR specification.\n *\n * In practice, this can be a ViewDefinition or ViewDefinitionSelect.\n *\n * TypeScript does not like checks for properties that are not part of the type, so we use this interface instead.\n */\nexport interface SelectionStructure {\n  forEach?: string;\n  forEachOrNull?: string;\n  column?: ViewDefinitionSelect['column'];\n  select?: SelectionStructure[];\n  unionAll?: SelectionStructure[];\n}\n\n/**\n * SQL on FHIR output row.\n */\nexport type OutputRow = Record<string, any>;\n\n/**\n * Evaluates a SQL-on-FHIR view on a set of FHIR resources.\n * @param view - The view definition.\n * @param resources - The array of FHIR resources.\n * @returns The output rows.\n */\nexport function evalSqlOnFhir(view: ViewDefinition, resources: Resource[]): OutputRow[] {\n  const result = [];\n\n  for (const resource of resources) {\n    result.push(...processResource(view, resource));\n  }\n\n  return result;\n}\n\n/**\n * Processes a FHIR resource with a ViewDefinition to emit all rows.\n *\n * This step emits all rows produced by a ViewDefinition on an input Resource, by setting up a recursive call.\n *\n * See: https://build.fhir.org/ig/FHIR/sql-on-fhir-v2/implementer_guidance.html#process-a-resource-entry-point\n *\n * @param v - The view definition.\n * @param r - The FHIR resource.\n * @returns The output rows.\n */\nfunction processResource(v: ViewDefinition, r: Resource): OutputRow[] {\n  if (!v.resource) {\n    throw new Error('Resource type is required');\n  }\n\n  if (v.resource !== r.resourceType) {\n    return [];\n  }\n\n  const variables: Record<string, TypedValue> = {};\n  if (v.constant) {\n    for (const c of v.constant) {\n      const typedConstant = { type: 'ViewDefinitionConstant', value: c };\n      variables['%' + c.name] = getTypedPropertyValue(typedConstant, 'value') as TypedValue;\n    }\n  }\n\n  const typedResource = toTypedValue(r);\n\n  if (v.where) {\n    for (const where of v.where) {\n      const whereResult = evalFhirPathTyped(where.path, [typedResource], variables);\n      if (whereResult.length !== 1) {\n        return [];\n      }\n      if (whereResult[0].type !== 'boolean') {\n        throw new Error('WHERE clause must evaluate to a boolean');\n      }\n      if (!whereResult[0].value) {\n        return [];\n      }\n    }\n  }\n\n  return process(v, typedResource, variables);\n}\n\n/**\n * Processes a selection structure and node to emit all rows.\n *\n * This step emits all rows for a given Selection Structure and Node. We first generate sets of\n * \"partial rows\" (i.e., sets of incomplete column bindings from the various clauses of V) and combine them to emit complete rows.\n *\n * This function is deliberately structured to match the pseudocode in the SQL-on-FHIR specification.\n * See: https://build.fhir.org/ig/FHIR/sql-on-fhir-v2/implementer_guidance.html#processs-n-recursive-step\n *\n * @param s - The selection structure.\n * @param n - The node (element) from a FHIR resource.\n * @param variables - The variables.\n * @returns An array of output rows.\n */\nfunction process(s: SelectionStructure, n: TypedValue, variables: Record<string, TypedValue>): OutputRow[] {\n  const result: OutputRow[] = [];\n\n  // 1. Define a list of Nodes foci as\n  let foci: TypedValue[];\n  if (s.forEach) {\n    // If S.forEach is defined: fhirpath(S.forEach, N)\n    foci = evalFhirPathTyped(s.forEach, [n], variables);\n  } else if (s.forEachOrNull) {\n    // Else if S.forEachOrNull is defined: fhirpath(S.forEachOrNull, N)\n    foci = evalFhirPathTyped(s.forEachOrNull, [n], variables);\n  } else {\n    // Otherwise: [N] (a list with just the input node)\n    foci = [n];\n  }\n\n  // 2. For each element f of foci\n  for (const f of foci) {\n    // Initialize an empty list parts (each element of parts will be a list of partial rows)\n    const parts: OutputRow[][] = [];\n\n    // Process Columns:\n    for (const col of s.column ?? []) {\n      // For each Column col of S.column, define val as fhirpath(col.path, f)\n      const val = evalFhirPathTyped(col.path, [f], variables);\n\n      // Define b as a row whose column named col.name takes the value\n      let b: OutputRow;\n\n      if (val.length === 0) {\n        // If val was the empty set: null\n        b = { [col.name]: null };\n      } else if (col.collection) {\n        // Else if col.collection is true: val\n        b = { [col.name]: val.map((v) => v.value) };\n      } else if (val.length === 1) {\n        // Else if val has a single element e: e\n        b = { [col.name]: val[0].value };\n      } else {\n        // Else: throw \"Multiple values found but not expected for column\"\n        throw new Error('Multiple values found but not expected for column');\n      }\n\n      // Append [b] to parts\n      // (Note: append a list so the final element of parts is now a list containing the single row b).)\n      parts.push([b]);\n    }\n\n    // Process Selects:\n    // For each selection structure sel of S.select\n    for (const sel of s.select ?? []) {\n      // Define rows as the collection of all rows emitted by Process(sel, f)\n      const rows = process(sel, f, variables);\n\n      // Append rows to parts\n      // (Note: do not append the elements but the whole list, so the final element of parts is now the list rows)\n      parts.push(rows);\n    }\n\n    // Process UnionAlls:\n    // Initialize urows as an empty list of rows\n    // For each selection structure u of S.unionAll\n    if (s.unionAll) {\n      const urows: OutputRow[] = [];\n      for (const u of s.unionAll) {\n        // For each row r in Process(u, f)\n        for (const r of process(u, f, variables)) {\n          // Append r to urows\n          urows.push(r);\n        }\n      }\n\n      // Append urows to parts\n      // (Note: do not append the elements but the whole list, so the final element of parts is now the list urows\n      parts.push(urows);\n    }\n\n    // For every list of partial rows prows in the Cartesian product of parts\n    // (Note: the Cartesian product is always between a Selection Structure and its direct children, not deeper descendants.\n    // Because the process is recursive, rows generated by, for example, a .select[0].select[0].select[0] will eventually bubble up\n    // to the top level, but the bubbling happens one level at a time.)\n    result.push(...cartesianProduct(parts));\n  }\n\n  // If foci is an empty list and S.forEachOrNull is defined\n  if (foci.length === 0 && s.forEachOrNull) {\n    // (Note: when this condition is met, no rows have been emitted so far)\n    // Initialize a blank row r\n    const r: OutputRow = {};\n\n    // For each Column c in ValidateColumns(V, [])\n    for (const c of s.column ?? []) {\n      // Bind the column c.name to null in the row r\n      r[c.name] = null;\n    }\n\n    // Emit the row r\n    result.push(r);\n  }\n\n  return result;\n}\n\n/**\n * Returns the Cartesian product of the given arrays.\n *\n * For example, if there are two sets of partial rows:\n *\n *   [{\"a\": 1},{\"a\": 2}] with bindings for the variable a\n *   [{\"b\": 3},{\"b\": 4}] with bindings for the variable b\n *\n * Then the Cartesian product of these sets consists of four complete rows:\n *\n *   [\n *     {\"a\": 1, \"b\": 3},\n *     {\"a\": 1, \"b\": 4},\n *     {\"a\": 2, \"b\": 3},\n *     {\"a\": 2, \"b\": 4}\n *   ]\n *\n * @param parts - The arrays to combine.\n * @returns The Cartesian product of the arrays.\n */\nfunction cartesianProduct(parts: OutputRow[][]): OutputRow[] {\n  if (parts.length === 0) {\n    return [];\n  }\n\n  let temp = parts[0];\n  for (let i = 1; i < parts.length; i++) {\n    temp = cartesianProductHelper(temp, parts[i]);\n  }\n\n  return temp;\n}\n\nfunction cartesianProductHelper(aArray: OutputRow[], bArray: OutputRow[]): OutputRow[] {\n  const result = [];\n  for (const a of aArray) {\n    for (const b of bArray) {\n      result.push(combinePartialRows(a, b));\n    }\n  }\n  return result;\n}\n\nfunction combinePartialRows(a: OutputRow, b: OutputRow): OutputRow {\n  const result: OutputRow = {};\n  Object.assign(result, a);\n  Object.assign(result, b);\n  return result;\n}\n", "import { MEDPLUM_VERSION } from './client';\nimport { normalizeErrorString } from './outcomes';\n\nexport const MEDPLUM_RELEASES_URL = 'https://meta.medplum.com/releases';\n\nexport type ReleaseManifest = { tag_name: string; assets: { name: string; browser_download_url: string }[] };\n\nconst releaseManifests = new Map<string, ReleaseManifest>();\n\n/**\n * Clears the locally-cached `ReleaseManifest`s for all versions.\n */\nexport function clearReleaseCache(): void {\n  releaseManifests.clear();\n}\n\n/**\n * Asserts that a given candidate is a `ReleaseManifest`.\n * @param candidate - An object assumed to be a `ReleaseManifest`.\n */\nexport function assertReleaseManifest(candidate: unknown): asserts candidate is ReleaseManifest {\n  const manifest = candidate as ReleaseManifest;\n  if (!manifest.tag_name) {\n    throw new Error('Manifest missing tag_name');\n  }\n  const assets = manifest.assets;\n  if (!assets?.length) {\n    throw new Error('Manifest missing assets list');\n  }\n  for (const asset of assets) {\n    if (!asset.browser_download_url) {\n      throw new Error('Asset missing browser download URL');\n    }\n    if (!asset.name) {\n      throw new Error('Asset missing name');\n    }\n  }\n}\n\n/**\n * Fetches the manifest for a given Medplum release version.\n * @param appName - The name of the app to fetch the manifest for.\n * @param version - The version to fetch. If no `version` is provided, defaults to the `latest` version.\n * @param params - An optional list of key-value pairs to be appended to the URL query string.\n * @returns - The manifest for the specified or latest version.\n */\nexport async function fetchVersionManifest(\n  appName: string,\n  version?: string,\n  params?: Record<string, string>\n): Promise<ReleaseManifest> {\n  let manifest = releaseManifests.get(version ?? 'latest');\n  if (!manifest) {\n    const versionTag = version ? `v${version}` : 'latest';\n    const url = new URL(`${MEDPLUM_RELEASES_URL}/${versionTag}.json`);\n    url.searchParams.set('a', appName);\n    url.searchParams.set('c', MEDPLUM_VERSION);\n    if (params) {\n      for (const [key, value] of Object.entries(params)) {\n        url.searchParams.set(key, value);\n      }\n    }\n    const res = await fetch(url.toString());\n    if (res.status !== 200) {\n      let message: string | undefined;\n      try {\n        message = ((await res.json()) as { message: string }).message;\n      } catch (err) {\n        console.error(`Failed to parse message from body: ${normalizeErrorString(err)}`);\n      }\n      throw new Error(\n        `Received status code ${res.status} while fetching manifest for version '${version ?? 'latest'}'. Message: ${message}`\n      );\n    }\n    const response = (await res.json()) as ReleaseManifest;\n    assertReleaseManifest(response);\n    manifest = response;\n    releaseManifests.set(version ?? 'latest', manifest);\n    if (!version) {\n      releaseManifests.set(manifest.tag_name.slice(1), manifest);\n    }\n  }\n  return manifest;\n}\n\n/**\n * Tests that a given version string follows the basic semver pattern of `<int>.<int>.<int>`, which is used for Medplum versions.\n *\n * @param version - A version string that should be tested for valid semver semantics.\n * @returns `true` if `version` is a valid semver version that conforms to the Medplum versioning system, otherwise `false`.\n */\nexport function isValidMedplumSemver(version: string): boolean {\n  return /^\\d+\\.\\d+\\.\\d+$/.test(version);\n}\n\n/**\n * Tests that a given version string is a valid existing Medplum release version.\n * @param appName - The name of the app to check the version for.\n * @param version - A version to be checked against the existing Medplum repo releases.\n * @returns `true` if `version` is a valid semver version that corresponds to an existing release, otherwise `false`.\n */\nexport async function checkIfValidMedplumVersion(appName: string, version: string): Promise<boolean> {\n  if (!isValidMedplumSemver(version)) {\n    return false;\n  }\n  try {\n    await fetchVersionManifest(appName, version);\n  } catch (_err) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * Fetches the latest Medplum release version string.\n * @param appName - The name of the app to fetch the latest version for.\n * @returns A version string corresponding to the latest Medplum release version.\n */\nexport async function fetchLatestVersionString(appName: string): Promise<string> {\n  const latest = await fetchVersionManifest(appName);\n  if (!latest.tag_name.startsWith('v')) {\n    throw new Error(`Invalid release name found. Release tag '${latest.tag_name}' did not start with 'v'`);\n  }\n  return latest.tag_name.slice(1);\n}\n\n/**\n * Checks if a newer version of Medplum is available and logs a warning if so.\n * @param appName - The name of the app to check the version for.\n * @param params - An optional list of key-value pairs to be appended to the URL query string.\n */\nexport async function warnIfNewerVersionAvailable(appName: string, params?: Record<string, string>): Promise<void> {\n  try {\n    const current = MEDPLUM_VERSION.split('-')[0];\n    const manifest = await fetchVersionManifest(appName, undefined, params);\n    const latest = manifest.tag_name.slice(1);\n    if (current !== latest) {\n      console.warn(\n        `A new version (v${latest}) of Medplum is available. Your current version (v${current}) may be missing important updates and bug fixes.`\n      );\n    }\n  } catch (err) {\n    console.warn(`Failed to check for newer version: ${normalizeErrorString(err)}`);\n  }\n}\n"],
  "mappings": "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Ac,mBACd,GAAIZ,GACJ,MAAO,CACL,CACE,SAAU,QACV,KAAM,YACN,QAAS,CACP,KAAM,WACR,CACF,CACF,CACF,EAEaa,GAAiC,CAC5C,aAAc,mBACd,GAAIX,GACJ,MAAO,CACL,CACE,SAAU,QACV,KAAM,QACN,QAAS,CACP,KAAM,cACR,CACF,CACF,CACF,EAEaY,GAA6C,CACxD,GAAGD,GACH,MAAO,CACL,GAAGA,GAAa,MAChB,CACE,SAAU,QACV,KAAM,UACN,QAAS,CACP,KAAM,eACR,CACF,CACF,CACF,EAEaE,GAA8C,CACzD,GAAGF,GACH,MAAO,CACL,GAAGA,GAAa,MAChB,CACE,SAAU,QACV,KAAM,UACN,QAAS,CACP,KAAM,oCACR,CACF,CACF,CACF,EAEaG,GAA8B,CACzC,aAAc,mBACd,GAAIb,GACJ,MAAO,CACL,CACE,SAAU,QACV,KAAM,YACN,QAAS,CACP,KAAM,WACR,CACF,CACF,CACF,EAEac,GAAyB,CACpC,aAAc,mBACd,GAAIpB,GACJ,MAAO,CACL,CACE,SAAU,QACV,KAAM,UACN,QAAS,CACP,KAAM,MACR,CACF,CACF,CACF,EAEaqB,GAAuC,CAClD,aAAc,mBACd,GAAId,GACJ,MAAO,CACL,CACE,SAAU,QACV,KAAM,aACN,QAAS,CACP,KAAM,qBACR,CACF,CACF,CACF,EAEae,GAAoC,CAC/C,aAAc,mBACd,GAAId,GACJ,MAAO,CACL,CACE,SAAU,QACV,KAAM,mBACN,QAAS,CACP,KAAM,6CACR,CACF,CACF,CACF,EAEae,GAAoC,CAC/C,aAAc,mBACd,GAAId,GACJ,MAAO,CACL,CACE,SAAU,QACV,KAAM,YACN,QAAS,CACP,KAAM,mBACR,CACF,CACF,CACF,EAEO,SAASe,GAASC,EAAoC,CAC3D,MAAO,CACL,aAAc,mBACd,GAAIf,GACJ,MAAO,CACL,CACE,SAAU,cACV,KAAM,gBACN,QAAS,CACP,KAAM,UACR,EACA,YAAae,CACf,CACF,CACF,CACF,CAEO,SAASC,EAAWC,EAAiBC,EAAuC,CACjF,MAAO,CACL,aAAc,mBACd,MAAO,C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ACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,IAAO,CACL,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,EACA,KAAQ,CACN,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,EACA,KAAQ,CACN,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,KAAQ,CACN,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,KAAQ,CACN,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,SAAY,CACV,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,MAAS,CACP,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,WAAc,CACZ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,QAAW,CACT,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,OAAU,CACR,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,CACF,CACF,EACA,IAAO,CACL,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,MAAS,CACP,KAAQ,CACN,CACE,KAAQ,SACV,CACF,CACF,EACA,WAAc,CACZ,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,EACA,KAAQ,CACN,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,OAAU,CACR,KAAQ,CACN,CACE,KAAQ,KACV,CACF,CACF,EACA,KAAQ,CACN,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,CACF,CACF,EACA,WAAc,CACZ,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,YAAa,CACX,KAAQ,CACN,CACE,KAAQ,YACR,cAAiB,CACf,uDACA,kDACA,wDACA,sDACF,CACF,EACA,CACE,KAAQ,QACV,CACF,CACF,EACA,KAAQ,CACN,KAAQ,CACN,CACE,KAAQ,UACV,CACF,CACF,EACA,KAAQ,CACN,IAAO,EACP,KAAQ,CACN,CACE,KAAQ,UACV,CACF,CACF,CACF,CACF,EACA,WAAc,CACZ,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,YAAe,CACb,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,EACA,SAAY,CACV,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,EACA,KAAQ,CACN,KAAQ,CACN,CACE,KAAQ,cACV,CACF,CACF,EACA,IAAO,CACL,KAAQ,CACN,CACE,KAAQ,KACV,CACF,CACF,EACA,KAAQ,CACN,KAAQ,CACN,CACE,KAAQ,aACV,CACF,CACF,EACA,KAAQ,CACN,KAAQ,CACN,CACE,KAAQ,cACV,CACF,CACF,EACA,MAAS,CACP,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,SAAY,CACV,KAAQ,CACN,CACE,KAAQ,UACV,CACF,CACF,CACF,CACF,EACA,gBAAmB,CACjB,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,OAAU,CACR,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,KAAQ,CACN,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,CACF,CACF,EACA,OAAU,CACR,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,OAAU,CACR,KAAQ,CACN,CACE,KAAQ,KACV,CACF,CACF,EACA,QAAW,CACT,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,KAAQ,CACN,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,EACA,QAAW,CACT,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,aAAgB,CACd,KAAQ,CACN,CACE,KAAQ,SACV,CACF,CACF,CACF,CACF,EACA,cAAiB,CACf,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,KAAQ,CACN,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,QAAW,CACT,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,cACV,CACF,CACF,CACF,CACF,EACA,aAAgB,CACd,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,OAAU,CACR,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,EACA,MAAS,CACP,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,IAAO,CACL,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,EACA,KAAQ,CACN,KAAQ,CACN,CACE,KAAQ,aACV,CACF,CACF,EACA,OAAU,CACR,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,CACF,CACF,EACA,YAAe,CACb,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,KAAQ,CACN,IAAO,EACP,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,EACA,KAAQ,CACN,IAAO,EACP,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,QAAW,CACT,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,eACV,CACF,CACF,CACF,CACF,EACA,MAAS,CACP,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,MAAS,CACP,KAAQ,CACN,CACE,KAAQ,SACV,CACF,CACF,EACA,WAAc,CACZ,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,EACA,KAAQ,CACN,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,OAAU,CACR,KAAQ,CACN,CACE,KAAQ,KACV,CACF,CACF,EACA,KAAQ,CACN,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,CACF,CACF,EACA,gBAAmB,CACjB,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,KAAQ,CACN,IAAO,EACP,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,EACA,QAAW,CACT,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,YACR,cAAiB,CAAC,6DAA6D,CACjF,CACF,CACF,EACA,aAAc,CACZ,KAAQ,CACN,CACE,KAAQ,iBACV,EACA,CACE,KAAQ,YACR,cAAiB,CAAC,+CAA+C,CACnE,CACF,CACF,EACA,YAAe,CACb,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,WAAc,CACZ,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,2BACV,CACF,CACF,EACA,WAAc,CACZ,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,2BACV,CACF,CACF,EACA,MAAS,CACP,KAAQ,CACN,CACE,KAAQ,aACV,CACF,CACF,EACA,KAAQ,CACN,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,qBACV,CACF,CACF,CACF,CACF,EACA,0BAA6B,CAC3B,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,KAAQ,CACN,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,YAAe,CACb,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,SAAY,CACV,KAAQ,CACN,CACE,KAAQ,YACR,cAAiB,CAAC,kDAAkD,CACtE,CACF,CACF,EACA,KAAQ,CACN,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,CACF,CACF,EACA,0BAA6B,CAC3B,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,KAAQ,CACN,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,YAAe,CACb,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,WAAY,CACV,KAAQ,CACN,CACE,KAAQ,UACV,EACA,CACE,KAAQ,QACV,EACA,CACE,KAAQ,UACV,CACF,CACF,CACF,CACF,EACA,oBAAuB,CACrB,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,KAAQ,CACN,IAAO,EACP,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,EACP,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,CACF,CACF,EACA,SAAY,CACV,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,MAAS,CACP,KAAQ,CACN,CACE,KAAQ,SACV,CACF,CACF,EACA,WAAc,CACZ,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,EACA,KAAQ,CACN,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,OAAU,CACR,KAAQ,CACN,CACE,KAAQ,KACV,CACF,CACF,EACA,KAAQ,CACN,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,CACF,CACF,EACA,OAAU,CACR,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,kBAAqB,CACnB,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,SAAY,CACV,KAAQ,CACN,CACE,KAAQ,SACV,CACF,CACF,EACA,KAAQ,CACN,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,sBAAyB,CACvB,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,iBACV,CACF,CACF,EACA,mBAAsB,CACpB,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,OAAU,CACR,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,cAAe,CACb,KAAQ,CACN,CACE,KAAQ,SACV,EACA,CACE,KAAQ,iBACV,CACF,CACF,EACA,KAAQ,CACN,KAAQ,CACN,CACE,KAAQ,iBACV,CACF,CACF,EACA,MAAS,CACP,KAAQ,CACN,CACE,KAAQ,iBACV,CACF,CACF,EACA,OAAU,CACR,KAAQ,CACN,CACE,KAAQ,iBACV,CACF,CACF,EACA,YAAe,CACb,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,mBACV,CACF,CACF,EACA,iBAAoB,CAClB,KAAQ,CACN,CACE,KAAQ,OACV,CACF,CACF,EACA,yBAA4B,CAC1B,KAAQ,CACN,CACE,KAAQ,WACR,QAAW,CAAC,wDAAwD,CACtE,CACF,CACF,EACA,mBAAsB,CACpB,KAAQ,CACN,CACE,KAAQ,WACR,QAAW,CAAC,wDAAwD,CACtE,CACF,CACF,CACF,CACF,EACA,kBAAqB,CACnB,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,KAAQ,CACN,KAAQ,CACN,CACE,KAAQ,iBACV,CACF,CACF,EACA,UAAW,CACT,KAAQ,CACN,CACE,KAAQ,OACV,EACA,CACE,KAAQ,WACR,QAAW,CAAC,wDAAwD,CACtE,CACF,CACF,EACA,UAAW,CACT,KAAQ,CACN,CACE,KAAQ,OACV,EACA,CACE,KAAQ,OACV,EACA,CACE,KAAQ,WACR,QAAW,CAAC,wDAAwD,CACtE,CACF,CACF,CACF,CACF,EACA,SAAY,CACV,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,MAAS,CACP,KAAQ,CACN,CACE,KAAQ,SACV,CACF,CACF,EACA,WAAc,CACZ,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,EACA,KAAQ,CACN,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,OAAU,CACR,KAAQ,CACN,CACE,KAAQ,KACV,CACF,CACF,EACA,KAAQ,CACN,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,CACF,CACF,EACA,kBAAqB,CACnB,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,kBAAqB,CACnB,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,KAAQ,CACN,IAAO,EACP,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,eAAkB,CAChB,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,EACA,UAAa,CACX,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,oBAAuB,CACrB,KAAQ,CACN,CACE,KAAQ,SACV,CACF,CACF,EACA,MAAS,CACP,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,KAAQ,CACN,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,QAAW,CACT,KAAQ,CACN,CACE,KAAQ,0BACV,CACF,CACF,EACA,MAAS,CACP,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,WAAc,CACZ,KAAQ,CACN,CACE,KAAQ,UACV,CACF,CACF,EACA,QAAW,CACT,KAAQ,CACN,CACE,KAAQ,UACV,CACF,CACF,EACA,aAAgB,CACd,KAAQ,CACN,CACE,KAAQ,UACV,CACF,CACF,EACA,MAAS,CACP,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,IAAO,CACL,KAAQ,CACN,CACE,KAAQ,aACV,CACF,CACF,EACA,IAAO,CACL,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,KAAQ,CACN,KAAQ,CACN,CACE,KAAQ,uBACV,CACF,CACF,EACA,iBAAoB,CAClB,KAAQ,CACN,CACE,KAAQ,KACV,CACF,CACF,EACA,KAAQ,CACN,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,uBACV,CACF,CACF,EACA,kBAAmB,CACjB,KAAQ,CACN,CACE,KAAQ,cACV,EACA,CACE,KAAQ,SACV,EACA,CACE,KAAQ,WACV,EACA,CACE,KAAQ,MACV,EACA,CACE,KAAQ,MACV,EACA,CACE,KAAQ,UACV,EACA,CACE,KAAQ,SACV,EACA,CACE,KAAQ,IACV,EACA,CACE,KAAQ,SACV,EACA,CACE,KAAQ,SACV,EACA,CACE,KAAQ,UACV,EACA,CACE,KAAQ,KACV,EACA,CACE,KAAQ,aACV,EACA,CACE,KAAQ,QACV,EACA,CACE,KAAQ,MACV,EACA,CACE,KAAQ,aACV,EACA,CACE,KAAQ,KACV,EACA,CACE,KAAQ,KACV,EACA,CACE,KAAQ,MACV,EACA,CACE,KAAQ,SACV,EACA,CACE,KAAQ,KACV,EACA,CACE,KAAQ,YACV,EACA,CACE,KAAQ,YACV,EACA,CACE,KAAQ,iBACV,EACA,CACE,KAAQ,QACV,EACA,CACE,KAAQ,cACV,EACA,CACE,KAAQ,OACV,EACA,CACE,KAAQ,UACV,EACA,CACE,KAAQ,UACV,EACA,CACE,KAAQ,WACV,EACA,CACE,KAAQ,YACV,EACA,CACE,KAAQ,OACV,EACA,CACE,KAAQ,QACV,EACA,CACE,KAAQ,UACV,EACA,CACE,KAAQ,OACV,EACA,CACE,KAAQ,OACV,EACA,CACE,KAAQ,WACV,EACA,CACE,KAAQ,aACV,EACA,CACE,KAAQ,WACV,EACA,CACE,KAAQ,QACV,EACA,CACE,KAAQ,eACV,EACA,CACE,KAAQ,aACV,EACA,CACE,KAAQ,iBACV,EACA,CACE,KAAQ,YACV,EACA,CACE,KAAQ,qBACV,EACA,CACE,KAAQ,iBACV,EACA,CACE,KAAQ,mBACV,EACA,CACE,KAAQ,cACV,EACA,CACE,KAAQ,QACV,EACA,CACE,KAAQ,MACV,CACF,CACF,EACA,mBAAsB,CACpB,KAAQ,CACN,CACE,KAAQ,UACV,CACF,CACF,EACA,aAAgB,CACd,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,WAAY,CACV,KAAQ,CACN,CACE,KAAQ,cACV,EACA,CACE,KAAQ,SACV,EACA,CACE,KAAQ,WACV,EACA,CACE,KAAQ,MACV,EACA,CACE,KAAQ,MACV,EACA,CACE,KAAQ,UACV,EACA,CACE,KAAQ,SACV,EACA,CACE,KAAQ,IACV,EACA,CACE,KAAQ,SACV,EACA,CACE,KAAQ,SACV,EACA,CACE,KAAQ,UACV,EACA,CACE,KAAQ,KACV,EACA,CACE,KAAQ,aACV,EACA,CACE,KAAQ,QACV,EACA,CACE,KAAQ,MACV,EACA,CACE,KAAQ,aACV,EACA,CACE,KAAQ,KACV,EACA,CACE,KAAQ,KACV,EACA,CACE,KAAQ,MACV,EACA,CACE,KAAQ,SACV,EACA,CACE,KAAQ,KACV,EACA,CACE,KAAQ,YACV,EACA,CACE,KAAQ,YACV,EACA,CACE,KAAQ,iBACV,EACA,CACE,KAAQ,QACV,EACA,CACE,KAAQ,cACV,EACA,CACE,KAAQ,OACV,EACA,CACE,KAAQ,UACV,EACA,CACE,KAAQ,UACV,EACA,CACE,KAAQ,WACV,EACA,CACE,KAAQ,YACV,EACA,CACE,KAAQ,OACV,EACA,CACE,KAAQ,QACV,EACA,CACE,KAAQ,UACV,EACA,CACE,KAAQ,OACV,EACA,CACE,KAAQ,OACV,EACA,CACE,KAAQ,WACV,EACA,CACE,KAAQ,aACV,EACA,CACE,KAAQ,WACV,EACA,CACE,KAAQ,QACV,EACA,CACE,KAAQ,eACV,EACA,CACE,KAAQ,aACV,EACA,CACE,KAAQ,iBACV,EACA,CACE,KAAQ,YACV,EACA,CACE,KAAQ,qBACV,EACA,CACE,KAAQ,iBACV,EACA,CACE,KAAQ,mBACV,EACA,CACE,KAAQ,cACV,EACA,CACE,KAAQ,QACV,EACA,CACE,KAAQ,MACV,CACF,CACF,EACA,aAAc,CACZ,KAAQ,CACN,CACE,KAAQ,cACV,EACA,CACE,KAAQ,SACV,EACA,CACE,KAAQ,WACV,EACA,CACE,KAAQ,MACV,EACA,CACE,KAAQ,MACV,EACA,CACE,KAAQ,UACV,EACA,CACE,KAAQ,SACV,EACA,CACE,KAAQ,IACV,EACA,CACE,KAAQ,SACV,EACA,CACE,KAAQ,SACV,EACA,CACE,KAAQ,UACV,EACA,CACE,KAAQ,KACV,EACA,CACE,KAAQ,aACV,EACA,CACE,KAAQ,QACV,EACA,CACE,KAAQ,MACV,EACA,CACE,KAAQ,aACV,EACA,CACE,KAAQ,KACV,EACA,CACE,KAAQ,KACV,EACA,CACE,KAAQ,MACV,EACA,CACE,KAAQ,SACV,EACA,CACE,KAAQ,KACV,EACA,CACE,KAAQ,YACV,EACA,CACE,KAAQ,YACV,EACA,CACE,KAAQ,iBACV,EACA,CACE,KAAQ,QACV,EACA,CACE,KAAQ,cACV,EACA,CACE,KAAQ,OACV,EACA,CACE,KAAQ,UACV,EACA,CACE,KAAQ,UACV,EACA,CACE,KAAQ,WACV,EACA,CACE,KAAQ,YACV,EACA,CACE,KAAQ,OACV,EACA,CACE,KAAQ,QACV,EACA,CACE,KAAQ,UACV,EACA,CACE,KAAQ,OACV,EACA,CACE,KAAQ,OACV,EACA,CACE,KAAQ,WACV,EACA,CACE,KAAQ,aACV,EACA,CACE,KAAQ,WACV,EACA,CACE,KAAQ,QACV,EACA,CACE,KAAQ,eACV,EACA,CACE,KAAQ,aACV,EACA,CACE,KAAQ,iBACV,EACA,CACE,KAAQ,YACV,EACA,CACE,KAAQ,qBACV,EACA,CACE,KAAQ,iBACV,EACA,CACE,KAAQ,mBACV,EACA,CACE,KAAQ,cACV,EACA,CACE,KAAQ,QACV,EACA,CACE,KAAQ,MACV,CACF,CACF,EACA,QAAW,CACT,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,0BACV,CACF,CACF,EACA,cAAe,CACb,KAAQ,CACN,CACE,KAAQ,MACV,EACA,CACE,KAAQ,UACV,EACA,CACE,KAAQ,SACV,EACA,CACE,KAAQ,MACV,EACA,CACE,KAAQ,SACV,EACA,CACE,KAAQ,SACV,EACA,CACE,KAAQ,aACV,EACA,CACE,KAAQ,aACV,EACA,CACE,KAAQ,UACV,CACF,CACF,EACA,cAAe,CACb,KAAQ,CACN,CACE,KAAQ,MACV,EACA,CACE,KAAQ,UACV,EACA,CACE,KAAQ,SACV,EACA,CACE,KAAQ,MACV,EACA,CACE,KAAQ,SACV,EACA,CACE,KAAQ,SACV,EACA,CACE,KAAQ,aACV,EACA,CACE,KAAQ,aACV,EACA,CACE,KAAQ,UACV,CACF,CACF,EACA,UAAa,CACX,KAAQ,CACN,CACE,KAAQ,SACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,IACV,CACF,CACF,EACA,WAAc,CACZ,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,6BACV,CACF,CACF,EACA,YAAe,CACb,KAAQ,CACN,CACE,KAAQ,SACV,CACF,CACF,EACA,WAAc,CACZ,KAAQ,CACN,CACE,KAAQ,SACV,CACF,CACF,EACA,iBAAoB,CAClB,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,KAAQ,CACN,CACE,KAAQ,SACV,CACF,CACF,EACA,QAAW,CACT,KAAQ,CACN,CACE,KAAQ,0BACV,CACF,CACF,EACA,QAAW,CACT,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,0BACV,CACF,CACF,CACF,CACF,EACA,sCAAyC,CACvC,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,KAAQ,CACN,IAAO,EACP,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,EACA,KAAQ,CACN,IAAO,EACP,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,CACF,CACF,EACA,yBAA4B,CAC1B,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,cAAiB,CACf,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,uCACV,CACF,CACF,EACA,YAAe,CACb,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,QAAW,CACT,KAAQ,CACN,CACE,KAAQ,SACV,CACF,CACF,EACA,MAAS,CACP,IAAO,EACP,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,CACF,CACF,EACA,sBAAyB,CACvB,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,KAAQ,CACN,IAAO,EACP,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,IAAO,CACL,IAAO,EACP,KAAQ,CACN,CACE,KAAQ,aACV,CACF,CACF,EACA,IAAO,CACL,IAAO,EACP,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,CACF,CACF,EACA,sBAAyB,CACvB,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,KAAQ,CACN,IAAO,EACP,KAAQ,CACN,CACE,KAAQ,KACV,CACF,CACF,EACA,QAAW,CACT,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,YACR,cAAiB,CACf,8DACA,6DACF,CACF,CACF,CACF,EACA,cAAiB,CACf,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,YACR,cAAiB,CACf,8DACA,6DACF,CACF,CACF,CACF,EACA,YAAe,CACb,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,EACA,WAAc,CACZ,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,CACF,CACF,EACA,yBAA4B,CAC1B,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,MAAS,CACP,IAAO,EACP,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,WAAY,CACV,IAAO,EACP,KAAQ,CACN,CACE,KAAQ,cACV,EACA,CACE,KAAQ,SACV,EACA,CACE,KAAQ,WACV,EACA,CACE,KAAQ,MACV,EACA,CACE,KAAQ,MACV,EACA,CACE,KAAQ,UACV,EACA,CACE,KAAQ,SACV,EACA,CACE,KAAQ,IACV,EACA,CACE,KAAQ,SACV,EACA,CACE,KAAQ,SACV,EACA,CACE,KAAQ,UACV,EACA,CACE,KAAQ,KACV,EACA,CACE,KAAQ,aACV,EACA,CACE,KAAQ,QACV,EACA,CACE,KAAQ,MACV,EACA,CACE,KAAQ,aACV,EACA,CACE,KAAQ,KACV,EACA,CACE,KAAQ,KACV,EACA,CACE,KAAQ,MACV,EACA,CACE,KAAQ,SACV,EACA,CACE,KAAQ,KACV,EACA,CACE,KAAQ,YACV,EACA,CACE,KAAQ,YACV,EACA,CACE,KAAQ,iBACV,EACA,CACE,KAAQ,QACV,EACA,CACE,KAAQ,cACV,EACA,CACE,KAAQ,OACV,EACA,CACE,KAAQ,UACV,EACA,CACE,KAAQ,UACV,EACA,CACE,KAAQ,WACV,EACA,CACE,KAAQ,YACV,EACA,CACE,KAAQ,OACV,EACA,CACE,KAAQ,QACV,EACA,CACE,KAAQ,UACV,EACA,CACE,KAAQ,OACV,EACA,CACE,KAAQ,OACV,EACA,CACE,KAAQ,WACV,EACA,CACE,KAAQ,aACV,EACA,CACE,KAAQ,WACV,EACA,CACE,KAAQ,QACV,EACA,CACE,KAAQ,eACV,EACA,CACE,KAAQ,aACV,EACA,CACE,KAAQ,iBACV,EACA,CACE,KAAQ,YACV,EACA,CACE,KAAQ,qBACV,EACA,CACE,KAAQ,iBACV,EACA,CACE,KAAQ,mBACV,EACA,CACE,KAAQ,cACV,EACA,CACE,KAAQ,QACV,EACA,CACE,KAAQ,MACV,CACF,CACF,CACF,CACF,EACA,4BAA+B,CAC7B,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,IAAO,CACL,IAAO,EACP,KAAQ,CACN,CACE,KAAQ,IACV,CACF,CACF,EACA,aAAgB,CACd,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,SAAY,CACV,IAAO,EACP,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,EACA,MAAS,CACP,IAAO,EACP,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,WAAc,CACZ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,MAAS,CACP,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,OAAU,CACR,KAAQ,CACN,CACE,KAAQ,YACR,cAAiB,CAAC,6DAA6D,CACjF,CACF,CACF,CACF,CACF,EACA,yBAA4B,CAC1B,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,SAAY,CACV,IAAO,EACP,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,EACA,YAAe,CACb,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,SAAY,CACV,KAAQ,CACN,CACE,KAAQ,YACR,cAAiB,CAAC,kDAAkD,CACtE,CACF,CACF,CACF,CACF,EACA,yBAA4B,CAC1B,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,SAAY,CACV,IAAO,EACP,KAAQ,CACN,CACE,KAAQ,IACV,CACF,CACF,EACA,SAAY,CACV,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,EACA,IAAO,CACL,IAAO,EACP,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,QAAW,CACT,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,CACF,CACF,EACA,WAAc,CACZ,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,YAAe,CACb,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,KAAQ,CACN,KAAQ,CACN,CACE,KAAQ,IACV,CACF,CACF,EACA,SAAY,CACV,IAAO,EACP,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,EACA,WAAc,CACZ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,KAAQ,CACN,CACE,KAAQ,KACV,CACF,CACF,CACF,CACF,EACA,UAAa,CACX,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,IAAO,CACL,IAAO,EACP,KAAQ,CACN,CACE,KAAQ,KACV,CACF,CACF,EACA,WAAY,CACV,KAAQ,CACN,CACE,KAAQ,cACV,EACA,CACE,KAAQ,SACV,EACA,CACE,KAAQ,WACV,EACA,CACE,KAAQ,MACV,EACA,CACE,KAAQ,MACV,EACA,CACE,KAAQ,UACV,EACA,CACE,KAAQ,SACV,EACA,CACE,KAAQ,IACV,EACA,CACE,KAAQ,SACV,EACA,CACE,KAAQ,SACV,EACA,CACE,KAAQ,UACV,EACA,CACE,KAAQ,KACV,EACA,CACE,KAAQ,aACV,EACA,CACE,KAAQ,QACV,EACA,CACE,KAAQ,MACV,EACA,CACE,KAAQ,aACV,EACA,CACE,KAAQ,KACV,EACA,CACE,KAAQ,KACV,EACA,CACE,KAAQ,MACV,EACA,CACE,KAAQ,SACV,EACA,CACE,KAAQ,KACV,EACA,CACE,KAAQ,YACV,EACA,CACE,KAAQ,YACV,EACA,CACE,KAAQ,iBACV,EACA,CACE,KAAQ,QACV,EACA,CACE,KAAQ,cACV,EACA,CACE,KAAQ,OACV,EACA,CACE,KAAQ,UACV,EACA,CACE,KAAQ,UACV,EACA,CACE,KAAQ,WACV,EACA,CACE,KAAQ,YACV,EACA,CACE,KAAQ,OACV,EACA,CACE,KAAQ,QACV,EACA,CACE,KAAQ,UACV,EACA,CACE,KAAQ,OACV,EACA,CACE,KAAQ,OACV,EACA,CACE,KAAQ,WACV,EACA,CACE,KAAQ,aACV,EACA,CACE,KAAQ,WACV,EACA,CACE,KAAQ,QACV,EACA,CACE,KAAQ,eACV,EACA,CACE,KAAQ,aACV,EACA,CACE,KAAQ,iBACV,EACA,CACE,KAAQ,YACV,EACA,CACE,KAAQ,qBACV,EACA,CACE,KAAQ,iBACV,EACA,CACE,KAAQ,mBACV,EACA,CACE,KAAQ,cACV,EACA,CACE,KAAQ,QACV,EACA,CACE,KAAQ,MACV,CACF,CACF,CACF,CACF,EACA,UAAa,CACX,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,IAAO,CACL,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,EACA,KAAQ,CACN,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,OAAU,CACR,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,MAAS,CACP,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,OAAU,CACR,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,OAAU,CACR,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,OAAU,CACR,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,CACF,CACF,EACA,WAAc,CACZ,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,IAAO,CACL,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,EACA,KAAQ,CACN,KAAQ,CACN,CACE,KAAQ,iBACV,CACF,CACF,EACA,OAAU,CACR,KAAQ,CACN,CACE,KAAQ,KACV,CACF,CACF,EACA,MAAS,CACP,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,OAAU,CACR,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,SAAY,CACV,KAAQ,CACN,CACE,KAAQ,YACR,cAAiB,CAAC,sDAAsD,CAC1E,CACF,CACF,CACF,CACF,EACA,gBAAmB,CACjB,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,kBAAqB,CACnB,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,QAAW,CACT,IAAO,EACP,KAAQ,CACN,CACE,KAAQ,iBACV,CACF,CACF,EACA,aAAgB,CACd,KAAQ,CACN,CACE,KAAQ,iBACV,CACF,CACF,EACA,OAAU,CACR,IAAO,EACP,KAAQ,CACN,CACE,KAAQ,iBACV,CACF,CACF,EACA,UAAa,CACX,IAAO,EACP,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,YAAe,CACb,KAAQ,CACN,CACE,KAAQ,UACV,CACF,CACF,CACF,CACF,EACA,KAAQ,CACN,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,UAAa,CACX,KAAQ,CACN,CACE,KAAQ,IACV,CACF,CACF,EACA,YAAe,CACb,KAAQ,CACN,CACE,KAAQ,SACV,CACF,CACF,EACA,OAAU,CACR,KAAQ,CACN,CACE,KAAQ,KACV,CACF,CACF,EACA,QAAW,CACT,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,YACR,cAAiB,CAAC,6DAA6D,CACjF,CACF,CACF,EACA,SAAY,CACV,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,IAAO,CACL,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,QAAW,CACT,KAAQ,CACN,CACE,KAAQ,KACV,CACF,CACF,EACA,OAAU,CACR,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,WAAc,CACZ,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,QAAW,CACT,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,SAAY,CACV,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,YAAe,CACb,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,CACF,CACF,EACA,MAAS,CACP,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,MAAS,CACP,KAAQ,CACN,CACE,KAAQ,SACV,CACF,CACF,EACA,SAAY,CACV,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,CACF,CACF,EACA,UAAa,CACX,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,OAAU,CACR,IAAO,EACP,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,EACA,IAAO,CACL,IAAO,EACP,KAAQ,CACN,CACE,KAAQ,OACV,CACF,CACF,CACF,CACF,EACA,oBAAuB,CACrB,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,KAAQ,CACN,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,EACA,IAAO,CACL,IAAO,EACP,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,EACA,IAAO,CACL,KAAQ,CACN,CACE,KAAQ,SACV,CACF,CACF,EACA,IAAO,CACL,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,cAAiB,CACf,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,KAAQ,CACN,IAAO,EACP,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,EACA,QAAW,CACT,KAAQ,CACN,CACE,KAAQ,YACR,cAAiB,CAAC,6DAA6D,CACjF,CACF,CACF,CACF,CACF,EACA,OAAU,CACR,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,MAAS,CACP,KAAQ,CACN,CACE,KAAQ,UACV,CACF,CACF,EACA,IAAO,CACL,KAAQ,CACN,CACE,KAAQ,UACV,CACF,CACF,CACF,CACF,EACA,WAAc,CACZ,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,kBAAqB,CACnB,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,SAAU,CACR,KAAQ,CACN,CACE,KAAQ,OACV,EACA,CACE,KAAQ,iBACV,CACF,CACF,EACA,OAAU,CACR,KAAQ,CACN,CACE,KAAQ,iBACV,CACF,CACF,EACA,KAAQ,CACN,KAAQ,CACN,CACE,KAAQ,iBACV,CACF,CACF,EACA,uBAA0B,CACxB,KAAQ,CACN,CACE,KAAQ,iBACV,CACF,CACF,CACF,CACF,EACA,mBAAsB,CACpB,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,kBAAqB,CACnB,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,OAAU,CACR,KAAQ,CACN,CACE,KAAQ,UACV,CACF,CACF,EACA,MAAS,CACP,KAAQ,CACN,CACE,KAAQ,UACV,CACF,CACF,EACA,MAAS,CACP,KAAQ,CACN,CACE,KAAQ,UACV,CACF,CACF,EACA,OAAU,CACR,KAAQ,CACN,CACE,KAAQ,UACV,CACF,CACF,EACA,cAAiB,CACf,KAAQ,CACN,CACE,KAAQ,UACV,CACF,CACF,EACA,iBAAoB,CAClB,KAAQ,CACN,CACE,KAAQ,UACV,CACF,CACF,EACA,MAAS,CACP,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,MAAS,CACP,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,QAAW,CACT,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,MAAS,CACP,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,YACV,CACF,CACF,EACA,QAAW,CACT,KAAQ,CACN,CACE,KAAQ,iBACV,CACF,CACF,CACF,CACF,EACA,iBAAoB,CAClB,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,kBAAqB,CACnB,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,WAAc,CACZ,KAAQ,CACN,CACE,KAAQ,YACV,CACF,CACF,EACA,KAAQ,CACN,IAAO,EACP,KAAQ,CACN,CACE,KAAQ,iBACV,CACF,CACF,EACA,OAAU,CACR,IAAO,EACP,KAAQ,CACN,CACE,KAAQ,UACV,CACF,CACF,EACA,6BAAgC,CAC9B,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,iBACV,CACF,CACF,CACF,CACF,EACA,SAAY,CACV,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,MAAS,CACP,KAAQ,CACN,CACE,KAAQ,SACV,CACF,CACF,EACA,WAAc,CACZ,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,EACA,KAAQ,CACN,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,OAAU,CACR,KAAQ,CACN,CACE,KAAQ,KACV,CACF,CACF,EACA,KAAQ,CACN,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,CACF,CACF,EACA,MAAS,CACP,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,IAAO,CACL,KAAQ,CACN,CACE,KAAQ,WACR,QAAW,CAAC,wDAAwD,CACtE,CACF,CACF,EACA,KAAQ,CACN,KAAQ,CACN,CACE,KAAQ,WACR,QAAW,CAAC,wDAAwD,CACtE,CACF,CACF,CACF,CACF,EACA,MAAS,CACP,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,UAAa,CACX,KAAQ,CACN,CACE,KAAQ,UACV,CACF,CACF,EACA,YAAe,CACb,KAAQ,CACN,CACE,KAAQ,UACV,CACF,CACF,CACF,CACF,EACA,UAAa,CACX,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,UAAa,CACX,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,KAAQ,CACN,KAAQ,CACN,CACE,KAAQ,KACV,CACF,CACF,EACA,WAAc,CACZ,KAAQ,CACN,CACE,KAAQ,YACV,CACF,CACF,EACA,QAAW,CACT,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,CACF,CACF,EACA,gBAAmB,CACjB,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,KAAQ,CACN,IAAO,EACP,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,EACA,MAAS,CACP,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,QAAW,CACT,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,SAAY,CACV,KAAQ,CACN,CACE,KAAQ,UACV,CACF,CACF,EACA,IAAO,CACL,KAAQ,CACN,CACE,KAAQ,KACV,CACF,CACF,EACA,SAAY,CACV,KAAQ,CACN,CACE,KAAQ,YACV,CACF,CACF,EACA,SAAY,CACV,KAAQ,CACN,CACE,KAAQ,YACR,cAAiB,CAAC,kDAAkD,CACtE,CACF,CACF,CACF,CACF,EACA,YAAe,CACb,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,OAAU,CACR,IAAO,EACP,KAAQ,CACN,CACE,KAAQ,WACR,QAAW,CAAC,wDAAwD,CACtE,CACF,CACF,EACA,OAAU,CACR,IAAO,EACP,KAAQ,CACN,CACE,KAAQ,SACV,CACF,CACF,EACA,OAAU,CACR,KAAQ,CACN,CACE,KAAQ,SACV,CACF,CACF,EACA,WAAc,CACZ,KAAQ,CACN,CACE,KAAQ,SACV,CACF,CACF,EACA,WAAc,CACZ,KAAQ,CACN,CACE,KAAQ,SACV,CACF,CACF,EACA,WAAc,CACZ,IAAO,EACP,KAAQ,CACN,CACE,KAAQ,aACV,CACF,CACF,EACA,KAAQ,CACN,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,CACF,CACF,EACA,UAAa,CACX,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,KAAQ,CACN,IAAO,EACP,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,KAAQ,CACN,IAAO,EACP,KAAQ,CACN,CACE,KAAQ,SACV,CACF,CACF,EACA,IAAO,CACL,IAAO,EACP,KAAQ,CACN,CACE,KAAQ,YACR,cAAiB,CACf,uDACA,2DACA,wDACA,kDACA,iDACA,sDACF,CACF,CACF,CACF,EACA,WAAc,CACZ,KAAQ,CACN,CACE,KAAQ,YACR,cAAiB,CACf,uDACA,2DACA,wDACA,kDACA,iDACA,sDACF,CACF,CACF,CACF,EACA,aAAgB,CACd,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,EACA,UAAa,CACX,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,EACA,KAAQ,CACN,KAAQ,CACN,CACE,KAAQ,cACV,CACF,CACF,CACF,CACF,EACA,gBAAmB,CACjB,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,kBAAqB,CACnB,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,YAAa,CACX,KAAQ,CACN,CACE,KAAQ,UACV,EACA,CACE,KAAQ,OACV,EACA,CACE,KAAQ,QACV,CACF,CACF,EACA,WAAc,CACZ,KAAQ,CACN,CACE,KAAQ,iBACV,CACF,CACF,EACA,WAAc,CACZ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,eAAkB,CAChB,KAAQ,CACN,CACE,KAAQ,+BACV,CACF,CACF,CACF,CACF,EACA,8BAAiC,CAC/B,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,SAAY,CACV,KAAQ,CACN,CACE,KAAQ,UACV,CACF,CACF,EACA,UAAa,CACX,KAAQ,CACN,CACE,KAAQ,UACV,CACF,CACF,CACF,CACF,EACA,OAAU,CACR,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,kBAAqB,CACnB,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,MAAS,CACP,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,UACV,CACF,CACF,EACA,OAAU,CACR,KAAQ,CACN,CACE,KAAQ,cACV,CACF,CACF,EACA,KAAQ,CACN,KAAQ,CACN,CACE,KAAQ,iBACV,CACF,CACF,CACF,CACF,EACA,aAAgB,CACd,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,YAAa,CACX,KAAQ,CACN,CACE,KAAQ,UACV,EACA,CACE,KAAQ,OACV,EACA,CACE,KAAQ,QACV,CACF,CACF,EACA,MAAS,CACP,KAAQ,CACN,CACE,KAAQ,aACV,CACF,CACF,EACA,SAAY,CACV,KAAQ,CACN,CACE,KAAQ,aACV,CACF,CACF,EACA,SAAY,CACV,KAAQ,CACN,CACE,KAAQ,SACV,CACF,CACF,EACA,YAAe,CACb,KAAQ,CACN,CACE,KAAQ,SACV,CACF,CACF,EACA,aAAgB,CACd,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,EACA,UAAa,CACX,KAAQ,CACN,CACE,KAAQ,aACV,CACF,CACF,EACA,aAAgB,CACd,KAAQ,CACN,CACE,KAAQ,aACV,CACF,CACF,EACA,OAAU,CACR,KAAQ,CACN,CACE,KAAQ,SACV,CACF,CACF,EACA,UAAa,CACX,KAAQ,CACN,CACE,KAAQ,SACV,CACF,CACF,EACA,WAAc,CACZ,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,EACA,KAAQ,CACN,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,EACA,OAAU,CACR,KAAQ,CACN,CACE,KAAQ,aACV,CACF,CACF,CACF,CACF,EACA,kBAAqB,CACnB,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,KAAQ,CACN,IAAO,EACP,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,EACA,KAAQ,CACN,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,YAAa,CACX,KAAQ,CACN,CACE,KAAQ,QACV,EACA,CACE,KAAQ,YACR,cAAiB,CAAC,kDAAkD,CACtE,EACA,CACE,KAAQ,MACV,EACA,CACE,KAAQ,UACV,CACF,CACF,EACA,KAAQ,CACN,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,iBACV,CACF,CACF,EACA,UAAa,CACX,KAAQ,CACN,CACE,KAAQ,YACV,CACF,CACF,CACF,CACF,EACA,aAAgB,CACd,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,KAAQ,CACN,IAAO,EACP,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,WAAY,CACV,IAAO,EACP,KAAQ,CACN,CACE,KAAQ,iBACV,EACA,CACE,KAAQ,UACV,EACA,CACE,KAAQ,OACV,EACA,CACE,KAAQ,YACR,cAAiB,CACf,yDACA,wDACA,wDACA,4DACA,gDACA,mDACA,sDACF,CACF,CACF,CACF,CACF,CACF,EACA,cAAiB,CACf,SAAY,CACV,GAAM,CACJ,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,UAAa,CACX,IAAO,iBACP,KAAQ,CACN,CACE,KAAQ,WACV,CACF,CACF,EACA,MAAS,CACP,KAAQ,CACN,CACE,KAAQ,SACV,CACF,CACF,EACA,WAAc,CACZ,KAAQ,CACN,CACE,KAAQ,MACV,CACF,CACF,EACA,KAAQ,CACN,KAAQ,CACN,CACE,KAAQ,QACV,CACF,CACF,EACA,OAAU,CACR,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",
  "names": ["PrefixOperatorAtom", "operator", "child", "InfixOperatorAtom", "left", "right", "ParserBuilder", "tokenType", "parselet", "precedence", "builder", "parser", "token", "input", "Parser", "tokens", "prefixParselets", "infixParselets", "expected", "prefix", "next", "nextToken", "expectedId", "expectedValue", "actual", "t", "LRUCache", "max", "key", "item", "val", "UCUM", "LOINC", "SNOMED", "RXNORM", "CPT", "ICD10", "NDC", "HTTP_HL7_ORG", "HTTP_TERMINOLOGY_HL7_ORG", "OK_ID", "CREATED_ID", "GONE_ID", "NOT_MODIFIED_ID", "FOUND_ID", "NOT_FOUND_ID", "CONFLICT_ID", "UNAUTHORIZED_ID", "FORBIDDEN_ID", "PRECONDITION_FAILED_ID", "MULTIPLE_MATCHES_ID", "TOO_MANY_REQUESTS_ID", "ACCEPTED_ID", "SERVER_TIMEOUT_ID", "allOk", "created", "notModified", "notFound", "unauthorized", "unauthorizedTokenExpired", "unauthorizedTokenAudience", "forbidden", "gone", "preconditionFailed", "multipleMatches", "tooManyRequests", "accepted", "location", "badRequest", "details", "expression", "conflict", "code", "validationError", "serverError", "err", "serverTimeout", "msg", "redirect", "url", "urlStr", "isOperationOutcome", "value", "isOk", "outcome", "isCreated", "isAccepted", "isRedirect", "isNotFound", "isConflict", "isGone", "isUnauthenticated", "getStatus", "assertOk", "resource", "OperationOutcomeError", "cause", "operationOutcomeToString", "normalizeOperationOutcome", "error", "normalizeErrorString", "strs", "operationOutcomeIssueToString", "issue", "issueStr", "createOperationOutcomeIssue", "severity", "message", "path", "data", "createStructureIssue", "createConstraintIssue", "constraint", "createProcessingIssue", "normalizedTypes", "compressElement", "element", "outputPropertySchema", "inflateElement", "path", "partial", "max", "inflateBaseSchema", "base", "output", "key", "schema", "property", "base_schema_default", "parseStructureDefinition", "sd", "StructureDefinitionParser", "DATA_TYPES", "inflateBaseSchema", "base_schema_default", "PROFILE_SCHEMAS_BY_URL", "PROFILE_DATA_TYPES", "TYPE_SPECIAL_CASES", "getDataTypesMap", "profileUrl", "dataTypes", "indexStructureDefinitionBundle", "bundle", "sds", "e", "r", "indexDefaultSearchParameters", "loadDataType", "schema", "specialCase", "typeName", "inner", "getAllDataTypes", "isDataTypeLoaded", "type", "tryGetDataType", "profileType", "getDataType", "OperationOutcomeError", "badRequest", "isResourceType", "resourceType", "typeSchema", "isResourceTypeSchema", "isProfileLoaded", "tryGetProfile", "getDescription", "element", "path", "elementPath", "field", "parentContext", "pathsCompatible", "getElementDefinitionTypeName", "hasDefaultExtensionSlice", "d", "contentRefPath", "ref", "current", "next", "t", "ed", "code", "getExtension", "max", "parseCardinality", "baseMax", "typedElementDef", "c", "firstValue", "getTypedPropertyValue", "subsetResource", "resource", "properties", "extraProperties", "property", "choiceTypeField", "capitalize", "mandatorySubsetProperties", "subsetTag", "prefix", "trimPrefix", "str", "parent", "child", "obj", "isEmpty", "discriminators", "result", "crawlTypedValue", "typedValue", "visitor", "options", "Crawler", "crawlTypedValueAsync", "AsyncCrawler", "root", "getDataType", "obj", "schema", "path", "objIsResource", "isResource", "key", "parent", "propertyValues", "getNestedProperty", "propertyValue", "value", "arrayify", "isPrimitiveType", "type", "propertyGetter", "getTypedPropertyValueWithPath", "getTypedPropertyValue", "firstProp", "nestedProps", "prop", "next", "current", "element", "input", "parentPath", "withPath", "tv", "parentPrefix", "v", "idx", "fhirTypeToJsType", "fhirPathCache", "LRUCache", "isPrimitiveType", "code", "validationRegexes", "skippedConstraintKeys", "validateResource", "resource", "options", "OperationOutcomeError", "validationError", "ResourceValidator", "toTypedValue", "validateTypedValue", "typedValue", "isResource", "parseStructureDefinition", "getDataType", "checkObjectForNull", "crawlTypedValue", "issues", "foundError", "issue", "_path", "obj", "schema", "_parent", "key", "path", "propertyValues", "element", "value", "values", "createStructureIssue", "matchesSpecifiedValue", "sliceCounts", "s", "sliceName", "checkSliceElement", "field", "isEmpty", "slices", "counts", "slice", "sliceCardinality", "parent", "properties", "object", "choiceOfTypeElements", "choiceOfTypeElementName", "isChoiceOfType", "relatedElementName", "requiredRelatedElementName", "createOperationOutcomeIssue", "constraints", "constraint", "createConstraintIssue", "reference", "isReference", "referenceResourceType", "targetProfiles", "t", "hl7BaseUrl", "HTTP_HL7_ORG", "hl7AllResourcesUrl", "hl7ResourceTypeUrl", "medplumBaseUrl", "medplumResourceTypeUrl", "targetProfile", "variables", "UCUM", "evalValues", "evalFhirPathTyped", "e", "createProcessingIssue", "primitiveValue", "extensionElement", "unpackPrimitiveElement", "type", "expectedType", "str", "regex", "n", "isIntegerType", "PropertyType", "propertyType", "propertyDefinitions", "prefix", "parts", "testProperty", "part", "elementName", "getTypedPropertyValue", "propertyPath", "partnerKey", "i", "typeAndValue", "v", "deepIncludes", "deepEquals", "matchDiscriminant", "discriminator", "elements", "sliceElement", "sliceType", "slicingRules", "arrayify", "getNestedProperty", "primitiveKeys", "extensionEntries", "k", "_", "booleanToTypedValue", "value", "PropertyType", "toTypedValue", "isQuantity", "isResource", "isCodeableConcept", "isCoding", "toJsBoolean", "obj", "singleton", "collection", "type", "getTypedPropertyValue", "input", "path", "options", "elementDefinition", "getElementDefinition", "getTypedPropertyValueWithSchema", "getTypedPropertyValueWithoutSchema", "typedValue", "element", "types", "resultValue", "resultType", "primitiveExtension", "lastPathSegmentIndex", "lastPathSegment", "candidatePath", "capitalize", "i", "assignPrimitiveExtension", "isEmpty", "toTypedValueWithType", "result", "propertyValue", "trimmedPath", "propertyType", "propertyName", "v", "removeDuplicates", "arr", "found", "j", "fhirPathEquals", "fhirPathNot", "fhirPathArrayEquals", "x", "y", "val", "index", "fhirPathArrayNotEquals", "xValue", "yValue", "isQuantityEquivalent", "deepEquals", "fhirPathArrayEquivalent", "fhirPathEquivalentCompare", "fhirPathEquivalent", "xType", "xValueRaw", "yType", "yValueRaw", "fhirPathIs", "desiredType", "cleanType", "isDateString", "isDateTimeString", "isPeriod", "validationRegexes", "toPeriod", "dateStringToInstantString", "fill", "object1", "object2", "keys1", "keys2", "key", "val1", "val2", "isObject", "target", "safeAssign", "source", "isResourceWithId", "resource", "resourceType", "isResource", "createReference", "reference", "getReferenceString", "display", "getDisplayString", "input", "isReference", "resolveId", "parseReference", "OperationOutcomeError", "validationError", "type", "id", "isProfileResource", "profileName", "getProfileResourceDisplayString", "deviceName", "getDeviceDisplayString", "formatCodeableConcept", "code", "isCodeableConcept", "isTextObject", "names", "formatHumanName", "device", "getImageSrc", "photo", "p", "url", "getPhotoImageSrc", "getDateProperty", "date", "calculateAge", "birthDateStr", "endDateStr", "startDate", "endDate", "startYear", "startMonth", "startDay", "endYear", "endMonth", "endDay", "years", "months", "days", "calculateAgeString", "getQuestionnaireAnswers", "response", "result", "buildQuestionnaireAnswerItems", "items", "item", "getAllQuestionnaireAnswers", "buildAllQuestionnaireAnswerItems", "getIdentifier", "system", "identifiers", "array", "identifier", "setIdentifier", "value", "getExtensionValue", "urls", "extension", "getExtension", "typedValue", "getTypedPropertyValue", "curr", "i", "e", "stringify", "pretty", "processedValue", "removeEmptyFromUnknown", "removeEmptyFromArray", "removeEmptyFromObject", "inputArray", "len", "newArray", "count", "inputElement", "processedElement", "inputObject", "newObject", "key", "inputValue", "isEmpty", "v", "t", "isPopulated", "arg", "deepEquals", "object1", "object2", "path", "deepEqualsArray", "isObject", "deepEqualsObject", "array1", "array2", "keySet", "k", "val1", "val2", "deepIncludes", "pattern", "deepIncludesArray", "deepIncludesObject", "patternVal", "valueVal", "patternKey", "deepClone", "isUUID", "obj", "isStringArray", "arr", "isString", "isCoding", "byteToHex", "n", "arrayBufferToHex", "arrayBuffer", "buffer", "normalizeArrayBufferView", "bytes", "arrayBufferToBase64", "typedArrayOrBuffer", "capitalize", "word", "isLowerCase", "c", "isComplexTypeCode", "getPathDifference", "parentPath", "parentPathPrefix", "getCodeBySystem", "concept", "coding", "setCodeBySystem", "findObservationInterval", "definition", "patient", "category", "interval", "observationIntervalMatchesPatient", "observationIntervalMatchesValue", "findObservationReferenceRange", "findObservationReferenceRanges", "observationIntervalMatchesGender", "observationIntervalMatchesAge", "matchesRange", "precision", "range", "preciseGreaterThanOrEquals", "preciseLessThanOrEquals", "preciseRound", "a", "preciseEquals", "b", "toPreciseInteger", "preciseLessThan", "preciseGreaterThan", "findResourceByCode", "resources", "r", "arrayify", "singularize", "sleep", "ms", "resolve", "splitN", "str", "delim", "delimIndex", "lazy", "fn", "executed", "append", "sortStringArray", "ensureTrailingSlash", "ensureNoLeadingSlash", "concatUrls", "baseUrl", "getWebSocketUrl", "getQueryString", "query", "entry", "VALID_HOSTNAME_REGEX", "isValidHostname", "addProfileToResource", "profileUrl", "mapByIdentifier", "resourceBundle", "identifierSystem", "removeProfileFromResource", "index", "flatMapFilter", "resultValue", "escapeHtml", "unsafe", "typedValueToString", "typedValue", "formatAddress", "formatCodeableConcept", "formatCoding", "formatHumanName", "formatQuantity", "formatReferenceString", "value", "stringify", "address", "options", "builder", "cityStateZip", "name", "textStr", "ensureString", "formatGivenName", "formatFamilyName", "isValidDate", "date", "formatDate", "locales", "d", "formatTime", "time", "formatDateTime", "dateTime", "formatPeriod", "period", "unitAdverbForm", "singularUnits", "pluralUnits", "formatTiming", "timing", "formatTimingRepeat", "capitalize", "repeat", "frequency", "periodUnit", "t", "formatRange", "range", "precision", "exclusive", "low", "high", "preciseDecrement", "preciseIncrement", "quantity", "result", "formatMoney", "money", "codeableConcept", "c", "coding", "includeCode", "display", "code", "formatObservationValue", "obs", "valueString", "input", "a", "n", "toPreciseInteger", "PropertyType", "indexSearchParameterBundle", "bundle", "entry", "resource", "indexSearchParameter", "indexDefaultSearchParameters", "maybeSDs", "e", "sd", "getOrInitTypeSchema", "resourceType", "typeSchema", "globalSchema", "searchParam", "getElementDefinitionTypeName", "elementDefinition", "code", "buildTypeName", "components", "capitalize", "isResourceTypeSchema", "getResourceTypes", "getAllDataTypes", "schema", "getSearchParameters", "getSearchParameter", "getPathDisplayName", "path", "propertyName", "getPropertyDisplayName", "words", "capitalizeDisplayWord", "capitalizedWords", "word", "upper", "getElementDefinition", "typeName", "profileUrl", "tryGetDataType", "getElementDefinitionFromElements", "elements", "simpleMatch", "i", "c", "testProperty", "element", "isTypedValue", "value", "isResource", "isReference", "stringifyTypedValue", "v", "stringifyCoding", "formatHumanName", "isResourceWithId", "getReferenceString", "coding", "parseDateString", "str", "stub", "functions", "_context", "input", "booleanToTypedValue", "e", "isEmpty", "context", "criteria", "toJsBoolean", "value", "other", "otherArray", "getRootInput", "PropertyType", "result", "num", "numValue", "removeDuplicates", "_input", "_other", "toTypedValue", "criterion", "trueResult", "otherwiseResult", "evalResult", "validateInput", "lowerStr", "parseDateString", "isQuantity", "match", "substringAtom", "applyStringFunc", "str", "substring", "startAtom", "lengthAtom", "start", "length", "startIndex", "endIndex", "prefixAtom", "prefix", "suffixAtom", "suffix", "patternAtom", "substitionAtom", "pattern", "substition", "regexAtom", "regex", "separatorAtom", "separator", "applyMathFunc", "baseAtom", "base", "expAtom", "x", "_nameAtom", "endAtom", "unitsAtom", "startDate", "endDate", "unit", "age", "calculateAge", "typeAtom", "typeName", "SymbolAtom", "DotAtom", "fhirPathIs", "refStr", "ref", "resourceType", "id", "isResource", "systemAtom", "system", "expectedResourceType", "resource", "reference", "resolveId", "urlAtom", "url", "extension", "getExtension", "func", "argsAtoms", "atom", "quantity", "numberInput", "type", "returnValue", "count", "element", "last", "FhirPathAtom", "original", "child", "context", "input", "result", "e", "error", "LiteralAtom", "value", "SymbolAtom", "name", "variableValue", "typedValue", "isResource", "getTypedPropertyValue", "EmptySetAtom", "UnaryOperatorAtom", "PrefixOperatorAtom", "operator", "impl", "AsAtom", "InfixOperatorAtom", "left", "right", "functions", "BooleanInfixOperatorAtom", "ArithemticOperatorAtom", "leftEvalResult", "rightEvalResult", "leftValue", "rightValue", "leftNumber", "isQuantity", "rightNumber", "booleanToTypedValue", "PropertyType", "toTypedValue", "ConcatAtom", "ContainsAtom", "InAtom", "singleton", "fhirPathEquals", "DotAtom", "UnionAtom", "leftResult", "rightResult", "removeDuplicates", "EqualsAtom", "fhirPathArrayEquals", "NotEqualsAtom", "fhirPathArrayNotEquals", "EquivalentAtom", "fhirPathArrayEquivalent", "NotEquivalentAtom", "fhirPathNot", "IsAtom", "typeName", "fhirPathIs", "AndAtom", "OrAtom", "XorAtom", "ImpliesAtom", "FunctionAtom", "args", "arg", "IndexerAtom", "expr", "evalResult", "index", "STANDARD_UNITS", "Tokenizer", "str", "keywords", "operators", "options", "token", "c", "next", "start", "endChar", "unescaped", "match", "hex", "result", "value", "foundTime", "foundTimeZone", "id", "isUnitToken", "twoCharOp", "condition", "mark", "FHIRPATH_KEYWORDS", "FHIRPATH_OPERATORS", "tokenize", "str", "Tokenizer", "OperatorPrecedence", "PARENTHESES_PARSELET", "parser", "expr", "INDEXER_PARSELET", "left", "IndexerAtom", "FUNCTION_CALL_PARSELET", "SymbolAtom", "args", "FunctionAtom", "parseQuantity", "str", "parts", "value", "unit", "initFhirPathParserBuilder", "ParserBuilder", "_", "token", "LiteralAtom", "PropertyType", "parseDateString", "EmptySetAtom", "right", "UnaryOperatorAtom", "x", "ArithemticOperatorAtom", "y", "DotAtom", "UnionAtom", "EqualsAtom", "NotEqualsAtom", "EquivalentAtom", "NotEquivalentAtom", "ConcatAtom", "AndAtom", "AsAtom", "ContainsAtom", "InAtom", "IsAtom", "OrAtom", "XorAtom", "ImpliesAtom", "fhirPathParserBuilder", "parseFhirPath", "input", "FhirPathAtom", "tokenize", "evalFhirPath", "expression", "array", "i", "el", "toTypedValue", "evalFhirPathTyped", "e", "variables", "cache", "ast", "cachedAst", "v", "SearchParameterType", "getSearchParameterDetails", "resourceType", "searchParam", "result", "globalSchema", "buildSearchParameterDetails", "setSearchParameterDetails", "code", "details", "typeSchema", "expressions", "getExpressionsForResourceType", "builder", "expression", "atomArray", "flattenAtom", "flattenedExpression", "lazy", "BooleanInfixOperatorAtom", "crawlSearchParameterDetails", "getSearchParameterType", "getParsedExpressionForResourceType", "atoms", "baseType", "index", "currAtom", "AsAtom", "FunctionAtom", "handleFunctionAtom", "propertyName", "elementDefinition", "getElementDefinition", "hasArrayIndex", "nextIndex", "IndexerAtom", "nextAtom", "elementDefinitionType", "propertyType", "isBackboneElement", "functionAtom", "IsAtom", "propertyTypes", "PropertyType", "fhirPathExpression", "parseFhirPath", "buildExpressionsForResourceType", "getExpressionForResourceType", "atom", "i", "UnionAtom", "FhirPathAtom", "DotAtom", "DEFAULT_SEARCH_COUNT", "DEFAULT_MAX_SEARCH_COUNT", "Operator", "MODIFIER_OPERATORS", "PREFIX_OPERATORS", "parseSearchRequest", "url", "query", "pathname", "searchParams", "path", "search", "resourceType", "queryArray", "key", "value", "v", "parseSearchImpl", "searchRequest", "parseKeyValue", "code", "modifier", "colonIndex", "append", "parseSortRule", "target", "parseIncludeTarget", "param", "globalSchema", "parseParameter", "parseUnknownParameter", "field", "descending", "presenceOperators", "searchParam", "operator", "searchValue", "parsePrefix", "isValidSearchValue", "OperationOutcomeError", "badRequest", "parseModifier", "prefix", "input", "prefixOperator", "parts", "isDateTimeString", "subexpressionPattern", "parseXFhirQuery", "variables", "_", "expr", "replacement", "evalFhirPathTyped", "stringifyTypedValue", "formatSearchQuery", "definition", "params", "filter", "formatFilter", "formatSortRules", "formatIncludeTarget", "sortStringArray", "sortRules", "sr", "kind", "splitSearchOnComma", "result", "current", "escaped", "c", "matchesSearchRequest", "resource", "searchRequest", "filter", "matchesSearchFilter", "searchParam", "globalSchema", "Operator", "matchesMissingOrPresent", "matchesReferenceFilter", "matchesStringFilter", "matchesTokenFilter", "matchesDateFilter", "exists", "evalFhirPath", "values", "negated", "isNegated", "references", "value", "filterValue", "splitSearchOnComma", "match", "reference", "getSearchParameterDetails", "SearchParameterType", "matchesBooleanFilter", "expected", "result", "asToken", "searchParamElementType", "resourceValues", "filterValues", "resourceValue", "PropertyType", "matchesTokenIdentifierValue", "matchesTokenCodeableConceptValue", "matchesStringValue", "operator", "system", "code", "str", "s", "_operator", "coding", "matchesDateValue", "buildDateTimeColumn", "isString", "err", "isPeriod", "universalAccessPolicy", "protectedResourceTypes", "projectAdminResourceTypes", "AccessPolicyInteraction", "readInteractions", "canReadResourceType", "accessPolicy", "resourceType", "accessPolicySupportsInteraction", "canWriteResourceType", "interaction", "policy", "shallowMatchesResourcePolicy", "canWriteResource", "resource", "satisfiedAccessPolicy", "matchesAccessPolicyResourcePolicy", "resourcePolicy", "c", "matchesSearchRequest", "parseSearchRequest", "decodeBase64", "data", "binaryString", "bytes", "c", "encodeBase64", "utf8Bytes", "encodeBase64Url", "decodeBase64Url", "base64", "getRandomString", "randomItems", "arrayBufferToHex", "encryptSHA256", "str", "generateId", "c", "r", "convertToTransactionBundle", "bundle", "idToUuid", "deepClone", "entry", "resource", "id", "generateId", "input", "jsonString", "key", "value", "referenceReplacer", "reorderBundle", "replacement", "adjacencyList", "buildAdjacencyList", "sortedFullUrls", "cycles", "topologicalSortWithCycles", "entryMap", "reorderedEntries", "fullUrl", "cycle", "originalEntry", "putEntry", "VertexState", "graph", "sorted", "state", "vertex", "visit", "path", "cycleStartIndex", "hasCycle", "neighbor", "findReferences", "callback", "isReference", "reference", "convertContainedResourcesToBundle", "simpleBundle", "contained", "ContentType", "EventTarget", "type", "callback", "array", "event", "listener", "TypedEventTarget", "handler", "FHIRCAST_EVENT_NAMES", "FHIRCAST_RESOURCE_TYPES", "FHIRCAST_EVENT_VERSION_REQUIRED", "isContextVersionRequired", "event", "assertContextVersionOptional", "OperationOutcomeError", "validationError", "FHIRCAST_EVENT_RESOURCES", "isFhircastResourceType", "resourceType", "isCompletedSubscriptionRequest", "subscriptionRequest", "serializeFhircastSubscriptionRequest", "validateFhircastSubscriptionRequest", "channelType", "mode", "topic", "events", "formattedSubRequest", "validateSingleResourceContext", "resource", "i", "keySchema", "expectedResourceType", "validateFhircastContext", "context", "keysSeen", "isReference", "validateFhircastContexts", "contexts", "eventSchema", "key", "details", "createFhircastMessagePayload", "versionId", "normalizedContexts", "generateId", "FhircastConnection", "TypedEventTarget", "subRequest", "websocket", "message", "fhircastMessage", "decodePayload", "payload", "decodeBase64Url", "isJwt", "token", "parseJWTPayload", "_header", "_signature", "isMedplumAccessToken", "accessToken", "tryGetJwtExpiration", "exp", "MedplumKeyValueClient", "medplum", "key", "value", "ContentType", "_a", "ReadablePromise", "requestPromise", "res", "err", "onfulfilled", "onrejected", "onfinally", "ClientStorage", "storage", "MemoryStorage", "key", "value", "str", "stringify", "index", "MockAsyncClientStorage", "resolve", "Events", "eventsInitialized", "lazyInitEvents", "error", "target", "code", "reason", "assert", "condition", "msg", "cloneEvent", "e", "DEFAULT", "didWarnAboutMissingWebSocket", "ReconnectingWebSocket", "_ReconnectingWebSocket", "TypedEventTarget", "url", "protocols", "options", "event", "minUptime", "message", "value", "acc", "data", "maxEnqueuedMessages", "args", "reconnectionDelayGrowFactor", "minReconnectionDelay", "maxReconnectionDelay", "delay", "resolve", "maxRetries", "connectionTimeout", "WS", "err", "DEFAULT_PING_INTERVAL_MS", "SubscriptionEmitter", "TypedEventTarget", "criteria", "CriteriaEntry", "subscriptionProps", "SubscriptionManager", "medplum", "wsUrl", "options", "MedplumClient", "OperationOutcomeError", "validationError", "url", "ws", "ReconnectingWebSocket", "event", "parsedData", "bundle", "status", "subscriptionId", "resolveId", "connectEvent", "criteriaEntry", "err", "errorEvent", "emitter", "serverError", "closeEvent", "openEvent", "nextProfile", "error", "disconnectEvent", "getReferenceString", "parameter", "token", "param", "entries", "entry", "deepEquals", "emitters", "mapEntry", "otherEntry", "otherProps", "normalizeErrorString", "newCriteriaEntry", "resourceMatchesSubscriptionCriteria", "resource", "subscription", "context", "getPreviousResource", "logger", "matchesChannelType", "subscriptionCriteria", "searchRequest", "parseSearchRequest", "isFhirCriteriaMet", "supportedInteractionExtension", "getExtension", "matchesSearchRequest", "channelType", "currentResource", "previous", "evalInput", "toTypedValue", "evalFhirPathTyped", "MEDPLUM_VERSION", "MEDPLUM_CLI_CLIENT_ID", "DEFAULT_ACCEPT", "ContentType", "DEFAULT_BASE_URL", "DEFAULT_RESOURCE_CACHE_SIZE", "DEFAULT_BROWSER_CACHE_TIME", "DEFAULT_NODE_CACHE_TIME", "DEFAULT_REFRESH_GRACE_PERIOD", "BINARY_URL_PREFIX", "system", "OAuthGrantType", "OAuthTokenType", "OAuthTokenAuthMethod", "OAuthClientAssertionType", "MedplumClient", "TypedEventTarget", "options", "getDefaultFetch", "ClientStorage", "ensureTrailingSlash", "concatUrls", "LRUCache", "err", "activeLogin", "url", "resourceType", "key", "cached", "promise", "resolve", "reject", "readablePromise", "ReadablePromise", "body", "contentType", "operations", "newUserRequest", "codeChallengeMethod", "codeChallenge", "newProjectRequest", "newPatientRequest", "loginRequest", "loginParams", "code", "authorizeUrl", "clientId", "redirectUri", "baseLogin", "pkceEnabled", "token", "path", "query", "getQueryString", "cacheKey", "b", "bundleToResourceArray", "searchParams", "bundle", "nextLink", "link", "params", "id", "reference", "refString", "isDataTypeLoaded", "response", "indexStructureDefinitionBundle", "searchParameter", "indexSearchParameter", "profileUrl", "isProfileLoaded", "sdBundle", "sd", "loadDataType", "vid", "resource", "result", "arg1", "arg2", "arg3", "arg4", "arg5", "createBinaryOptions", "normalizeCreateBinaryOptions", "fileData", "fileStr", "reader", "requestOptions", "binary", "data", "filename", "securityContext", "onProgress", "xhr", "handleSignalAbort", "sendResult", "e", "OperationOutcomeError", "normalizeOperationOutcome", "headers", "value", "createPdfOptions", "normalizeCreatePdfOptions", "docDefinition", "tableLayouts", "fonts", "rest", "blob", "text", "profile", "encounter", "subject", "createReference", "idOrIdentifier", "identifier", "email", "operationName", "variables", "graphName", "agent", "destination", "waitForResponse", "resolveId", "getReferenceString", "login", "gracePeriod", "accessToken", "refreshToken", "tryGetJwtExpiration", "isMedplumAccessToken", "newLogin", "logins", "profileChanged", "urlString", "createMediaOptions", "additionalFields", "media", "content", "contents", "createDocumentReferenceOptions", "documentReference", "attachment", "exportLevel", "resourceTypes", "since", "fhirPath", "MedplumKeyValueClient", "entry", "t", "method", "state", "isJson", "notFound", "contentLocation", "tryGetContentLocation", "statusUrl", "maxRetries", "attemptNum", "isRetryable", "delayMs", "maxRetryTime", "sleep", "sortStringArray", "res", "rateLimitHeader", "header", "str", "parts", "name", "remainingPart", "p", "remainingUnits", "timePart", "secondsUntilReset", "rateLimits", "retryDelay", "limit", "statusOptions", "entries", "batch", "i", "responseEntry", "isOk", "ifNoneExist", "unauthorized", "pkceState", "getRandomString", "codeVerifier", "arrayHash", "encryptSHA256", "arrayBufferToBase64", "getWindowOrigin", "tokenParams", "clientSecret", "assertion", "scope", "jwt", "encodeBase64", "topic", "events", "validationError", "subRequest", "endpoint", "serializeFhircastSubscriptionRequest", "validateFhircastSubscriptionRequest", "FhircastConnection", "event", "context", "versionId", "isContextVersionRequired", "createFhircastMessagePayload", "assertContextVersionOptional", "projectId", "formBody", "error", "badRequest", "tokens", "isJwt", "tokenPayload", "parseJWTPayload", "unauthorizedTokenExpired", "unauthorizedTokenAudience", "oldState", "newState", "SubscriptionManager", "getWebSocketUrl", "criteria", "subscriptionProps", "location", "isOperationOutcome", "array", "isCreateBinaryOptions", "input", "isObject", "isCreatePdfOptions", "ExternalSecretSystems", "summarizeObservations", "observations", "summaryCode", "summarizeFn", "sampler", "DataSampler", "e", "obs", "opts", "codesOverlap", "expandSampledData", "data", "quantity", "code", "fn", "computedValue", "compressSampledData", "a", "b", "c", "t", "sample", "d", "sampling", "expandSampledObservation", "results", "obsTimestamp", "startTime", "convertSampleToObservations", "component", "template", "values", "parentObservation", "getReferenceString", "i", "value", "dataPointTime", "buildElementsContext", "parentContext", "path", "elements", "profileUrl", "debugMode", "accessPolicyResource", "mergedElements", "mergeElementsForContext", "keyPrefix", "splitN", "removeHiddenFields", "markReadonlyFields", "elementsByPath", "key", "property", "getExtendedProps", "memoizedExtendedProps", "hidden", "matchesKeyPrefixes", "result", "elementPath", "element", "getPathDifference", "usedNewElements", "prefix", "prefixes", "keyParts", "i", "isSliceDefinitionWithTypes", "slice", "isDiscriminatorComponentMatch", "typedValue", "discriminator", "profileUrl", "nestedProp", "getNestedProperty", "elements", "v", "matchDiscriminant", "getValueSliceName", "value", "slices", "discriminators", "d", "SchemaCrawler", "schema", "visitor", "elements", "rootContext", "buildElementsContext", "element", "key", "path", "allowedElements", "elementKey", "slice", "slicing", "visitorSlicing", "isPopulated", "elementTree", "createElementTree", "node", "nodePath", "child", "slices", "slicesToVisit", "isSliceDefinitionWithTypes", "profileUrl", "t", "tryGetProfile", "sliceSchema", "elementsContext", "sliceElements", "rootNodes", "isChildKey", "parentKey", "childKey", "addNode", "currentNode", "newNode", "elementEntries", "a", "b", "added", "rootNode", "SLICE_NAME_KEY", "applyDefaultValuesToResource", "resource", "schema", "visitor", "DefaultValueVisitor", "SchemaCrawler", "applyDefaultValuesToElement", "existingValue", "elements", "key", "elementKey", "element", "applyFixedOrPatternValue", "keyDifference", "getPathDifference", "getDefaultValuesForNewSliceEntry", "slice", "slicing", "rootValue", "path", "type", "deepClone", "elementsContext", "parentValues", "parentPath", "elementValues", "parentValue", "elementsKeyPrefix", "parentArray", "parent", "applyMinimums", "elementValue", "getValueAtKey", "i", "value", "isPopulated", "isEmpty", "setValueAtKey", "sliceValues", "matchingItems", "arrayItem", "getValueSliceName", "isComplexTypeCode", "emptySliceValue", "sliceValuesContext", "sliceValueArray", "sliceValue", "resolvedKey", "code", "capitalize", "keyParts", "last", "answer", "keyPart", "item", "lastItem", "isObject", "inputValue", "iv", "outputValue", "lastArray", "applyPattern", "pattern", "resultObj", "conceptMapTranslate", "map", "params", "OperationOutcomeError", "badRequest", "sourceCodes", "constructSourceSet", "isOperationOutcome", "matches", "translateCodes", "g", "result", "indexCodes", "concept", "system", "code", "key", "groups", "codes", "group", "mappings", "m", "target", "handleUnmappedCodes", "MAPPING_LANGUAGE_OPERATORS", "FHIRPATH_OPERATORS", "tokenize", "str", "Tokenizer", "FHIRPATH_KEYWORDS", "CONCEPT_MAP_EQUIVALENCE", "StructureMapParser", "parser", "next", "result", "parameters", "rules", "sources", "parts", "whereFhirPath", "OperatorPrecedence", "checkFhirPath", "targets", "transformAtom", "FunctionAtom", "atomToParameter", "LiteralAtom", "SymbolAtom", "identifier", "atom", "arg", "conceptMap", "prefixes", "prefix", "uri", "sourcePrefix", "sourceSystem", "sourceCode", "equivalence", "targetPrefix", "targetSystem", "targetCode", "group", "g", "literalToParameter", "literalAtom", "fhirPathParserBuilder", "initFhirPathParserBuilder", "parseMappingLanguage", "input", "tokenize", "TransformMapCollection", "resources", "resourceType", "url", "result", "r", "pattern", "parts", "structureMapTransform", "structureMap", "input", "transformMaps", "evalStructureMap", "ctx", "evalImports", "registerGlobals", "evalGroup", "getTransformMaps", "importedMaps", "importedMap", "c", "group", "setVariable", "sourceDefinitions", "targetDefinitions", "inputDefinition", "variables", "outputs", "inputIndex", "sourceDefinition", "safeAssign", "targetDefinition", "output", "newContext", "rule", "evalRule", "evalRuleSourceAt", "index", "source", "sourceValue", "evalSource", "evalRuleAfterSources", "tryEvalShorthandRule", "target", "evalTarget", "childRule", "dependent", "evalDependent", "getVariable", "tryFindTypesGroup", "targetContext", "originalValue", "isArray", "isArrayProperty", "targetValue", "setTargetValue", "currentContext", "value", "array", "arrayify", "entry", "sourceContext", "sourceElement", "evalFhirPathTyped", "evalCondition", "evalListMode", "condition", "toJsBoolean", "evalAppend", "evalCast", "evalCc", "evalCopy", "evalCreate", "evalEvaluate", "evalTranslate", "evalTruncate", "generateId", "elementTypes", "tryGetPropertySchema", "elementType", "toTypedValue", "el", "unarrayify", "element", "tryGetDataType", "arg1", "resolveParameter", "arg2", "params", "system", "code", "p", "expr", "buildFhirPathVariables", "args", "mapUri", "conceptMap", "conceptMapTranslate", "targetLength", "dependentGroup", "variable", "variableValue", "parameter", "paramValue", "getTypedPropertyValue", "name", "key", "DEFAULT_INDENT", "FileBuilder", "indent", "header", "line", "nowrap", "first", "wrappedLine", "wordWrap", "text", "maxLength", "result", "length", "word", "MAPPING_LANGUAGE_OPERATORS", "FHIRPATH_OPERATORS", "tokenize", "str", "Tokenizer", "FHIRPATH_KEYWORDS", "FhirFilterComparison", "path", "operator", "value", "FhirFilterNegation", "child", "FhirFilterConnective", "keyword", "left", "right", "operatorMap", "Operator", "getOperator", "value", "operator", "OperationOutcomeError", "badRequest", "FilterParameterParser", "parser", "result", "FhirFilterNegation", "FhirFilterComparison", "next", "FhirFilterConnective", "fhirPathParserBuilder", "initFhirPathParserBuilder", "parseFilterParameter", "input", "tokenize", "AckCode", "TEXT_MSG_FOR_ACK_CODE", "Hl7Context", "segmentSeparator", "fieldSeparator", "componentSeparator", "repetitionSeparator", "escapeCharacter", "subcomponentSeparator", "Hl7Message", "_Hl7Message", "segments", "context", "index", "name", "s", "options", "now", "msh", "sendingApp", "sendingFacility", "receivingApp", "receivingFacility", "controlId", "versionId", "ackCode", "Hl7Segment", "formatHl7DateTime", "messageType", "triggerEvent", "messageStructure", "result", "text", "err", "line", "segment", "existingIndex", "_Hl7Segment", "fields", "isStringArray", "f", "Hl7Field", "fieldIndex", "component", "subcomponent", "repetition", "field", "actualIndex", "value", "_Hl7Field", "components", "r", "subcomponents", "parseHl7DateTime", "hl7DateTime", "year", "parseIntOrDefault", "month", "day", "hour", "minute", "second", "millisecond", "date", "tzOffset", "parseTimeZoneOffset", "str", "defaultValue", "defaultOffset", "offsetStr", "plusIndex", "minusIndex", "sign", "isoDate", "milliseconds", "LogLevel", "LogLevelNames", "Logger", "_Logger", "write", "metadata", "level", "options", "override", "config", "mergedConfig", "msg", "data", "parseLogLevel", "value", "validateResourceType", "resourceType", "OperationOutcomeError", "validationError", "isResourceType", "checkForNull", "value", "path", "issues", "createStructureIssue", "checkArrayForNull", "checkObjectForNull", "array", "i", "obj", "key", "streamToBuffer", "stream", "chunks", "resolve", "reject", "chunk", "err", "evalSqlOnFhir", "view", "resources", "result", "resource", "processResource", "v", "r", "variables", "c", "typedConstant", "getTypedPropertyValue", "typedResource", "toTypedValue", "where", "whereResult", "evalFhirPathTyped", "process", "s", "n", "foci", "f", "parts", "col", "val", "b", "sel", "rows", "urows", "u", "cartesianProduct", "temp", "i", "cartesianProductHelper", "aArray", "bArray", "a", "combinePartialRows", "MEDPLUM_RELEASES_URL", "releaseManifests", "clearReleaseCache", "assertReleaseManifest", "candidate", "manifest", "assets", "asset", "fetchVersionManifest", "appName", "version", "params", "versionTag", "url", "MEDPLUM_VERSION", "key", "value", "res", "message", "err", "normalizeErrorString", "response", "isValidMedplumSemver", "checkIfValidMedplumVersion", "fetchLatestVersionString", "latest", "warnIfNewerVersionAvailable", "current"]
}
